import {
  require_path
} from "./chunk-CCBSYPCA.js";
import {
  require_events,
  require_http,
  require_net,
  require_process,
  require_stream,
  require_timers,
  require_tls,
  require_url,
  require_util,
  require_zlib
} from "./chunk-I7QTQSI7.js";
import {
  require_crypto
} from "./chunk-PZ2OIUX5.js";
import {
  require_node_buffer,
  require_node_stream,
  require_node_util
} from "./chunk-KDGGN65P.js";
import {
  require_buffer,
  require_node_fs,
  require_node_path,
  require_node_process,
  require_worker_threads
} from "./chunk-ZYPHM2GT.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toCommonJS
} from "./chunk-ZDU32GKS.js";

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators2, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d = decorators2[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators2, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators2.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators2[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
      } catch (e) {
        fail(e);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// browser-external:node:events
var require_node_events = __commonJS({
  "browser-external:node:events"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:events" has been externalized for browser compatibility. Cannot access "node:events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@discordjs/util/dist/index.js
var require_dist = __commonJS({
  "node_modules/@discordjs/util/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      calculateShardId: () => calculateShardId,
      getUserAgentAppendix: () => getUserAgentAppendix,
      isEquatable: () => isEquatable,
      isJSONEncodable: () => isJSONEncodable,
      lazy: () => lazy,
      range: () => range,
      shouldUseGlobalFetchAndWebSocket: () => shouldUseGlobalFetchAndWebSocket
    });
    module2.exports = __toCommonJS2(src_exports);
    function lazy(cb) {
      let defaultValue;
      return () => defaultValue ?? (defaultValue = cb());
    }
    __name(lazy, "lazy");
    function* range(range2) {
      let rangeEnd;
      let start = 0;
      let step = 1;
      if (typeof range2 === "number") {
        rangeEnd = range2;
      } else {
        start = range2.start;
        rangeEnd = range2.end;
        step = range2.step ?? 1;
      }
      for (let index = start; index < rangeEnd; index += step) {
        yield index;
      }
    }
    __name(range, "range");
    function calculateShardId(guildId, shardCount) {
      return Number(BigInt(guildId) >> 22n) % shardCount;
    }
    __name(calculateShardId, "calculateShardId");
    function shouldUseGlobalFetchAndWebSocket() {
      if (typeof globalThis.process === "undefined") {
        return "fetch" in globalThis && "WebSocket" in globalThis;
      }
      if ("versions" in globalThis.process) {
        return "deno" in globalThis.process.versions || "bun" in globalThis.process.versions;
      }
      return false;
    }
    __name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
    function getUserAgentAppendix() {
      if (typeof globalThis.EdgeRuntime !== "undefined") {
        return "Vercel-Edge-Functions";
      }
      if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
        return "Cloudflare-Workers";
      }
      if (typeof globalThis.Netlify !== "undefined") {
        return "Netlify-Edge-Functions";
      }
      if (typeof globalThis.process !== "object") {
        if (typeof globalThis.navigator === "object") {
          return globalThis.navigator.userAgent;
        }
        return "UnknownEnvironment";
      }
      if ("versions" in globalThis.process) {
        if ("deno" in globalThis.process.versions) {
          return `Deno/${globalThis.process.versions.deno}`;
        }
        if ("bun" in globalThis.process.versions) {
          return `Bun/${globalThis.process.versions.bun}`;
        }
        if ("node" in globalThis.process.versions) {
          return `Node.js/${globalThis.process.versions.node}`;
        }
      }
      return "UnknownEnvironment";
    }
    __name(getUserAgentAppendix, "getUserAgentAppendix");
    function isJSONEncodable(maybeEncodable) {
      return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
    }
    __name(isJSONEncodable, "isJSONEncodable");
    function isEquatable(maybeEquatable) {
      return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
    }
    __name(isEquatable, "isEquatable");
  }
});

// node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS({
  "node_modules/discord-api-types/gateway/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS({
  "node_modules/discord-api-types/gateway/v10.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GatewayDispatchEvents = exports2.GatewayIntentBits = exports2.GatewayCloseCodes = exports2.GatewayOpcodes = exports2.GatewayVersion = void 0;
    __exportStar2(require_common(), exports2);
    exports2.GatewayVersion = "10";
    var GatewayOpcodes;
    (function(GatewayOpcodes2) {
      GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
      GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
      GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
      GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
      GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
      GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
      GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
      GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
      GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
      GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
      GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
    })(GatewayOpcodes = exports2.GatewayOpcodes || (exports2.GatewayOpcodes = {}));
    var GatewayCloseCodes;
    (function(GatewayCloseCodes2) {
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4e3] = "UnknownError";
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
      GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
      GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
      GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
      GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
      GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
      GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
      GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
    })(GatewayCloseCodes = exports2.GatewayCloseCodes || (exports2.GatewayCloseCodes = {}));
    var GatewayIntentBits;
    (function(GatewayIntentBits2) {
      GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
      GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
      GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
      GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
      GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
      GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
      GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
      GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
      GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
      GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
      GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
      GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
      GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
      GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
    })(GatewayIntentBits = exports2.GatewayIntentBits || (exports2.GatewayIntentBits = {}));
    var GatewayDispatchEvents;
    (function(GatewayDispatchEvents2) {
      GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
      GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
      GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
      GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
      GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
      GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
      GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
      GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
      GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
      GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
      GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
      GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
      GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
      GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
      GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
      GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
      GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
      GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
      GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
      GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
      GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
      GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
      GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
      GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
      GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
      GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
      GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
      GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
      GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
      GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
      GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
      GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
      GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
      GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
      GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
      GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
      GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
      GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
      GatewayDispatchEvents2["Ready"] = "READY";
      GatewayDispatchEvents2["Resumed"] = "RESUMED";
      GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
      GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
      GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
      GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
      GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
      GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
      GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
      GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
      GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
      GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
      GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
      GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
      GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
      GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
      GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
      GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
      GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
      GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
      GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
      GatewayDispatchEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
      GatewayDispatchEvents2["EntitlementUpdate"] = "ENTITLEMENT_UPDATE";
      GatewayDispatchEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    })(GatewayDispatchEvents = exports2.GatewayDispatchEvents || (exports2.GatewayDispatchEvents = {}));
  }
});

// node_modules/discord-api-types/globals.js
var require_globals = __commonJS({
  "node_modules/discord-api-types/globals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormattingPatterns = void 0;
    exports2.FormattingPatterns = {
      /**
       * Regular expression for matching a user mention, strictly without a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      User: /<@(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a user mention, strictly with a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       *
       * @deprecated Passing `!` in user mentions is no longer necessary / supported, and future message contents won't have it
       */
      UserWithNickname: /<@!(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a user mention, with or without a nickname
       *
       * The `id` group property is present on the `exec` result of this expression
       *
       * @deprecated Passing `!` in user mentions is no longer necessary / supported, and future message contents won't have it
       */
      UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a channel mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      Channel: /<#(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a role mention
       *
       * The `id` group property is present on the `exec` result of this expression
       */
      Role: /<@&(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a application command mention
       *
       * The `fullName` (possibly including `name`, `subcommandOrGroup` and `subcommand`) and `id` group properties are present on the `exec` result of this expression
       */
      SlashCommand: (
        // eslint-disable-next-line unicorn/no-unsafe-regex
        /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u
      ),
      /**
       * Regular expression for matching a custom emoji, either static or animated
       *
       * The `animated`, `name` and `id` group properties are present on the `exec` result of this expression
       */
      Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching strictly an animated custom emoji
       *
       * The `animated`, `name` and `id` group properties are present on the `exec` result of this expression
       */
      AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching strictly a static custom emoji
       *
       * The `name` and `id` group properties are present on the `exec` result of this expression
       */
      StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      /**
       * Regular expression for matching a timestamp, either default or custom styled
       *
       * The `timestamp` and `style` group properties are present on the `exec` result of this expression
       */
      // eslint-disable-next-line prefer-named-capture-group
      Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
      /**
       * Regular expression for matching strictly default styled timestamps
       *
       * The `timestamp` group property is present on the `exec` result of this expression
       */
      DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
      /**
       * Regular expression for matching strictly custom styled timestamps
       *
       * The `timestamp` and `style` group properties are present on the `exec` result of this expression
       */
      StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/
    };
    Object.freeze(exports2.FormattingPatterns);
  }
});

// node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS({
  "node_modules/discord-api-types/payloads/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionFlagsBits = void 0;
    exports2.PermissionFlagsBits = {
      /**
       * Allows creation of instant invites
       *
       * Applies to channel types: Text, Voice, Stage
       */
      CreateInstantInvite: 1n << 0n,
      /**
       * Allows kicking members
       */
      // eslint-disable-next-line sonarjs/no-identical-expressions
      KickMembers: 1n << 1n,
      /**
       * Allows banning members
       */
      BanMembers: 1n << 2n,
      /**
       * Allows all permissions and bypasses channel permission overwrites
       */
      Administrator: 1n << 3n,
      /**
       * Allows management and editing of channels
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageChannels: 1n << 4n,
      /**
       * Allows management and editing of the guild
       */
      ManageGuild: 1n << 5n,
      /**
       * Allows for the addition of reactions to messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      AddReactions: 1n << 6n,
      /**
       * Allows for viewing of audit logs
       */
      ViewAuditLog: 1n << 7n,
      /**
       * Allows for using priority speaker in a voice channel
       *
       * Applies to channel types: Voice
       */
      PrioritySpeaker: 1n << 8n,
      /**
       * Allows the user to go live
       *
       * Applies to channel types: Voice, Stage
       */
      Stream: 1n << 9n,
      /**
       * Allows guild members to view a channel, which includes reading messages in text channels and joining voice channels
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ViewChannel: 1n << 10n,
      /**
       * Allows for sending messages in a channel and creating threads in a forum
       * (does not allow sending messages in threads)
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendMessages: 1n << 11n,
      /**
       * Allows for sending of `/tts` messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendTTSMessages: 1n << 12n,
      /**
       * Allows for deletion of other users messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageMessages: 1n << 13n,
      /**
       * Links sent by users with this permission will be auto-embedded
       *
       * Applies to channel types: Text, Voice, Stage
       */
      EmbedLinks: 1n << 14n,
      /**
       * Allows for uploading images and files
       *
       * Applies to channel types: Text, Voice, Stage
       */
      AttachFiles: 1n << 15n,
      /**
       * Allows for reading of message history
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ReadMessageHistory: 1n << 16n,
      /**
       * Allows for using the `@everyone` tag to notify all users in a channel,
       * and the `@here` tag to notify all online users in a channel
       *
       * Applies to channel types: Text, Voice, Stage
       */
      MentionEveryone: 1n << 17n,
      /**
       * Allows the usage of custom emojis from other servers
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseExternalEmojis: 1n << 18n,
      /**
       * Allows for viewing guild insights
       */
      ViewGuildInsights: 1n << 19n,
      /**
       * Allows for joining of a voice channel
       *
       * Applies to channel types: Voice, Stage
       */
      Connect: 1n << 20n,
      /**
       * Allows for speaking in a voice channel
       *
       * Applies to channel types: Voice
       */
      Speak: 1n << 21n,
      /**
       * Allows for muting members in a voice channel
       *
       * Applies to channel types: Voice, Stage
       */
      MuteMembers: 1n << 22n,
      /**
       * Allows for deafening of members in a voice channel
       *
       * Applies to channel types: Voice
       */
      DeafenMembers: 1n << 23n,
      /**
       * Allows for moving of members between voice channels
       *
       * Applies to channel types: Voice, Stage
       */
      MoveMembers: 1n << 24n,
      /**
       * Allows for using voice-activity-detection in a voice channel
       *
       * Applies to channel types: Voice
       */
      UseVAD: 1n << 25n,
      /**
       * Allows for modification of own nickname
       */
      ChangeNickname: 1n << 26n,
      /**
       * Allows for modification of other users nicknames
       */
      ManageNicknames: 1n << 27n,
      /**
       * Allows management and editing of roles
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageRoles: 1n << 28n,
      /**
       * Allows management and editing of webhooks
       *
       * Applies to channel types: Text, Voice, Stage
       */
      ManageWebhooks: 1n << 29n,
      /**
       * Allows management and editing of emojis, stickers, and soundboard sounds
       *
       * @deprecated This is the old name for {@apilink PermissionFlagsBits#ManageGuildExpressions}
       */
      ManageEmojisAndStickers: 1n << 30n,
      /**
       * Allows management and editing of emojis, stickers, and soundboard sounds
       */
      ManageGuildExpressions: 1n << 30n,
      /**
       * Allows members to use application commands, including slash commands and context menu commands
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseApplicationCommands: 1n << 31n,
      /**
       * Allows for requesting to speak in stage channels
       *
       * Applies to channel types: Stage
       */
      RequestToSpeak: 1n << 32n,
      /**
       * Allows for creating, editing, and deleting scheduled events
       *
       * Applies to channel types: Voice, Stage
       */
      ManageEvents: 1n << 33n,
      /**
       * Allows for deleting and archiving threads, and viewing all private threads
       *
       * Applies to channel types: Text
       */
      ManageThreads: 1n << 34n,
      /**
       * Allows for creating public and announcement threads
       *
       * Applies to channel types: Text
       */
      CreatePublicThreads: 1n << 35n,
      /**
       * Allows for creating private threads
       *
       * Applies to channel types: Text
       */
      CreatePrivateThreads: 1n << 36n,
      /**
       * Allows the usage of custom stickers from other servers
       *
       * Applies to channel types: Text, Voice, Stage
       */
      UseExternalStickers: 1n << 37n,
      /**
       * Allows for sending messages in threads
       *
       * Applies to channel types: Text
       */
      SendMessagesInThreads: 1n << 38n,
      /**
       * Allows for using Activities (applications with the {@apilink ApplicationFlags.Embedded} flag) in a voice channel
       *
       * Applies to channel types: Voice
       */
      UseEmbeddedActivities: 1n << 39n,
      /**
       * Allows for timing out users to prevent them from sending or reacting to messages in chat and threads,
       * and from speaking in voice and stage channels
       */
      ModerateMembers: 1n << 40n,
      /**
       * Allows for viewing role subscription insights
       */
      ViewCreatorMonetizationAnalytics: 1n << 41n,
      /**
       * Allows for using soundboard in a voice channel
       *
       * Applies to channel types: Voice
       */
      UseSoundboard: 1n << 42n,
      /**
       * Allows the usage of custom soundboard sounds from other servers
       *
       * Applies to channel types: Voice
       */
      UseExternalSounds: 1n << 45n,
      /**
       * Allows sending voice messages
       *
       * Applies to channel types: Text, Voice, Stage
       */
      SendVoiceMessages: 1n << 46n
    };
    Object.freeze(exports2.PermissionFlagsBits);
  }
});

// node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS({
  "node_modules/discord-api-types/payloads/v10/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationRoleConnectionMetadataType = exports2.ApplicationFlags = void 0;
    var ApplicationFlags;
    (function(ApplicationFlags2) {
      ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
      ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
      ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
      ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
      ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
      ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
      ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
      ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
      ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
      ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
      ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
      ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
    })(ApplicationFlags = exports2.ApplicationFlags || (exports2.ApplicationFlags = {}));
    var ApplicationRoleConnectionMetadataType;
    (function(ApplicationRoleConnectionMetadataType2) {
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
      ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
    })(ApplicationRoleConnectionMetadataType = exports2.ApplicationRoleConnectionMetadataType || (exports2.ApplicationRoleConnectionMetadataType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS({
  "node_modules/discord-api-types/payloads/v10/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuditLogOptionsType = exports2.AuditLogEvent = void 0;
    var AuditLogEvent;
    (function(AuditLogEvent2) {
      AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
      AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
      AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
      AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
      AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
      AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
      AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
      AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
      AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
      AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
      AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
      AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
      AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
      AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
      AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
      AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
      AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
      AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
      AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
      AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
      AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
      AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
      AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
      AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
      AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
      AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
      AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
      AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
      AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
      AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
      AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
      AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
      AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
      AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
      AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
      AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
      AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
      AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
      AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
      AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
    })(AuditLogEvent = exports2.AuditLogEvent || (exports2.AuditLogEvent = {}));
    var AuditLogOptionsType;
    (function(AuditLogOptionsType2) {
      AuditLogOptionsType2["Role"] = "0";
      AuditLogOptionsType2["Member"] = "1";
    })(AuditLogOptionsType = exports2.AuditLogOptionsType || (exports2.AuditLogOptionsType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS({
  "node_modules/discord-api-types/payloads/v10/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoModerationActionType = exports2.AutoModerationRuleEventType = exports2.AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleTriggerType = void 0;
    var AutoModerationRuleTriggerType;
    (function(AutoModerationRuleTriggerType2) {
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
    })(AutoModerationRuleTriggerType = exports2.AutoModerationRuleTriggerType || (exports2.AutoModerationRuleTriggerType = {}));
    var AutoModerationRuleKeywordPresetType;
    (function(AutoModerationRuleKeywordPresetType2) {
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
    })(AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleKeywordPresetType || (exports2.AutoModerationRuleKeywordPresetType = {}));
    var AutoModerationRuleEventType;
    (function(AutoModerationRuleEventType2) {
      AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
    })(AutoModerationRuleEventType = exports2.AutoModerationRuleEventType || (exports2.AutoModerationRuleEventType = {}));
    var AutoModerationActionType;
    (function(AutoModerationActionType2) {
      AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
      AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
      AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
    })(AutoModerationActionType = exports2.AutoModerationActionType || (exports2.AutoModerationActionType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS({
  "node_modules/discord-api-types/payloads/v10/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelFlags = exports2.SelectMenuDefaultValueType = exports2.TextInputStyle = exports2.ButtonStyle = exports2.ComponentType = exports2.AllowedMentionsTypes = exports2.AttachmentFlags = exports2.EmbedType = exports2.ThreadMemberFlags = exports2.ThreadAutoArchiveDuration = exports2.OverwriteType = exports2.MessageFlags = exports2.MessageActivityType = exports2.MessageType = exports2.VideoQualityMode = exports2.ChannelType = exports2.ForumLayoutType = exports2.SortOrderType = void 0;
    var SortOrderType;
    (function(SortOrderType2) {
      SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
      SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
    })(SortOrderType = exports2.SortOrderType || (exports2.SortOrderType = {}));
    var ForumLayoutType;
    (function(ForumLayoutType2) {
      ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
      ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
      ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
    })(ForumLayoutType = exports2.ForumLayoutType || (exports2.ForumLayoutType = {}));
    var ChannelType;
    (function(ChannelType2) {
      ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
      ChannelType2[ChannelType2["DM"] = 1] = "DM";
      ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
      ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
      ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
      ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
      ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
      ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
      ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
      ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
      ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
      ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
      ChannelType2[ChannelType2["GuildMedia"] = 16] = "GuildMedia";
      ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
      ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
      ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
      ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
    })(ChannelType = exports2.ChannelType || (exports2.ChannelType = {}));
    var VideoQualityMode;
    (function(VideoQualityMode2) {
      VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
      VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
    })(VideoQualityMode = exports2.VideoQualityMode || (exports2.VideoQualityMode = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["Default"] = 0] = "Default";
      MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
      MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
      MessageType2[MessageType2["Call"] = 3] = "Call";
      MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
      MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
      MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
      MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
      MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
      MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
      MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
      MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
      MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
      MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
      MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
      MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
      MessageType2[MessageType2["Reply"] = 19] = "Reply";
      MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
      MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
      MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
      MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
      MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
      MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
      MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
      MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
      MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
      MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
      MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
      MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
      MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var MessageActivityType;
    (function(MessageActivityType2) {
      MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
      MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
      MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
      MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
    })(MessageActivityType = exports2.MessageActivityType || (exports2.MessageActivityType = {}));
    var MessageFlags;
    (function(MessageFlags2) {
      MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
      MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
      MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
      MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
      MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
      MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
      MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
      MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
      MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
      MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
      MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
      MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
    })(MessageFlags = exports2.MessageFlags || (exports2.MessageFlags = {}));
    var OverwriteType;
    (function(OverwriteType2) {
      OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
      OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
    })(OverwriteType = exports2.OverwriteType || (exports2.OverwriteType = {}));
    var ThreadAutoArchiveDuration;
    (function(ThreadAutoArchiveDuration2) {
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
    })(ThreadAutoArchiveDuration = exports2.ThreadAutoArchiveDuration || (exports2.ThreadAutoArchiveDuration = {}));
    var ThreadMemberFlags;
    (function(ThreadMemberFlags2) {
      ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
      ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
      ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
      ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
    })(ThreadMemberFlags = exports2.ThreadMemberFlags || (exports2.ThreadMemberFlags = {}));
    var EmbedType;
    (function(EmbedType2) {
      EmbedType2["Rich"] = "rich";
      EmbedType2["Image"] = "image";
      EmbedType2["Video"] = "video";
      EmbedType2["GIFV"] = "gifv";
      EmbedType2["Article"] = "article";
      EmbedType2["Link"] = "link";
      EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
    })(EmbedType = exports2.EmbedType || (exports2.EmbedType = {}));
    var AttachmentFlags;
    (function(AttachmentFlags2) {
      AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
    })(AttachmentFlags = exports2.AttachmentFlags || (exports2.AttachmentFlags = {}));
    var AllowedMentionsTypes;
    (function(AllowedMentionsTypes2) {
      AllowedMentionsTypes2["Everyone"] = "everyone";
      AllowedMentionsTypes2["Role"] = "roles";
      AllowedMentionsTypes2["User"] = "users";
    })(AllowedMentionsTypes = exports2.AllowedMentionsTypes || (exports2.AllowedMentionsTypes = {}));
    var ComponentType;
    (function(ComponentType2) {
      ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
      ComponentType2[ComponentType2["Button"] = 2] = "Button";
      ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
      ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
      ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
      ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
      ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
      ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
      ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
    })(ComponentType = exports2.ComponentType || (exports2.ComponentType = {}));
    var ButtonStyle;
    (function(ButtonStyle2) {
      ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
      ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
      ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
      ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
      ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
    })(ButtonStyle = exports2.ButtonStyle || (exports2.ButtonStyle = {}));
    var TextInputStyle;
    (function(TextInputStyle2) {
      TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
      TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
    })(TextInputStyle = exports2.TextInputStyle || (exports2.TextInputStyle = {}));
    var SelectMenuDefaultValueType;
    (function(SelectMenuDefaultValueType2) {
      SelectMenuDefaultValueType2["Channel"] = "channel";
      SelectMenuDefaultValueType2["Role"] = "role";
      SelectMenuDefaultValueType2["User"] = "user";
    })(SelectMenuDefaultValueType = exports2.SelectMenuDefaultValueType || (exports2.SelectMenuDefaultValueType = {}));
    var ChannelFlags;
    (function(ChannelFlags2) {
      ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
      ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
      ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
      ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
      ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
      ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
      ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
      ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
      ChannelFlags2[ChannelFlags2["HideMediaDownloadOptions"] = 32768] = "HideMediaDownloadOptions";
    })(ChannelFlags = exports2.ChannelFlags || (exports2.ChannelFlags = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/emoji.js
var require_emoji = __commonJS({
  "node_modules/discord-api-types/payloads/v10/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS({
  "node_modules/discord-api-types/payloads/v10/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityFlags = exports2.ActivityType = exports2.ActivityPlatform = exports2.PresenceUpdateStatus = void 0;
    var PresenceUpdateStatus;
    (function(PresenceUpdateStatus2) {
      PresenceUpdateStatus2["Online"] = "online";
      PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
      PresenceUpdateStatus2["Idle"] = "idle";
      PresenceUpdateStatus2["Invisible"] = "invisible";
      PresenceUpdateStatus2["Offline"] = "offline";
    })(PresenceUpdateStatus = exports2.PresenceUpdateStatus || (exports2.PresenceUpdateStatus = {}));
    var ActivityPlatform;
    (function(ActivityPlatform2) {
      ActivityPlatform2["Desktop"] = "desktop";
      ActivityPlatform2["Xbox"] = "xbox";
      ActivityPlatform2["Samsung"] = "samsung";
      ActivityPlatform2["IOS"] = "ios";
      ActivityPlatform2["Android"] = "android";
      ActivityPlatform2["Embedded"] = "embedded";
      ActivityPlatform2["PS4"] = "ps4";
      ActivityPlatform2["PS5"] = "ps5";
    })(ActivityPlatform = exports2.ActivityPlatform || (exports2.ActivityPlatform = {}));
    var ActivityType;
    (function(ActivityType2) {
      ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
      ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
      ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
      ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
      ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
      ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
    })(ActivityType = exports2.ActivityType || (exports2.ActivityType = {}));
    var ActivityFlags;
    (function(ActivityFlags2) {
      ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
      ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
      ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
      ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
      ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
      ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
      ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
      ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
      ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
    })(ActivityFlags = exports2.ActivityFlags || (exports2.ActivityFlags = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS({
  "node_modules/discord-api-types/payloads/v10/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GuildOnboardingPromptType = exports2.GuildOnboardingMode = exports2.MembershipScreeningFieldType = exports2.GuildWidgetStyle = exports2.IntegrationExpireBehavior = exports2.GuildMemberFlags = exports2.GuildFeature = exports2.GuildSystemChannelFlags = exports2.GuildHubType = exports2.GuildPremiumTier = exports2.GuildVerificationLevel = exports2.GuildNSFWLevel = exports2.GuildMFALevel = exports2.GuildExplicitContentFilter = exports2.GuildDefaultMessageNotifications = void 0;
    var GuildDefaultMessageNotifications;
    (function(GuildDefaultMessageNotifications2) {
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
    })(GuildDefaultMessageNotifications = exports2.GuildDefaultMessageNotifications || (exports2.GuildDefaultMessageNotifications = {}));
    var GuildExplicitContentFilter;
    (function(GuildExplicitContentFilter2) {
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
    })(GuildExplicitContentFilter = exports2.GuildExplicitContentFilter || (exports2.GuildExplicitContentFilter = {}));
    var GuildMFALevel;
    (function(GuildMFALevel2) {
      GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
      GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
    })(GuildMFALevel = exports2.GuildMFALevel || (exports2.GuildMFALevel = {}));
    var GuildNSFWLevel;
    (function(GuildNSFWLevel2) {
      GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
      GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
      GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
      GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
    })(GuildNSFWLevel = exports2.GuildNSFWLevel || (exports2.GuildNSFWLevel = {}));
    var GuildVerificationLevel;
    (function(GuildVerificationLevel2) {
      GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
      GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
      GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
      GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
      GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
    })(GuildVerificationLevel = exports2.GuildVerificationLevel || (exports2.GuildVerificationLevel = {}));
    var GuildPremiumTier;
    (function(GuildPremiumTier2) {
      GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
      GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
      GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
      GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
    })(GuildPremiumTier = exports2.GuildPremiumTier || (exports2.GuildPremiumTier = {}));
    var GuildHubType;
    (function(GuildHubType2) {
      GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
      GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
      GuildHubType2[GuildHubType2["College"] = 2] = "College";
    })(GuildHubType = exports2.GuildHubType || (exports2.GuildHubType = {}));
    var GuildSystemChannelFlags;
    (function(GuildSystemChannelFlags2) {
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
    })(GuildSystemChannelFlags = exports2.GuildSystemChannelFlags || (exports2.GuildSystemChannelFlags = {}));
    var GuildFeature;
    (function(GuildFeature2) {
      GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
      GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
      GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
      GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
      GuildFeature2["Banner"] = "BANNER";
      GuildFeature2["Community"] = "COMMUNITY";
      GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
      GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
      GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
      GuildFeature2["Discoverable"] = "DISCOVERABLE";
      GuildFeature2["Featurable"] = "FEATURABLE";
      GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
      GuildFeature2["Hub"] = "HUB";
      GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
      GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
      GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
      GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
      GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
      GuildFeature2["MoreStickers"] = "MORE_STICKERS";
      GuildFeature2["News"] = "NEWS";
      GuildFeature2["Partnered"] = "PARTNERED";
      GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
      GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
      GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
      GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
      GuildFeature2["RoleIcons"] = "ROLE_ICONS";
      GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
      GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
      GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
      GuildFeature2["VanityURL"] = "VANITY_URL";
      GuildFeature2["Verified"] = "VERIFIED";
      GuildFeature2["VIPRegions"] = "VIP_REGIONS";
      GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
    })(GuildFeature = exports2.GuildFeature || (exports2.GuildFeature = {}));
    var GuildMemberFlags;
    (function(GuildMemberFlags2) {
      GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
      GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
      GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
      GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
      GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
      GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
      GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
      GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
    })(GuildMemberFlags = exports2.GuildMemberFlags || (exports2.GuildMemberFlags = {}));
    var IntegrationExpireBehavior;
    (function(IntegrationExpireBehavior2) {
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
    })(IntegrationExpireBehavior = exports2.IntegrationExpireBehavior || (exports2.IntegrationExpireBehavior = {}));
    var GuildWidgetStyle;
    (function(GuildWidgetStyle2) {
      GuildWidgetStyle2["Shield"] = "shield";
      GuildWidgetStyle2["Banner1"] = "banner1";
      GuildWidgetStyle2["Banner2"] = "banner2";
      GuildWidgetStyle2["Banner3"] = "banner3";
      GuildWidgetStyle2["Banner4"] = "banner4";
    })(GuildWidgetStyle = exports2.GuildWidgetStyle || (exports2.GuildWidgetStyle = {}));
    var MembershipScreeningFieldType;
    (function(MembershipScreeningFieldType2) {
      MembershipScreeningFieldType2["Terms"] = "TERMS";
    })(MembershipScreeningFieldType = exports2.MembershipScreeningFieldType || (exports2.MembershipScreeningFieldType = {}));
    var GuildOnboardingMode;
    (function(GuildOnboardingMode2) {
      GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
      GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
    })(GuildOnboardingMode = exports2.GuildOnboardingMode || (exports2.GuildOnboardingMode = {}));
    var GuildOnboardingPromptType;
    (function(GuildOnboardingPromptType2) {
      GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
      GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
    })(GuildOnboardingPromptType = exports2.GuildOnboardingPromptType || (exports2.GuildOnboardingPromptType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS({
  "node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventStatus = exports2.GuildScheduledEventEntityType = void 0;
    var GuildScheduledEventEntityType;
    (function(GuildScheduledEventEntityType2) {
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
    })(GuildScheduledEventEntityType = exports2.GuildScheduledEventEntityType || (exports2.GuildScheduledEventEntityType = {}));
    var GuildScheduledEventStatus;
    (function(GuildScheduledEventStatus2) {
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
    })(GuildScheduledEventStatus = exports2.GuildScheduledEventStatus || (exports2.GuildScheduledEventStatus = {}));
    var GuildScheduledEventPrivacyLevel;
    (function(GuildScheduledEventPrivacyLevel2) {
      GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventPrivacyLevel || (exports2.GuildScheduledEventPrivacyLevel = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandOptionType = void 0;
    var ApplicationCommandOptionType;
    (function(ApplicationCommandOptionType2) {
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
    })(ApplicationCommandOptionType = exports2.ApplicationCommandOptionType || (exports2.ApplicationCommandOptionType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_attachment(), exports2);
    __exportStar2(require_base(), exports2);
    __exportStar2(require_boolean(), exports2);
    __exportStar2(require_channel2(), exports2);
    __exportStar2(require_integer(), exports2);
    __exportStar2(require_mentionable(), exports2);
    __exportStar2(require_number(), exports2);
    __exportStar2(require_role(), exports2);
    __exportStar2(require_shared(), exports2);
    __exportStar2(require_string(), exports2);
    __exportStar2(require_subcommand(), exports2);
    __exportStar2(require_subcommandGroup(), exports2);
    __exportStar2(require_user(), exports2);
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APIApplicationCommandPermissionsConstant = exports2.ApplicationCommandPermissionType = void 0;
    var ApplicationCommandPermissionType;
    (function(ApplicationCommandPermissionType2) {
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
    })(ApplicationCommandPermissionType = exports2.ApplicationCommandPermissionType || (exports2.ApplicationCommandPermissionType = {}));
    exports2.APIApplicationCommandPermissionsConstant = {
      // eslint-disable-next-line unicorn/prefer-native-coercion-functions
      Everyone: (guildId) => String(guildId),
      AllChannels: (guildId) => String(BigInt(guildId) - 1n)
    };
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandType = void 0;
    __exportStar2(require_chatInput(), exports2);
    __exportStar2(require_contextMenu(), exports2);
    __exportStar2(require_permissions(), exports2);
    var ApplicationCommandType;
    (function(ApplicationCommandType2) {
      ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
      ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
      ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
    })(ApplicationCommandType = exports2.ApplicationCommandType || (exports2.ApplicationCommandType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js
var require_autocomplete = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/base.js
var require_base2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js
var require_messageComponents = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/ping.js
var require_ping = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/ping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS({
  "node_modules/discord-api-types/payloads/v10/_interactions/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionResponseType = exports2.InteractionType = void 0;
    var InteractionType;
    (function(InteractionType2) {
      InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
      InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
      InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
      InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
      InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
    })(InteractionType = exports2.InteractionType || (exports2.InteractionType = {}));
    var InteractionResponseType;
    (function(InteractionResponseType2) {
      InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
      InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
      InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
      InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
      InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
      InteractionResponseType2[InteractionResponseType2["PremiumRequired"] = 10] = "PremiumRequired";
    })(InteractionResponseType = exports2.InteractionResponseType || (exports2.InteractionResponseType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS({
  "node_modules/discord-api-types/payloads/v10/interactions.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_applicationCommands(), exports2);
    __exportStar2(require_autocomplete(), exports2);
    __exportStar2(require_base2(), exports2);
    __exportStar2(require_messageComponents(), exports2);
    __exportStar2(require_modalSubmit(), exports2);
    __exportStar2(require_ping(), exports2);
    __exportStar2(require_responses(), exports2);
  }
});

// node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS({
  "node_modules/discord-api-types/payloads/v10/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InviteTargetType = void 0;
    var InviteTargetType;
    (function(InviteTargetType2) {
      InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
      InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
    })(InviteTargetType = exports2.InviteTargetType || (exports2.InviteTargetType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Scopes = void 0;
    var OAuth2Scopes2;
    (function(OAuth2Scopes3) {
      OAuth2Scopes3["Bot"] = "bot";
      OAuth2Scopes3["Connections"] = "connections";
      OAuth2Scopes3["DMChannelsRead"] = "dm_channels.read";
      OAuth2Scopes3["Email"] = "email";
      OAuth2Scopes3["Identify"] = "identify";
      OAuth2Scopes3["Guilds"] = "guilds";
      OAuth2Scopes3["GuildsJoin"] = "guilds.join";
      OAuth2Scopes3["GuildsMembersRead"] = "guilds.members.read";
      OAuth2Scopes3["GroupDMJoins"] = "gdm.join";
      OAuth2Scopes3["MessagesRead"] = "messages.read";
      OAuth2Scopes3["RoleConnectionsWrite"] = "role_connections.write";
      OAuth2Scopes3["RPC"] = "rpc";
      OAuth2Scopes3["RPCNotificationsRead"] = "rpc.notifications.read";
      OAuth2Scopes3["WebhookIncoming"] = "webhook.incoming";
      OAuth2Scopes3["Voice"] = "voice";
      OAuth2Scopes3["ApplicationsBuildsUpload"] = "applications.builds.upload";
      OAuth2Scopes3["ApplicationsBuildsRead"] = "applications.builds.read";
      OAuth2Scopes3["ApplicationsStoreUpdate"] = "applications.store.update";
      OAuth2Scopes3["ApplicationsEntitlements"] = "applications.entitlements";
      OAuth2Scopes3["RelationshipsRead"] = "relationships.read";
      OAuth2Scopes3["ActivitiesRead"] = "activities.read";
      OAuth2Scopes3["ActivitiesWrite"] = "activities.write";
      OAuth2Scopes3["ApplicationsCommands"] = "applications.commands";
      OAuth2Scopes3["ApplicationsCommandsUpdate"] = "applications.commands.update";
      OAuth2Scopes3["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
    })(OAuth2Scopes2 = exports2.OAuth2Scopes || (exports2.OAuth2Scopes = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RoleFlags = void 0;
    var RoleFlags;
    (function(RoleFlags2) {
      RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
    })(RoleFlags = exports2.RoleFlags || (exports2.RoleFlags = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS({
  "node_modules/discord-api-types/payloads/v10/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StageInstancePrivacyLevel = void 0;
    var StageInstancePrivacyLevel;
    (function(StageInstancePrivacyLevel2) {
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(StageInstancePrivacyLevel = exports2.StageInstancePrivacyLevel || (exports2.StageInstancePrivacyLevel = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS({
  "node_modules/discord-api-types/payloads/v10/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StickerFormatType = exports2.StickerType = void 0;
    var StickerType;
    (function(StickerType2) {
      StickerType2[StickerType2["Standard"] = 1] = "Standard";
      StickerType2[StickerType2["Guild"] = 2] = "Guild";
    })(StickerType = exports2.StickerType || (exports2.StickerType = {}));
    var StickerFormatType;
    (function(StickerFormatType2) {
      StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
      StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
      StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
      StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
    })(StickerFormatType = exports2.StickerFormatType || (exports2.StickerFormatType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS({
  "node_modules/discord-api-types/payloads/v10/teams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TeamMemberRole = exports2.TeamMemberMembershipState = void 0;
    var TeamMemberMembershipState;
    (function(TeamMemberMembershipState2) {
      TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
      TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
    })(TeamMemberMembershipState = exports2.TeamMemberMembershipState || (exports2.TeamMemberMembershipState = {}));
    var TeamMemberRole;
    (function(TeamMemberRole2) {
      TeamMemberRole2["Admin"] = "admin";
      TeamMemberRole2["Developer"] = "developer";
      TeamMemberRole2["ReadOnly"] = "read_only";
    })(TeamMemberRole = exports2.TeamMemberRole || (exports2.TeamMemberRole = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/template.js
var require_template = __commonJS({
  "node_modules/discord-api-types/payloads/v10/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/user.js
var require_user2 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionVisibility = exports2.ConnectionService = exports2.UserPremiumType = exports2.UserFlags = void 0;
    var UserFlags;
    (function(UserFlags2) {
      UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
      UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
      UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
      UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
      UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
      UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
      UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
      UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
      UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
      UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
      UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
      UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
      UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
      UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
      UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
      UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
      UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
      UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
      UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
      UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
    })(UserFlags = exports2.UserFlags || (exports2.UserFlags = {}));
    var UserPremiumType;
    (function(UserPremiumType2) {
      UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
      UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
      UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
      UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
    })(UserPremiumType = exports2.UserPremiumType || (exports2.UserPremiumType = {}));
    var ConnectionService;
    (function(ConnectionService2) {
      ConnectionService2["BattleNet"] = "battlenet";
      ConnectionService2["eBay"] = "ebay";
      ConnectionService2["EpicGames"] = "epicgames";
      ConnectionService2["Facebook"] = "facebook";
      ConnectionService2["GitHub"] = "github";
      ConnectionService2["Instagram"] = "instagram";
      ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
      ConnectionService2["PayPal"] = "paypal";
      ConnectionService2["PlayStationNetwork"] = "playstation";
      ConnectionService2["Reddit"] = "reddit";
      ConnectionService2["RiotGames"] = "riotgames";
      ConnectionService2["Spotify"] = "spotify";
      ConnectionService2["Skype"] = "skype";
      ConnectionService2["Steam"] = "steam";
      ConnectionService2["TikTok"] = "tiktok";
      ConnectionService2["Twitch"] = "twitch";
      ConnectionService2["X"] = "twitter";
      ConnectionService2["Twitter"] = "twitter";
      ConnectionService2["Xbox"] = "xbox";
      ConnectionService2["YouTube"] = "youtube";
    })(ConnectionService = exports2.ConnectionService || (exports2.ConnectionService = {}));
    var ConnectionVisibility;
    (function(ConnectionVisibility2) {
      ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
      ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
    })(ConnectionVisibility = exports2.ConnectionVisibility || (exports2.ConnectionVisibility = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/voice.js
var require_voice = __commonJS({
  "node_modules/discord-api-types/payloads/v10/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS({
  "node_modules/discord-api-types/payloads/v10/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebhookType = void 0;
    var WebhookType;
    (function(WebhookType2) {
      WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
      WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
      WebhookType2[WebhookType2["Application"] = 3] = "Application";
    })(WebhookType = exports2.WebhookType || (exports2.WebhookType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/monetization.js
var require_monetization = __commonJS({
  "node_modules/discord-api-types/payloads/v10/monetization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SKUType = exports2.SKUFlags = exports2.EntitlementType = void 0;
    var EntitlementType;
    (function(EntitlementType2) {
      EntitlementType2[EntitlementType2["ApplicationSubscription"] = 8] = "ApplicationSubscription";
    })(EntitlementType = exports2.EntitlementType || (exports2.EntitlementType = {}));
    var SKUFlags;
    (function(SKUFlags2) {
      SKUFlags2[SKUFlags2["Available"] = 4] = "Available";
      SKUFlags2[SKUFlags2["GuildSubscription"] = 128] = "GuildSubscription";
      SKUFlags2[SKUFlags2["UserSubscription"] = 256] = "UserSubscription";
    })(SKUFlags = exports2.SKUFlags || (exports2.SKUFlags = {}));
    var SKUType;
    (function(SKUType2) {
      SKUType2[SKUType2["Subscription"] = 5] = "Subscription";
      SKUType2[SKUType2["SubscriptionGroup"] = 6] = "SubscriptionGroup";
    })(SKUType = exports2.SKUType || (exports2.SKUType = {}));
  }
});

// node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS({
  "node_modules/discord-api-types/payloads/v10/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_common2(), exports2);
    __exportStar2(require_application(), exports2);
    __exportStar2(require_auditLog(), exports2);
    __exportStar2(require_autoModeration(), exports2);
    __exportStar2(require_channel(), exports2);
    __exportStar2(require_emoji(), exports2);
    __exportStar2(require_gateway(), exports2);
    __exportStar2(require_guild(), exports2);
    __exportStar2(require_guildScheduledEvent(), exports2);
    __exportStar2(require_interactions(), exports2);
    __exportStar2(require_invite(), exports2);
    __exportStar2(require_oauth2(), exports2);
    __exportStar2(require_permissions2(), exports2);
    __exportStar2(require_stageInstance(), exports2);
    __exportStar2(require_sticker(), exports2);
    __exportStar2(require_teams(), exports2);
    __exportStar2(require_template(), exports2);
    __exportStar2(require_user2(), exports2);
    __exportStar2(require_voice(), exports2);
    __exportStar2(require_webhook(), exports2);
    __exportStar2(require_monetization(), exports2);
  }
});

// node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS({
  "node_modules/discord-api-types/rest/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Locale = exports2.RESTJSONErrorCodes = void 0;
    var RESTJSONErrorCodes;
    (function(RESTJSONErrorCodes2) {
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 13e4] = "APIResourceOverloaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 18e4] = "CannotUpdateAFinishedEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 2e5] = "MessageWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 24e4] = "MessageBlockedByHarmfulLinksFilter";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 35e4] = "CannotEnableOnboardingRequirementsAreNotMet";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
    })(RESTJSONErrorCodes = exports2.RESTJSONErrorCodes || (exports2.RESTJSONErrorCodes = {}));
    var Locale;
    (function(Locale2) {
      Locale2["Indonesian"] = "id";
      Locale2["EnglishUS"] = "en-US";
      Locale2["EnglishGB"] = "en-GB";
      Locale2["Bulgarian"] = "bg";
      Locale2["ChineseCN"] = "zh-CN";
      Locale2["ChineseTW"] = "zh-TW";
      Locale2["Croatian"] = "hr";
      Locale2["Czech"] = "cs";
      Locale2["Danish"] = "da";
      Locale2["Dutch"] = "nl";
      Locale2["Finnish"] = "fi";
      Locale2["French"] = "fr";
      Locale2["German"] = "de";
      Locale2["Greek"] = "el";
      Locale2["Hindi"] = "hi";
      Locale2["Hungarian"] = "hu";
      Locale2["Italian"] = "it";
      Locale2["Japanese"] = "ja";
      Locale2["Korean"] = "ko";
      Locale2["Lithuanian"] = "lt";
      Locale2["Norwegian"] = "no";
      Locale2["Polish"] = "pl";
      Locale2["PortugueseBR"] = "pt-BR";
      Locale2["Romanian"] = "ro";
      Locale2["Russian"] = "ru";
      Locale2["SpanishES"] = "es-ES";
      Locale2["Swedish"] = "sv-SE";
      Locale2["Thai"] = "th";
      Locale2["Turkish"] = "tr";
      Locale2["Ukrainian"] = "uk";
      Locale2["Vietnamese"] = "vi";
    })(Locale = exports2.Locale || (exports2.Locale = {}));
  }
});

// node_modules/discord-api-types/rest/v10/application.js
var require_application2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/auditLog.js
var require_auditLog2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/autoModeration.js
var require_autoModeration2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/channel.js
var require_channel3 = __commonJS({
  "node_modules/discord-api-types/rest/v10/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/emoji.js
var require_emoji2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/gateway.js
var require_gateway2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/guild.js
var require_guild2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/interactions.js
var require_interactions2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/interactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/invite.js
var require_invite2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/oauth2.js
var require_oauth22 = __commonJS({
  "node_modules/discord-api-types/rest/v10/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/stageInstance.js
var require_stageInstance2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/sticker.js
var require_sticker2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/template.js
var require_template2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/user.js
var require_user3 = __commonJS({
  "node_modules/discord-api-types/rest/v10/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/voice.js
var require_voice2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/webhook.js
var require_webhook2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/discord-api-types/rest/v10/monetization.js
var require_monetization2 = __commonJS({
  "node_modules/discord-api-types/rest/v10/monetization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EntitlementOwnerType = void 0;
    var EntitlementOwnerType;
    (function(EntitlementOwnerType2) {
      EntitlementOwnerType2[EntitlementOwnerType2["Guild"] = 1] = "Guild";
      EntitlementOwnerType2[EntitlementOwnerType2["User"] = 2] = "User";
    })(EntitlementOwnerType = exports2.EntitlementOwnerType || (exports2.EntitlementOwnerType = {}));
  }
});

// node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS({
  "node_modules/discord-api-types/rest/v10/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Routes = exports2.RouteBases = exports2.ImageFormat = exports2.CDNRoutes = exports2.StickerPackApplicationId = exports2.Routes = exports2.APIVersion = void 0;
    __exportStar2(require_common3(), exports2);
    __exportStar2(require_application2(), exports2);
    __exportStar2(require_auditLog2(), exports2);
    __exportStar2(require_autoModeration2(), exports2);
    __exportStar2(require_channel3(), exports2);
    __exportStar2(require_emoji2(), exports2);
    __exportStar2(require_gateway2(), exports2);
    __exportStar2(require_guild2(), exports2);
    __exportStar2(require_guildScheduledEvent2(), exports2);
    __exportStar2(require_interactions2(), exports2);
    __exportStar2(require_invite2(), exports2);
    __exportStar2(require_oauth22(), exports2);
    __exportStar2(require_stageInstance2(), exports2);
    __exportStar2(require_sticker2(), exports2);
    __exportStar2(require_template2(), exports2);
    __exportStar2(require_user3(), exports2);
    __exportStar2(require_voice2(), exports2);
    __exportStar2(require_webhook2(), exports2);
    __exportStar2(require_monetization2(), exports2);
    exports2.APIVersion = "10";
    exports2.Routes = {
      /**
       * Route for:
       * - GET `/applications/{application.id}/role-connections/metadata`
       * - PUT `/applications/{application.id}/role-connections/metadata`
       */
      applicationRoleConnectionMetadata(applicationId) {
        return `/applications/${applicationId}/role-connections/metadata`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/auto-moderation/rules`
       * - POST `/guilds/{guild.id}/auto-moderation/rules`
       */
      guildAutoModerationRules(guildId) {
        return `/guilds/${guildId}/auto-moderation/rules`;
      },
      /**
       * Routes for:
       * - GET    `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       * - PATCH  `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       * - DELETE `/guilds/{guild.id}/auto-moderation/rules/{rule.id}`
       */
      guildAutoModerationRule(guildId, ruleId) {
        return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/audit-logs`
       */
      guildAuditLog(guildId) {
        return `/guilds/${guildId}/audit-logs`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}`
       * - PATCH  `/channels/{channel.id}`
       * - DELETE `/channels/{channel.id}`
       */
      channel(channelId) {
        return `/channels/${channelId}`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/messages`
       * - POST `/channels/{channel.id}/messages`
       */
      channelMessages(channelId) {
        return `/channels/${channelId}/messages`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}/messages/{message.id}`
       * - PATCH  `/channels/{channel.id}/messages/{message.id}`
       * - DELETE `/channels/{channel.id}/messages/{message.id}`
       */
      channelMessage(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/messages/{message.id}/crosspost`
       */
      channelMessageCrosspost(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/crosspost`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me`
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageOwnReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
      },
      /**
       * Route for:
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}/{user.id}`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageUserReaction(channelId, messageId, emoji, userId) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
      },
      /**
       * Route for:
       * - GET    `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}`
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions/{emoji}`
       *
       * **Note**: You need to URL encode the emoji yourself
       */
      channelMessageReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
      },
      /**
       * Route for:
       * - DELETE `/channels/{channel.id}/messages/{message.id}/reactions`
       */
      channelMessageAllReactions(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/reactions`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/messages/bulk-delete`
       */
      channelBulkDelete(channelId) {
        return `/channels/${channelId}/messages/bulk-delete`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/permissions/{overwrite.id}`
       * - DELETE `/channels/{channel.id}/permissions/{overwrite.id}`
       */
      channelPermission(channelId, overwriteId) {
        return `/channels/${channelId}/permissions/${overwriteId}`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/invites`
       * - POST `/channels/{channel.id}/invites`
       */
      channelInvites(channelId) {
        return `/channels/${channelId}/invites`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/followers`
       */
      channelFollowers(channelId) {
        return `/channels/${channelId}/followers`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/typing`
       */
      channelTyping(channelId) {
        return `/channels/${channelId}/typing`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/pins`
       */
      channelPins(channelId) {
        return `/channels/${channelId}/pins`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/pins/{message.id}`
       * - DELETE `/channels/{channel.id}/pins/{message.id}`
       */
      channelPin(channelId, messageId) {
        return `/channels/${channelId}/pins/${messageId}`;
      },
      /**
       * Route for:
       * - PUT    `/channels/{channel.id}/recipients/{user.id}`
       * - DELETE `/channels/{channel.id}/recipients/{user.id}`
       */
      channelRecipient(channelId, userId) {
        return `/channels/${channelId}/recipients/${userId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/emojis`
       * - POST `/guilds/{guild.id}/emojis`
       */
      guildEmojis(guildId) {
        return `/guilds/${guildId}/emojis`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/emojis/{emoji.id}`
       * - PATCH  `/guilds/{guild.id}/emojis/{emoji.id}`
       * - DELETE `/guilds/{guild.id}/emojis/{emoji.id}`
       */
      guildEmoji(guildId, emojiId) {
        return `/guilds/${guildId}/emojis/${emojiId}`;
      },
      /**
       * Route for:
       * - POST `/guilds`
       */
      guilds() {
        return "/guilds";
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}`
       * - PATCH  `/guilds/{guild.id}`
       * - DELETE `/guilds/{guild.id}`
       */
      guild(guildId) {
        return `/guilds/${guildId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/preview`
       */
      guildPreview(guildId) {
        return `/guilds/${guildId}/preview`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/channels`
       * - POST  `/guilds/{guild.id}/channels`
       * - PATCH `/guilds/{guild.id}/channels`
       */
      guildChannels(guildId) {
        return `/guilds/${guildId}/channels`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/members/{user.id}`
       * - PUT    `/guilds/{guild.id}/members/{user.id}`
       * - PATCH  `/guilds/{guild.id}/members/@me`
       * - PATCH  `/guilds/{guild.id}/members/{user.id}`
       * - DELETE `/guilds/{guild.id}/members/{user.id}`
       */
      guildMember(guildId, userId = "@me") {
        return `/guilds/${guildId}/members/${userId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/members`
       */
      guildMembers(guildId) {
        return `/guilds/${guildId}/members`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/members/search`
       */
      guildMembersSearch(guildId) {
        return `/guilds/${guildId}/members/search`;
      },
      /**
       * Route for:
       * - PATCH `/guilds/{guild.id}/members/@me/nick`
       *
       * @deprecated Use {@link Routes.guildMember} instead.
       */
      guildCurrentMemberNickname(guildId) {
        return `/guilds/${guildId}/members/@me/nick`;
      },
      /**
       * Route for:
       * - PUT    `/guilds/{guild.id}/members/{user.id}/roles/{role.id}`
       * - DELETE `/guilds/{guild.id}/members/{user.id}/roles/{role.id}`
       */
      guildMemberRole(guildId, memberId, roleId) {
        return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
      },
      /**
       * Route for:
       * - POST `/guilds/{guild.id}/mfa`
       */
      guildMFA(guildId) {
        return `/guilds/${guildId}/mfa`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/bans`
       */
      guildBans(guildId) {
        return `/guilds/${guildId}/bans`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/bans/{user.id}`
       * - PUT    `/guilds/{guild.id}/bans/{user.id}`
       * - DELETE `/guilds/{guild.id}/bans/{user.id}`
       */
      guildBan(guildId, userId) {
        return `/guilds/${guildId}/bans/${userId}`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/roles`
       * - POST  `/guilds/{guild.id}/roles`
       * - PATCH `/guilds/{guild.id}/roles`
       */
      guildRoles(guildId) {
        return `/guilds/${guildId}/roles`;
      },
      /**
       * Route for:
       * - PATCH  `/guilds/{guild.id}/roles/{role.id}`
       * - DELETE `/guilds/{guild.id}/roles/{role.id}`
       */
      guildRole(guildId, roleId) {
        return `/guilds/${guildId}/roles/${roleId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/prune`
       * - POST `/guilds/{guild.id}/prune`
       */
      guildPrune(guildId) {
        return `/guilds/${guildId}/prune`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/regions`
       */
      guildVoiceRegions(guildId) {
        return `/guilds/${guildId}/regions`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/invites`
       */
      guildInvites(guildId) {
        return `/guilds/${guildId}/invites`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/integrations`
       */
      guildIntegrations(guildId) {
        return `/guilds/${guildId}/integrations`;
      },
      /**
       * Route for:
       * - DELETE `/guilds/{guild.id}/integrations/{integration.id}`
       */
      guildIntegration(guildId, integrationId) {
        return `/guilds/${guildId}/integrations/${integrationId}`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/widget`
       * - PATCH `/guilds/{guild.id}/widget`
       */
      guildWidgetSettings(guildId) {
        return `/guilds/${guildId}/widget`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/widget.json`
       */
      guildWidgetJSON(guildId) {
        return `/guilds/${guildId}/widget.json`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/vanity-url`
       */
      guildVanityUrl(guildId) {
        return `/guilds/${guildId}/vanity-url`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/widget.png`
       */
      guildWidgetImage(guildId) {
        return `/guilds/${guildId}/widget.png`;
      },
      /**
       * Route for:
       * - GET    `/invites/{invite.code}`
       * - DELETE `/invites/{invite.code}`
       */
      invite(code) {
        return `/invites/${code}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/templates/{template.code}`
       * - POST `/guilds/templates/{template.code}`
       */
      template(code) {
        return `/guilds/templates/${code}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/templates`
       * - POST `/guilds/{guild.id}/templates`
       */
      guildTemplates(guildId) {
        return `/guilds/${guildId}/templates`;
      },
      /**
       * Route for:
       * - PUT    `/guilds/{guild.id}/templates/{template.code}`
       * - PATCH  `/guilds/{guild.id}/templates/{template.code}`
       * - DELETE `/guilds/{guild.id}/templates/{template.code}`
       */
      guildTemplate(guildId, code) {
        return `/guilds/${guildId}/templates/${code}`;
      },
      /**
       * Route for:
       * - POST `/channels/{channel.id}/threads`
       * - POST `/channels/{channel.id}/messages/{message.id}/threads`
       */
      threads(parentId, messageId) {
        const parts = ["", "channels", parentId];
        if (messageId)
          parts.push("messages", messageId);
        parts.push("threads");
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/threads/active`
       */
      guildActiveThreads(guildId) {
        return `/guilds/${guildId}/threads/active`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/threads/archived/public`
       * - GET `/channels/{channel.id}/threads/archived/private`
       */
      channelThreads(channelId, archivedStatus) {
        return `/channels/${channelId}/threads/archived/${archivedStatus}`;
      },
      /**
       * Route for:
       * - GET `/channels/{channel.id}/users/@me/threads/archived/private`
       */
      channelJoinedArchivedThreads(channelId) {
        return `/channels/${channelId}/users/@me/threads/archived/private`;
      },
      /**
       * Route for:
       * - GET    `/channels/{thread.id}/thread-members`
       * - GET    `/channels/{thread.id}/thread-members/{user.id}`
       * - PUT    `/channels/{thread.id}/thread-members/@me`
       * - PUT    `/channels/{thread.id}/thread-members/{user.id}`
       * - DELETE `/channels/{thread.id}/thread-members/@me`
       * - DELETE `/channels/{thread.id}/thread-members/{user.id}`
       */
      threadMembers(threadId, userId) {
        const parts = ["", "channels", threadId, "thread-members"];
        if (userId)
          parts.push(userId);
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET   `/users/@me`
       * - GET   `/users/{user.id}`
       * - PATCH `/users/@me`
       *
       * @param [userId] The user ID, defaulted to `@me`
       */
      user(userId = "@me") {
        return `/users/${userId}`;
      },
      /**
       * Route for:
       * - GET `/users/@me/applications/{application.id}/role-connection`
       * - PUT `/users/@me/applications/{application.id}/role-connection`
       */
      userApplicationRoleConnection(applicationId) {
        return `/users/@me/applications/${applicationId}/role-connection`;
      },
      /**
       * Route for:
       * - GET `/users/@me/guilds`
       */
      userGuilds() {
        return `/users/@me/guilds`;
      },
      /**
       * Route for:
       * - GET `/users/@me/guilds/{guild.id}/member`
       */
      userGuildMember(guildId) {
        return `/users/@me/guilds/${guildId}/member`;
      },
      /**
       * Route for:
       * - DELETE `/users/@me/guilds/{guild.id}`
       */
      userGuild(guildId) {
        return `/users/@me/guilds/${guildId}`;
      },
      /**
       * Route for:
       * - POST `/users/@me/channels`
       */
      userChannels() {
        return `/users/@me/channels`;
      },
      /**
       * Route for:
       * - GET `/users/@me/connections`
       */
      userConnections() {
        return `/users/@me/connections`;
      },
      /**
       * Route for:
       * - GET `/voice/regions`
       */
      voiceRegions() {
        return `/voice/regions`;
      },
      /**
       * Route for:
       * - GET  `/channels/{channel.id}/webhooks`
       * - POST `/channels/{channel.id}/webhooks`
       */
      channelWebhooks(channelId) {
        return `/channels/${channelId}/webhooks`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/webhooks`
       */
      guildWebhooks(guildId) {
        return `/guilds/${guildId}/webhooks`;
      },
      /**
       * Route for:
       * - GET    `/webhooks/{webhook.id}`
       * - GET    `/webhooks/{webhook.id}/{webhook.token}`
       * - PATCH  `/webhooks/{webhook.id}`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}`
       * - DELETE `/webhooks/{webhook.id}`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}`
       * - POST   `/webhooks/{webhook.id}/{webhook.token}`
       *
       * - POST   `/webhooks/{application.id}/{interaction.token}`
       */
      webhook(webhookId, webhookToken) {
        const parts = ["", "webhooks", webhookId];
        if (webhookToken)
          parts.push(webhookToken);
        return parts.join("/");
      },
      /**
       * Route for:
       * - GET    `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - GET    `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - PATCH  `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}/messages/@original`
       * - DELETE `/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}`
       *
       * - PATCH  `/webhooks/{application.id}/{interaction.token}/messages/@original`
       * - PATCH  `/webhooks/{application.id}/{interaction.token}/messages/{message.id}`
       * - DELETE `/webhooks/{application.id}/{interaction.token}/messages/{message.id}`
       */
      webhookMessage(webhookId, webhookToken, messageId = "@original") {
        return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
      },
      /**
       * Route for:
       * - POST `/webhooks/{webhook.id}/{webhook.token}/github`
       * - POST `/webhooks/{webhook.id}/{webhook.token}/slack`
       */
      webhookPlatform(webhookId, webhookToken, platform) {
        return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
      },
      /**
       * Route for:
       * - GET `/gateway`
       */
      gateway() {
        return `/gateway`;
      },
      /**
       * Route for:
       * - GET `/gateway/bot`
       */
      gatewayBot() {
        return `/gateway/bot`;
      },
      /**
       * Route for:
       * - GET `/oauth2/applications/@me`
       */
      oauth2CurrentApplication() {
        return `/oauth2/applications/@me`;
      },
      /**
       * Route for:
       * - GET `/oauth2/@me`
       */
      oauth2CurrentAuthorization() {
        return `/oauth2/@me`;
      },
      /**
       * Route for:
       * - GET `/oauth2/authorize`
       */
      oauth2Authorization() {
        return `/oauth2/authorize`;
      },
      /**
       * Route for:
       * - POST `/oauth2/token`
       */
      oauth2TokenExchange() {
        return `/oauth2/token`;
      },
      /**
       * Route for:
       * - POST `/oauth2/token/revoke`
       */
      oauth2TokenRevocation() {
        return `/oauth2/token/revoke`;
      },
      /**
       * Route for:
       * - GET  `/applications/{application.id}/commands`
       * - PUT  `/applications/{application.id}/commands`
       * - POST `/applications/{application.id}/commands`
       */
      applicationCommands(applicationId) {
        return `/applications/${applicationId}/commands`;
      },
      /**
       * Route for:
       * - GET    `/applications/{application.id}/commands/{command.id}`
       * - PATCH  `/applications/{application.id}/commands/{command.id}`
       * - DELETE `/applications/{application.id}/commands/{command.id}`
       */
      applicationCommand(applicationId, commandId) {
        return `/applications/${applicationId}/commands/${commandId}`;
      },
      /**
       * Route for:
       * - GET  `/applications/{application.id}/guilds/{guild.id}/commands`
       * - PUT  `/applications/{application.id}/guilds/{guild.id}/commands`
       * - POST `/applications/{application.id}/guilds/{guild.id}/commands`
       */
      applicationGuildCommands(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands`;
      },
      /**
       * Route for:
       * - GET    `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       * - PATCH  `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       * - DELETE `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}`
       */
      applicationGuildCommand(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
      },
      /**
       * Route for:
       * - POST `/interactions/{interaction.id}/{interaction.token}/callback`
       */
      interactionCallback(interactionId, interactionToken) {
        return `/interactions/${interactionId}/${interactionToken}/callback`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/member-verification`
       * - PATCH `/guilds/{guild.id}/member-verification`
       */
      guildMemberVerification(guildId) {
        return `/guilds/${guildId}/member-verification`;
      },
      /**
       * Route for:
       * - PATCH `/guilds/{guild.id}/voice-states/@me`
       * - PATCH `/guilds/{guild.id}/voice-states/{user.id}`
       */
      guildVoiceState(guildId, userId = "@me") {
        return `/guilds/${guildId}/voice-states/${userId}`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/guilds/{guild.id}/commands/permissions`
       * - PUT `/applications/{application.id}/guilds/{guild.id}/commands/permissions`
       */
      guildApplicationCommandsPermissions(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions`
       * - PUT `/applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions`
       */
      applicationCommandPermissions(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
      },
      /**
       * Route for:
       * - GET   `/guilds/{guild.id}/welcome-screen`
       * - PATCH `/guilds/{guild.id}/welcome-screen`
       */
      guildWelcomeScreen(guildId) {
        return `/guilds/${guildId}/welcome-screen`;
      },
      /**
       * Route for:
       * - POST `/stage-instances`
       */
      stageInstances() {
        return `/stage-instances`;
      },
      /**
       * Route for:
       * - GET `/stage-instances/{channel.id}`
       * - PATCH `/stage-instances/{channel.id}`
       * - DELETE `/stage-instances/{channel.id}`
       */
      stageInstance(channelId) {
        return `/stage-instances/${channelId}`;
      },
      /**
       * Route for:
       * - GET `/stickers/{sticker.id}`
       */
      sticker(stickerId) {
        return `/stickers/${stickerId}`;
      },
      /**
       * Route for:
       * - GET `/sticker-packs`
       */
      stickerPacks() {
        return "/sticker-packs";
      },
      /**
       * Route for:
       * - GET `/sticker-packs`
       *
       * @deprecated Use {@link Routes.stickerPacks} instead.
       */
      nitroStickerPacks() {
        return "/sticker-packs";
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/stickers`
       * - POST `/guilds/{guild.id}/stickers`
       */
      guildStickers(guildId) {
        return `/guilds/${guildId}/stickers`;
      },
      /**
       * Route for:
       * - GET    `/guilds/{guild.id}/stickers/{sticker.id}`
       * - PATCH  `/guilds/{guild.id}/stickers/{sticker.id}`
       * - DELETE `/guilds/{guild.id}/stickers/{sticker.id}`
       */
      guildSticker(guildId, stickerId) {
        return `/guilds/${guildId}/stickers/${stickerId}`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/scheduled-events`
       * - POST `/guilds/{guild.id}/scheduled-events`
       */
      guildScheduledEvents(guildId) {
        return `/guilds/${guildId}/scheduled-events`;
      },
      /**
       * Route for:
       * - GET  `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       * - PATCH `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       * - DELETE `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}`
       */
      guildScheduledEvent(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/scheduled-events/{guildScheduledEvent.id}/users`
       */
      guildScheduledEventUsers(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
      },
      /**
       * Route for:
       * - GET `/guilds/${guild.id}/onboarding`
       * - PUT `/guilds/${guild.id}/onboarding`
       */
      guildOnboarding(guildId) {
        return `/guilds/${guildId}/onboarding`;
      },
      /**
       * Route for:
       * - GET `/applications/@me`
       * - PATCH `/applications/@me`
       */
      currentApplication() {
        return "/applications/@me";
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/entitlements`
       * - POST `/applications/{application.id}/entitlements`
       */
      entitlements(applicationId) {
        return `/applications/${applicationId}/entitlements`;
      },
      /**
       * Route for:
       * - DELETE `/applications/{application.id}/entitlements/{entitlement.id}`
       */
      entitlement(applicationId, entitlementId) {
        return `/applications/${applicationId}/entitlements/${entitlementId}`;
      },
      /**
       * Route for:
       * - GET `/applications/{application.id}/skus`
       */
      skus(applicationId) {
        return `/applications/${applicationId}/skus`;
      }
    };
    exports2.StickerPackApplicationId = "710982414301790216";
    exports2.CDNRoutes = {
      /**
       * Route for:
       * - GET `/emojis/{emoji.id}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      emoji(emojiId, format) {
        return `/emojis/${emojiId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/icons/{guild.id}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildIcon(guildId, guildIcon, format) {
        return `icons/${guildId}/${guildIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/splashes/{guild.id}/{guild.splash}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildSplash(guildId, guildSplash, format) {
        return `/splashes/${guildId}/${guildSplash}.${format}`;
      },
      /**
       * Route for:
       * - GET `/discovery-splashes/{guild.id}/{guild.discovery_splash}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
        return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
      },
      /**
       * Route for:
       * - GET `/banners/{guild.id}/{guild.banner}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildBanner(guildId, guildBanner, format) {
        return `/banners/${guildId}/${guildBanner}.${format}`;
      },
      /**
       * Route for:
       * - GET `/banners/{user.id}/{user.banner}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      userBanner(userId, userBanner, format) {
        return `/banners/${userId}/${userBanner}.${format}`;
      },
      /**
       * Route for:
       * - GET `/embed/avatars/{index}.png`
       *
       * The value for `index` parameter depends on whether the user is [migrated to the new username system](https://discord.com/developers/docs/change-log#unique-usernames-on-discord).
       * For users on the new username system, `index` will be `(user.id >> 22) % 6`.
       * For users on the legacy username system, `index` will be `user.discriminator % 5`.
       *
       * This route supports the extension: PNG
       */
      defaultUserAvatar(index) {
        return `/embed/avatars/${index}.png`;
      },
      /**
       * Route for:
       * - GET `/avatars/{user.id}/{user.avatar}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      userAvatar(userId, userAvatar, format) {
        return `/avatars/${userId}/${userAvatar}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guilds/{guild.id}/users/{user.id}/{guild_member.avatar}.{png|jpeg|webp|gif}`
       *
       * As this route supports GIFs, the hash will begin with `a_` if it is available in GIF format
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildMemberAvatar(guildId, userId, memberAvatar, format) {
        return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
      },
      /**
       * Route for:
       * - GET `/avatar-decorations/{user.id}/{user.avatar_decoration}.png`
       *
       * This route supports the extension: PNG
       */
      userAvatarDecoration(userId, userAvatarDecoration) {
        return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
      },
      /**
       * Route for:
       * - GET `/app-icons/{application.id}/{application.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationIcon(applicationId, applicationIcon, format) {
        return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-icons/{application.id}/{application.cover_image}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationCover(applicationId, applicationCoverImage, format) {
        return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/{application.id}/{application.asset_id}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      applicationAsset(applicationId, applicationAssetId, format) {
        return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/{application.id}/achievements/{achievement.id}/icons/{achievement.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      achievementIcon(applicationId, achievementId, achievementIconHash, format) {
        return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/710982414301790216/store/{sticker_pack.banner.asset_id}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      stickerPackBanner(stickerPackBannerAssetId, format) {
        return `/app-assets/${exports2.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/app-assets/${application.id}/store/${asset.id}.{png|jpeg|webp}}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      storePageAsset(applicationId, assetId) {
        return `/app-assets/${applicationId}/store/${assetId}.png`;
      },
      /**
       * Route for:
       * - GET `team-icons/{team.id}/{team.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      teamIcon(teamId, teamIcon, format) {
        return `/team-icons/${teamId}/${teamIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/stickers/{sticker.id}.{png|json}`
       *
       * This route supports the extensions: PNG, Lottie, GIF
       */
      sticker(stickerId, format) {
        return `/stickers/${stickerId}.${format}`;
      },
      /**
       * Route for:
       * - GET `/role-icons/{role.id}/{role.icon}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      roleIcon(roleId, roleIcon, format) {
        return `/role-icons/${roleId}/${roleIcon}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guild-events/{guild_scheduled_event.id}/{guild_scheduled_event.image}.{png|jpeg|webp}`
       *
       * This route supports the extensions: PNG, JPEG, WebP
       */
      guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
        return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
      },
      /**
       * Route for:
       * - GET `/guilds/${guild.id}/users/${user.id}/banners/${guild_member.banner}.{png|jpeg|webp|gif}`
       *
       * This route supports the extensions: PNG, JPEG, WebP, GIF
       */
      guildMemberBanner(guildId, userId, guildMemberBanner, format) {
        return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
      }
    };
    var ImageFormat;
    (function(ImageFormat2) {
      ImageFormat2["JPEG"] = "jpeg";
      ImageFormat2["PNG"] = "png";
      ImageFormat2["WebP"] = "webp";
      ImageFormat2["GIF"] = "gif";
      ImageFormat2["Lottie"] = "json";
    })(ImageFormat = exports2.ImageFormat || (exports2.ImageFormat = {}));
    exports2.RouteBases = {
      api: `https://discord.com/api/v${exports2.APIVersion}`,
      cdn: "https://cdn.discordapp.com",
      invite: "https://discord.gg",
      template: "https://discord.new",
      gift: "https://discord.gift",
      scheduledEvent: "https://discord.com/events"
    };
    Object.freeze(exports2.RouteBases);
    exports2.OAuth2Routes = {
      authorizationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2Authorization()}`,
      tokenURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenExchange()}`,
      /**
       * See https://tools.ietf.org/html/rfc7009
       */
      tokenRevocationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenRevocation()}`
    };
    Object.freeze(exports2.OAuth2Routes);
  }
});

// node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS({
  "node_modules/discord-api-types/rpc/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RPCCloseEventCodes = exports2.RPCErrorCodes = void 0;
    var RPCErrorCodes;
    (function(RPCErrorCodes2) {
      RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1e3] = "UnknownError";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4e3] = "InvalidPayload";
      RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
      RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
      RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
      RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
      RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
      RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
      RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
      RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
      RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5e3] = "OAuth2Error";
      RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
      RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    })(RPCErrorCodes = exports2.RPCErrorCodes || (exports2.RPCErrorCodes = {}));
    var RPCCloseEventCodes;
    (function(RPCCloseEventCodes2) {
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4e3] = "InvalidClientId";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
      RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
      RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
    })(RPCCloseEventCodes = exports2.RPCCloseEventCodes || (exports2.RPCCloseEventCodes = {}));
  }
});

// node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS({
  "node_modules/discord-api-types/rpc/v10.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_common4(), exports2);
  }
});

// node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS({
  "node_modules/discord-api-types/utils/v10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isContextMenuApplicationCommandInteraction = exports2.isChatInputApplicationCommandInteraction = exports2.isMessageComponentSelectMenuInteraction = exports2.isMessageComponentButtonInteraction = exports2.isMessageComponentInteraction = exports2.isInteractionButton = exports2.isLinkButton = exports2.isMessageComponentGuildInteraction = exports2.isMessageComponentDMInteraction = exports2.isApplicationCommandGuildInteraction = exports2.isApplicationCommandDMInteraction = exports2.isGuildInteraction = exports2.isDMInteraction = void 0;
    var index_1 = require_v102();
    function isDMInteraction(interaction) {
      return Reflect.has(interaction, "user");
    }
    exports2.isDMInteraction = isDMInteraction;
    function isGuildInteraction(interaction) {
      return Reflect.has(interaction, "guild_id");
    }
    exports2.isGuildInteraction = isGuildInteraction;
    function isApplicationCommandDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    exports2.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
    function isApplicationCommandGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    exports2.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
    function isMessageComponentDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    exports2.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
    function isMessageComponentGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    exports2.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
    function isLinkButton(component) {
      return component.style === index_1.ButtonStyle.Link;
    }
    exports2.isLinkButton = isLinkButton;
    function isInteractionButton(component) {
      return component.style !== index_1.ButtonStyle.Link;
    }
    exports2.isInteractionButton = isInteractionButton;
    function isMessageComponentInteraction(interaction) {
      return interaction.type === index_1.InteractionType.MessageComponent;
    }
    exports2.isMessageComponentInteraction = isMessageComponentInteraction;
    function isMessageComponentButtonInteraction(interaction) {
      return interaction.data.component_type === index_1.ComponentType.Button;
    }
    exports2.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
    function isMessageComponentSelectMenuInteraction(interaction) {
      return [
        index_1.ComponentType.StringSelect,
        index_1.ComponentType.UserSelect,
        index_1.ComponentType.RoleSelect,
        index_1.ComponentType.MentionableSelect,
        index_1.ComponentType.ChannelSelect
      ].includes(interaction.data.component_type);
    }
    exports2.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
    function isChatInputApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
    }
    exports2.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
    function isContextMenuApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
    }
    exports2.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
  }
});

// node_modules/discord-api-types/v10.js
var require_v106 = __commonJS({
  "node_modules/discord-api-types/v10.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utils = void 0;
    __exportStar2(require_v10(), exports2);
    __exportStar2(require_globals(), exports2);
    __exportStar2(require_v102(), exports2);
    __exportStar2(require_v103(), exports2);
    __exportStar2(require_v104(), exports2);
    exports2.Utils = require_v105();
  }
});

// node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Collection: () => Collection2,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var _a;
    var Collection2 = (_a = class extends Map {
      /**
       * Obtains the value of the given key if it exists, otherwise sets and returns the value provided by the default value generator.
       *
       * @param key - The key to get if it exists, or set otherwise
       * @param defaultValueGenerator - A function that generates the default value
       * @example
       * ```ts
       * collection.ensure(guildId, () => defaultGuildConfig);
       * ```
       */
      ensure(key, defaultValueGenerator) {
        if (this.has(key))
          return this.get(key);
        if (typeof defaultValueGenerator !== "function")
          throw new TypeError(`${defaultValueGenerator} is not a function`);
        const defaultValue = defaultValueGenerator(key, this);
        this.set(key, defaultValue);
        return defaultValue;
      }
      /**
       * Checks if all of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if all of the elements exist, `false` if at least one does not exist.
       */
      hasAll(...keys) {
        return keys.every((key) => super.has(key));
      }
      /**
       * Checks if any of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if any of the elements exist, `false` if none exist.
       */
      hasAny(...keys) {
        return keys.some((key) => super.has(key));
      }
      first(amount) {
        if (amount === void 0)
          return this.values().next().value;
        if (amount < 0)
          return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      firstKey(amount) {
        if (amount === void 0)
          return this.keys().next().value;
        if (amount < 0)
          return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      last(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.first(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      lastKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.firstKey(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the item at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the element to obtain
       */
      at(index) {
        index = Math.floor(index);
        const arr = [...this.values()];
        return arr.at(index);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the key at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the key to obtain
       */
      keyAt(index) {
        index = Math.floor(index);
        const arr = [...this.keys()];
        return arr.at(index);
      }
      random(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      randomKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse | Array.reverse()}
       * but returns a Collection instead of an Array.
       */
      reverse() {
        const entries = [...this.entries()].reverse();
        this.clear();
        for (const [key, value] of entries)
          this.set(key, value);
        return this;
      }
      find(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      findLast(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const entries = [...this.entries()];
        for (let index = entries.length - 1; index >= 0; index--) {
          const val = entries[index][1];
          const key = entries[index][0];
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findLastKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const entries = [...this.entries()];
        for (let index = entries.length - 1; index >= 0; index--) {
          const key = entries[index][0];
          const val = entries[index][1];
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      sweep(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this) {
          if (fn(val, key, this))
            this.delete(key);
        }
        return previousSize - this.size;
      }
      filter(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this) {
          if (fn(val, key, this))
            results.set(key, val);
        }
        return results;
      }
      partition(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = [
          new this.constructor[Symbol.species](),
          new this.constructor[Symbol.species]()
        ];
        for (const [key, val] of this) {
          if (fn(val, key, this)) {
            results[0].set(key, val);
          } else {
            results[1].set(key, val);
          }
        }
        return results;
      }
      flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
      }
      map(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({ length: this.size }, () => {
          const [key, value] = iter.next().value;
          return fn(value, key, this);
        });
      }
      mapValues(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
          coll.set(key, fn(val, key, this));
        return coll;
      }
      some(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return true;
        }
        return false;
      }
      every(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (!fn(val, key, this))
            return false;
        }
        return true;
      }
      /**
       * Applies a function to produce a single value. Identical in behavior to
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce | Array.reduce()}.
       *
       * @param fn - Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,
       * and `collection`
       * @param initialValue - Starting value for the accumulator
       * @example
       * ```ts
       * collection.reduce((acc, guild) => acc + guild.memberCount, 0);
       * ```
       */
      reduce(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        let accumulator;
        const iterator = this.entries();
        if (initialValue === void 0) {
          if (this.size === 0)
            throw new TypeError("Reduce of empty collection with no initial value");
          accumulator = iterator.next().value[1];
        } else {
          accumulator = initialValue;
        }
        for (const [key, value] of iterator) {
          accumulator = fn(accumulator, value, key, this);
        }
        return accumulator;
      }
      /**
       * Applies a function to produce a single value. Identical in behavior to
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight | Array.reduceRight()}.
       *
       * @param fn - Function used to reduce, taking four arguments; `accumulator`, `value`, `key`, and `collection`
       * @param initialValue - Starting value for the accumulator
       */
      reduceRight(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        const entries = [...this.entries()];
        let accumulator;
        let index;
        if (initialValue === void 0) {
          if (entries.length === 0)
            throw new TypeError("Reduce of empty collection with no initial value");
          accumulator = entries[entries.length - 1][1];
          index = entries.length - 1;
        } else {
          accumulator = initialValue;
          index = entries.length;
        }
        while (--index >= 0) {
          const key = entries[index][0];
          const val = entries[index][1];
          accumulator = fn(accumulator, val, key, this);
        }
        return accumulator;
      }
      each(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, value] of this) {
          fn(value, key, this);
        }
        return this;
      }
      tap(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        fn(this);
        return this;
      }
      /**
       * Creates an identical shallow copy of this collection.
       *
       * @example
       * ```ts
       * const newColl = someColl.clone();
       * ```
       */
      clone() {
        return new this.constructor[Symbol.species](this);
      }
      /**
       * Combines this collection with others into a new collection. None of the source collections are modified.
       *
       * @param collections - Collections to merge
       * @example
       * ```ts
       * const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);
       * ```
       */
      concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections) {
          for (const [key, val] of coll)
            newColl.set(key, val);
        }
        return newColl;
      }
      /**
       * Checks if this collection shares identical items with another.
       * This is different to checking for equality using equal-signs, because
       * the collections may be different objects, but contain the same data.
       *
       * @param collection - Collection to compare with
       * @returns Whether the collections have identical contents
       */
      equals(collection) {
        if (!collection)
          return false;
        if (this === collection)
          return true;
        if (this.size !== collection.size)
          return false;
        for (const [key, value] of this) {
          if (!collection.has(key) || value !== collection.get(key)) {
            return false;
          }
        }
        return true;
      }
      /**
       * The sort method sorts the items of a collection in place and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value, according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      sort(compareFunction = _a.defaultSort) {
        const entries = [...this.entries()];
        entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
        super.clear();
        for (const [key, value] of entries) {
          super.set(key, value);
        }
        return this;
      }
      /**
       * The intersection method returns a new collection containing the items where the key is present in both collections.
       *
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['c', 3]]);
       * const intersection = col1.intersection(col2);
       * console.log(col1.intersection(col2));
       * // => Collection { 'a' => 1 }
       * ```
       */
      intersection(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (other.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Returns a new collection containing the items where the key is present in either of the collections.
       *
       * @remarks
       *
       * If the collections have any items with the same key, the value from the first collection will be used.
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['b', 3], ['c', 3]]);
       * const union = col1.union(col2);
       * console.log(union);
       * // => Collection { 'a' => 1, 'b' => 2, 'c' => 3 }
       * ```
       */
      union(other) {
        const coll = new this.constructor[Symbol.species](this);
        for (const [key, value] of other) {
          if (!coll.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Returns a new collection containing the items where the key is present in this collection but not the other.
       *
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['c', 3]]);
       * console.log(col1.difference(col2));
       * // => Collection { 'b' => 2 }
       * console.log(col2.difference(col1));
       * // => Collection { 'c' => 3 }
       * ```
       */
      difference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (!other.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Returns a new collection containing only the items where the keys are present in either collection, but not both.
       *
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['c', 3]]);
       * const symmetricDifference = col1.symmetricDifference(col2);
       * console.log(col1.symmetricDifference(col2));
       * // => Collection { 'b' => 2, 'c' => 3 }
       * ```
       */
      symmetricDifference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (!other.has(key))
            coll.set(key, value);
        }
        for (const [key, value] of other) {
          if (!this.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Merges two Collections together into a new Collection.
       *
       * @param other - The other Collection to merge with
       * @param whenInSelf - Function getting the result if the entry only exists in this Collection
       * @param whenInOther - Function getting the result if the entry only exists in the other Collection
       * @param whenInBoth - Function getting the result if the entry exists in both Collections
       * @example
       * ```ts
       * // Sums up the entries in two collections.
       * coll.merge(
       *  other,
       *  x => ({ keep: true, value: x }),
       *  y => ({ keep: true, value: y }),
       *  (x, y) => ({ keep: true, value: x + y }),
       * );
       * ```
       * @example
       * ```ts
       * // Intersects two collections in a left-biased manner.
       * coll.merge(
       *  other,
       *  x => ({ keep: false }),
       *  y => ({ keep: false }),
       *  (x, _) => ({ keep: true, value: x }),
       * );
       * ```
       */
      merge(other, whenInSelf, whenInOther, whenInBoth) {
        const coll = new this.constructor[Symbol.species]();
        const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
        for (const key of keys) {
          const hasInSelf = this.has(key);
          const hasInOther = other.has(key);
          if (hasInSelf && hasInOther) {
            const result = whenInBoth(this.get(key), other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInSelf) {
            const result = whenInSelf(this.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInOther) {
            const result = whenInOther(other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          }
        }
        return coll;
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed | Array.toReversed()}
       * but returns a Collection instead of an Array.
       */
      toReversed() {
        return new this.constructor[Symbol.species](this).reverse();
      }
      /**
       * The sorted method sorts the items of a collection and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value,
       * according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      toSorted(compareFunction = _a.defaultSort) {
        return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
      }
      toJSON() {
        return [...this.entries()];
      }
      static defaultSort(firstValue, secondValue) {
        return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
      }
      /**
       * Creates a Collection from a list of entries.
       *
       * @param entries - The list of entries
       * @param combine - Function to combine an existing entry with a new one
       * @example
       * ```ts
       * Collection.combineEntries([["a", 1], ["b", 2], ["a", 2]], (x, y) => x + y);
       * // returns Collection { "a" => 3, "b" => 2 }
       * ```
       */
      static combineEntries(entries, combine) {
        const coll = new _a();
        for (const [key, value] of entries) {
          if (coll.has(key)) {
            coll.set(key, combine(coll.get(key), value, key));
          } else {
            coll.set(key, value);
          }
        }
        return coll;
      }
    }, __name(_a, "Collection"), _a);
    var version = "2.0.0";
  }
});

// node_modules/@sapphire/snowflake/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@sapphire/snowflake/dist/index.js"(exports2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __publicField2 = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
    var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
    var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
    var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
    var MaximumWorkerId = 0b11111n;
    var MaximumProcessId = 0b11111n;
    var MaximumIncrement = 0b111111111111n;
    var _a;
    var _b;
    var _c;
    var _d;
    var Snowflake = class {
      /**
       * @param epoch the epoch to use
       */
      constructor(epoch) {
        __publicField2(this, "decode", this.deconstruct);
        __publicField2(this, _a);
        __publicField2(this, _b, 0n);
        __publicField2(this, _c, 1n);
        __publicField2(this, _d, 0n);
        this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
      }
      /**
       * The epoch for this snowflake
       */
      get epoch() {
        return this[EpochSymbol];
      }
      /**
       * Gets the configured process ID
       */
      get processId() {
        return this[ProcessIdSymbol];
      }
      /**
       * Sets the process ID that will be used by default for the {@link generate} method
       * @param value The new value, will be coerced to BigInt and masked with `0b11111n`
       */
      set processId(value) {
        this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
      }
      /**
       * Gets the configured worker ID
       */
      get workerId() {
        return this[WorkerIdSymbol];
      }
      /**
       * Sets the worker ID that will be used by default for the {@link generate} method
       * @param value The new value, will be coerced to BigInt and masked with `0b11111n`
       */
      set workerId(value) {
        this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
      }
      /**
       * Generates a snowflake given an epoch and optionally a timestamp
       * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}
       *
       * **note** when `increment` is not provided it defaults to the private `increment` of the instance
       * @example
       * ```typescript
       * const epoch = new Date('2000-01-01T00:00:00.000Z');
       * const snowflake = new Snowflake(epoch).generate();
       * ```
       * @returns A unique snowflake
       */
      generate({
        increment,
        timestamp = Date.now(),
        workerId = this[WorkerIdSymbol],
        processId = this[ProcessIdSymbol]
      } = {}) {
        if (timestamp instanceof Date)
          timestamp = BigInt(timestamp.getTime());
        else if (typeof timestamp === "number")
          timestamp = BigInt(timestamp);
        else if (typeof timestamp !== "bigint") {
          throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
        }
        if (typeof increment !== "bigint") {
          increment = this[IncrementSymbol];
          this[IncrementSymbol] = increment + 1n & MaximumIncrement;
        }
        return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
      }
      /**
       * Deconstructs a snowflake given a snowflake ID
       * @param id the snowflake to deconstruct
       * @returns a deconstructed snowflake
       * @example
       * ```typescript
       * const epoch = new Date('2000-01-01T00:00:00.000Z');
       * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');
       * ```
       */
      deconstruct(id) {
        const bigIntId = BigInt(id);
        const epoch = this[EpochSymbol];
        return {
          id: bigIntId,
          timestamp: (bigIntId >> 22n) + epoch,
          workerId: bigIntId >> 17n & MaximumWorkerId,
          processId: bigIntId >> 12n & MaximumProcessId,
          increment: bigIntId & MaximumIncrement,
          epoch
        };
      }
      /**
       * Retrieves the timestamp field's value from a snowflake.
       * @param id The snowflake to get the timestamp value from.
       * @returns The UNIX timestamp that is stored in `id`.
       */
      timestampFrom(id) {
        return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
      }
      /**
       * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given
       * snowflake in sort order.
       * @param a The first snowflake to compare.
       * @param b The second snowflake to compare.
       * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.
       * @example Sort snowflakes in ascending order
       * ```typescript
       * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];
       * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));
       * //  ['254360814063058944', '737141877803057244', '1056191128120082432'];
       * ```
       * @example Sort snowflakes in descending order
       * ```typescript
       * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];
       * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));
       * //  ['1056191128120082432', '737141877803057244', '254360814063058944'];
       * ```
       */
      static compare(a, b) {
        const typeA = typeof a;
        return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
      }
    };
    __name(Snowflake, "Snowflake");
    _a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
    function cmpBigInt(a, b) {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    __name(cmpBigInt, "cmpBigInt");
    function cmpString(a, b) {
      return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
    }
    __name(cmpString, "cmpString");
    var DiscordSnowflake = new Snowflake(1420070400000n);
    var TwitterSnowflake = new Snowflake(1288834974657n);
    exports2.DiscordSnowflake = DiscordSnowflake;
    exports2.MaximumIncrement = MaximumIncrement;
    exports2.MaximumProcessId = MaximumProcessId;
    exports2.MaximumWorkerId = MaximumWorkerId;
    exports2.Snowflake = Snowflake;
    exports2.TwitterSnowflake = TwitterSnowflake;
  }
});

// node_modules/@vladfrangu/async_event_emitter/dist/index.cjs
var require_dist4 = __commonJS({
  "node_modules/@vladfrangu/async_event_emitter/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      AbortError: () => AbortError,
      AsyncEventEmitter: () => AsyncEventEmitter
    });
    module2.exports = __toCommonJS2(src_exports);
    function validateListener(input) {
      if (typeof input !== "function") {
        throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
      }
    }
    __name(validateListener, "validateListener");
    function validateAbortSignal(input) {
      if (input && !(input instanceof AbortSignal)) {
        throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
      }
    }
    __name(validateAbortSignal, "validateAbortSignal");
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) {
        list[index] = list[index + 1];
      }
      list.pop();
    }
    __name(spliceOne, "spliceOne");
    function arrayClone(arr) {
      switch (arr.length) {
        case 2:
          return [arr[0], arr[1]];
        case 3:
          return [arr[0], arr[1], arr[2]];
        case 4:
          return [arr[0], arr[1], arr[2], arr[3]];
        case 5:
          return [arr[0], arr[1], arr[2], arr[3], arr[4]];
        case 6:
          return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
      }
      return arr.slice();
    }
    __name(arrayClone, "arrayClone");
    function identicalSequenceRange(a, b) {
      for (let i = 0; i < a.length - 3; i++) {
        const pos = b.indexOf(a[i]);
        if (pos !== -1) {
          const rest = b.length - pos;
          if (rest > 3) {
            let len = 1;
            const maxLen = Math.min(a.length - i, rest);
            while (maxLen > len && a[i + len] === b[pos + len]) {
              len++;
            }
            if (len > 3) {
              return [len, i];
            }
          }
        }
      }
      return [0, 0];
    }
    __name(identicalSequenceRange, "identicalSequenceRange");
    function enhanceStackTrace(err, own) {
      let ctorInfo = "";
      try {
        const { name } = this.constructor;
        if (name !== "AsyncEventEmitter")
          ctorInfo = ` on ${name} instance`;
      } catch {
      }
      const sep = `
Emitted 'error' event${ctorInfo} at:
`;
      const errStack = err.stack.split("\n").slice(1);
      const ownStack = own.stack.split("\n").slice(1);
      const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
      if (len > 0) {
        ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
      }
      return err.stack + sep + ownStack.join("\n");
    }
    __name(enhanceStackTrace, "enhanceStackTrace");
    var _AsyncEventEmitter = class _AsyncEventEmitter2 {
      constructor() {
        this._events = {
          __proto__: null
        };
        this._eventCount = 0;
        this._maxListeners = 10;
        this._internalPromiseMap = /* @__PURE__ */ new Map();
        this._wrapperId = 0n;
      }
      addListener(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, false);
        this._addListener(eventName, wrapped, false);
        return this;
      }
      on(eventName, listener) {
        return this.addListener(eventName, listener);
      }
      once(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, true);
        this._addListener(eventName, wrapped, false);
        return this;
      }
      removeListener(eventName, listener) {
        validateListener(listener);
        const events = this._events;
        const eventList = events[eventName];
        if (eventList === void 0) {
          return this;
        }
        if (eventList === listener || eventList.listener === listener) {
          if (--this._eventCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[eventName];
            if (events.removeListener) {
              this.emit("removeListener", eventName, eventList.listener ?? eventList);
            }
          }
        } else if (typeof eventList !== "function") {
          let position = -1;
          for (let i = eventList.length - 1; i >= 0; i--) {
            if (eventList[i] === listener || eventList[i].listener === listener) {
              position = i;
              break;
            }
          }
          if (position < 0) {
            return this;
          }
          if (position === 0) {
            eventList.shift();
          } else {
            spliceOne(eventList, position);
          }
          if (eventList.length === 0) {
            delete events[eventName];
            --this._eventCount;
          }
          if (events.removeListener !== void 0) {
            this.emit("removeListener", eventName, listener);
          }
        }
        return this;
      }
      off(eventName, listener) {
        return this.removeListener(eventName, listener);
      }
      removeAllListeners(event) {
        const events = this._events;
        if (events.removeListener === void 0) {
          if (!event) {
            this._events = { __proto__: null };
            this._eventCount = 0;
          } else if (events[event] !== void 0) {
            if (--this._eventCount === 0) {
              this._events = { __proto__: null };
            } else {
              delete events[event];
            }
          }
          return this;
        }
        if (!event) {
          for (const key of Reflect.ownKeys(events)) {
            if (key === "removeListener") {
              continue;
            }
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = { __proto__: null };
          this._eventCount = 0;
          return this;
        }
        const listeners = events[event];
        if (typeof listeners === "function") {
          this.removeListener(event, listeners);
        } else if (listeners !== void 0) {
          for (let i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(event, listeners[i]);
          }
        }
        return this;
      }
      setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
          throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
        }
        this._maxListeners = n;
        return this;
      }
      getMaxListeners() {
        return this._maxListeners;
      }
      listeners(eventName) {
        const eventList = this._events[eventName];
        if (eventList === void 0) {
          return [];
        }
        if (typeof eventList === "function") {
          return [eventList.listener ?? eventList];
        }
        const ret = arrayClone(eventList);
        for (let i = 0; i < ret.length; ++i) {
          const orig = ret[i].listener;
          if (typeof orig === "function") {
            ret[i] = orig;
          }
        }
        return ret;
      }
      rawListeners(eventName) {
        const eventList = this._events[eventName];
        if (eventList === void 0) {
          return [];
        }
        if (typeof eventList === "function") {
          return [eventList];
        }
        return arrayClone(eventList);
      }
      emit(eventName, ...args) {
        let doError = eventName === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er;
          if (args.length > 0) {
            er = args[0];
          }
          if (er instanceof Error) {
            try {
              const capture = {};
              Error.captureStackTrace(capture, _AsyncEventEmitter2.prototype.emit);
              Object.defineProperty(er, "stack", {
                value: enhanceStackTrace.call(this, er, capture),
                configurable: true
              });
            } catch {
            }
            throw er;
          }
          const stringifiedError = String(er);
          const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
          err.context = er;
          throw err;
        }
        const handlers = events[eventName];
        if (handlers === void 0) {
          return false;
        }
        if (typeof handlers === "function") {
          const result = handlers.apply(this, args);
          if (result !== void 0 && result !== null) {
            handleMaybeAsync(this, result);
          }
        } else {
          const len = handlers.length;
          const listeners = arrayClone(handlers);
          for (let i = 0; i < len; ++i) {
            const result = listeners[i].apply(this, args);
            if (result !== void 0 && result !== null) {
              handleMaybeAsync(this, result);
            }
          }
        }
        return true;
      }
      listenerCount(eventName) {
        const events = this._events;
        if (events === void 0) {
          return 0;
        }
        const eventListeners = events[eventName];
        if (typeof eventListeners === "function") {
          return 1;
        }
        return (eventListeners == null ? void 0 : eventListeners.length) ?? 0;
      }
      prependListener(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, false);
        this._addListener(eventName, wrapped, true);
        return this;
      }
      prependOnceListener(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, true);
        this._addListener(eventName, wrapped, true);
        return this;
      }
      eventNames() {
        return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
      }
      async waitForAllListenersToComplete() {
        const promises = [...this._internalPromiseMap.values()];
        if (promises.length === 0) {
          return false;
        }
        await Promise.all(promises);
        return true;
      }
      _addListener(eventName, wrappedListener, prepend) {
        if (this._events.newListener !== void 0) {
          this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
        }
        let existing = this._events[eventName];
        if (existing === void 0) {
          existing = this._events[eventName] = wrappedListener;
          ++this._eventCount;
        } else if (typeof existing === "function") {
          existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];
        } else if (prepend) {
          existing.unshift(wrappedListener);
        } else {
          existing.push(wrappedListener);
        }
        if (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {
          existing._hasWarnedAboutMaxListeners = true;
          const warningMessage = [
            `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
            `Use emitter.setMaxListeners() to increase the limit.`
          ].join(" ");
          console.warn(warningMessage);
        }
      }
      _wrapListener(eventName, listener, once) {
        if (!once) {
          return listener;
        }
        const state = {
          fired: false,
          wrapFn: void 0,
          eventEmitter: this,
          eventName,
          listener
        };
        const aliased = onceWrapper;
        const wrapped = aliased.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      static listenerCount(emitter, eventName) {
        return emitter.listenerCount(eventName);
      }
      static async once(emitter, eventName, options = {}) {
        const signal = options == null ? void 0 : options.signal;
        validateAbortSignal(signal);
        if (signal == null ? void 0 : signal.aborted) {
          throw new AbortError(void 0, { cause: getReason(signal) });
        }
        return new Promise((resolve, reject) => {
          const errorListener = __name((err) => {
            emitter.removeListener(eventName, resolver);
            if (signal) {
              eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
            }
            reject(err);
          }, "errorListener");
          const resolver = __name((...args) => {
            emitter.removeListener("error", errorListener);
            if (signal) {
              eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve(args);
          }, "resolver");
          emitter.once(eventName, resolver);
          if (eventName !== "error") {
            emitter.once("error", errorListener);
          }
          const abortListener = __name(() => {
            eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError(void 0, { cause: getReason(signal) }));
          }, "abortListener");
          if (signal) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
          }
        });
      }
      static on(emitter, eventName, options = {}) {
        const signal = options == null ? void 0 : options.signal;
        validateAbortSignal(signal);
        if (signal == null ? void 0 : signal.aborted) {
          throw new AbortError(void 0, { cause: getReason(signal) });
        }
        const unconsumedEvents = [];
        const unconsumedPromises = [];
        let error = null;
        let finished = false;
        const abortListener = __name(() => {
          errorHandler(new AbortError(void 0, { cause: getReason(signal) }));
        }, "abortListener");
        const eventHandler = __name((...args) => {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEvents.push(args);
          }
        }, "eventHandler");
        const errorHandler = __name((err) => {
          finished = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          void iterator.return();
        }, "errorHandler");
        const iterator = Object.setPrototypeOf(
          {
            next() {
              const value = unconsumedEvents.shift();
              if (value) {
                return Promise.resolve(createIterResult(value, false));
              }
              if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
              }
              if (finished) {
                return Promise.resolve(createIterResult(void 0, true));
              }
              return new Promise((resolve, reject) => {
                unconsumedPromises.push({ resolve, reject });
              });
            },
            return() {
              emitter.off(eventName, eventHandler);
              emitter.off("error", errorHandler);
              if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
              }
              finished = true;
              const doneResult = createIterResult(void 0, true);
              for (const promise of unconsumedPromises) {
                promise.resolve(doneResult);
              }
              return Promise.resolve(doneResult);
            },
            throw(err) {
              if (!err || !(err instanceof Error)) {
                throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
              }
              error = err;
              emitter.off(eventName, eventHandler);
              emitter.off("error", errorHandler);
            },
            [Symbol.asyncIterator]() {
              return this;
            }
          },
          AsyncIteratorPrototype
        );
        emitter.on(eventName, eventHandler);
        if (eventName !== "error") {
          emitter.on("error", errorHandler);
        }
        if (signal) {
          eventTargetAgnosticAddListener(signal, "abort", abortListener);
        }
        return iterator;
      }
    };
    __name(_AsyncEventEmitter, "AsyncEventEmitter");
    var AsyncEventEmitter = _AsyncEventEmitter;
    function onceWrapper() {
      if (!this.fired) {
        this.eventEmitter.removeListener(this.eventName, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
          return this.listener.call(this.eventEmitter);
        }
        return this.listener.apply(this.eventEmitter, arguments);
      }
    }
    __name(onceWrapper, "onceWrapper");
    function getReason(signal) {
      return signal == null ? void 0 : signal.reason;
    }
    __name(getReason, "getReason");
    function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
      if (typeof emitter.off === "function") {
        emitter.off(name, listener);
      } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
      }
    }
    __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags == null ? void 0 : flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, listener, flags);
      }
    }
    __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
    var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);
    function createIterResult(value, done) {
      return { value, done };
    }
    __name(createIterResult, "createIterResult");
    var _AbortError = class _AbortError extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    __name(_AbortError, "AbortError");
    var AbortError = _AbortError;
    function handleMaybeAsync(emitter, result) {
      try {
        const fin = result.finally;
        if (typeof fin === "function") {
          const promiseId = String(++emitter["_wrapperId"]);
          emitter["_internalPromiseMap"].set(promiseId, result);
          fin.call(result, __name(function final() {
            emitter["_internalPromiseMap"].delete(promiseId);
          }, "final"));
        }
      } catch (err) {
        emitter.emit("error", err);
      }
    }
    __name(handleMaybeAsync, "handleMaybeAsync");
  }
});

// node_modules/magic-bytes.js/dist/model/toHex.js
var require_toHex = __commonJS({
  "node_modules/magic-bytes.js/dist/model/toHex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromHex = exports2.toHex = void 0;
    var hex = (num) => new Number(num).toString(16).toLowerCase();
    var toHex = (num) => `0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
    exports2.toHex = toHex;
    var fromHex = (hex2) => new Number(hex2);
    exports2.fromHex = fromHex;
  }
});

// node_modules/magic-bytes.js/dist/model/tree.js
var require_tree = __commonJS({
  "node_modules/magic-bytes.js/dist/model/tree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createComplexNode = exports2.createNode = exports2.merge = void 0;
    var createMatch = (leaf) => ({
      typename: leaf.typename,
      mime: leaf.info.mime,
      extension: leaf.info.extension
    });
    var isMatchingNode = (tree, path) => tree && path.length === 0;
    var head = (arr) => arr[0];
    var tail = (arr) => arr.slice(1, arr.length);
    var merge = (node, tree) => {
      if (node.bytes.length === 0)
        return tree;
      const currentByte = head(node.bytes);
      const path = tail(node.bytes);
      const currentTree = tree.bytes[currentByte];
      if (isMatchingNode(currentTree, path)) {
        const matchingNode = tree.bytes[currentByte];
        tree.bytes[currentByte] = {
          ...matchingNode,
          matches: [
            ...matchingNode.matches ? matchingNode.matches : [],
            createMatch(node)
          ]
        };
        return tree;
      }
      if (tree.bytes[currentByte]) {
        tree.bytes[currentByte] = exports2.merge(exports2.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
        return tree;
      }
      if (!tree.bytes[currentByte]) {
        tree.bytes[currentByte] = {
          ...tree.bytes[currentByte],
          ...exports2.createComplexNode(node.typename, path, node.info)
        };
      }
      return tree;
    };
    exports2.merge = merge;
    var createNode = (typename, bytes, info) => {
      return { typename, bytes, info: info ? info : {} };
    };
    exports2.createNode = createNode;
    var createComplexNode = (typename, bytes, info) => {
      let obj = {
        bytes: {},
        matches: void 0
      };
      const currentKey = head(bytes);
      const path = tail(bytes);
      if (bytes.length === 0) {
        return {
          matches: [
            createMatch({
              typename,
              info: info ? { extension: info.extension, mime: info.mime } : {}
            })
          ],
          bytes: {}
        };
      }
      obj.bytes[currentKey] = exports2.createComplexNode(typename, path, info);
      return obj;
    };
    exports2.createComplexNode = createComplexNode;
  }
});

// node_modules/magic-bytes.js/dist/model/pattern-tree.js
var require_pattern_tree = __commonJS({
  "node_modules/magic-bytes.js/dist/model/pattern-tree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var toHex_1 = require_toHex();
    var tree_1 = require_tree();
    var tree = {
      noOffset: null,
      offset: {}
    };
    var add = (typename, signature, additionalInfo, offset) => {
      if (offset) {
        const existing = tree.offset[toHex_1.toHex(offset)];
        if (!existing) {
          tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
        } else {
          const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), { ...existing });
          tree.offset[toHex_1.toHex(offset)] = merged;
        }
      } else {
        if (tree.noOffset === null) {
          tree.noOffset = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
        } else {
          tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), tree.noOffset);
        }
      }
    };
    add("gif", ["0x47", "0x49", "0x46", "0x38", "0x37", "0x61"], {
      mime: "image/gif",
      extension: "gif"
    });
    add("gif", ["0x47", "0x49", "0x46", "0x38", "0x39", "0x61"], {
      mime: "image/gif",
      extension: "gif"
    });
    add("jpg", ["0xFF", "0xD8", "0xFF"], {
      mime: "image/jpeg",
      extension: "jpeg"
    });
    add("jpg", ["0xFF", "0xD8", "0xFF", "0xDB"], {
      mime: "image/jpeg",
      extension: "jpeg"
    });
    add("jpg", [
      "0xFF",
      "0xD8",
      "0xFF",
      "0xE0",
      "?",
      "?",
      "0x4A",
      "0x46",
      "0x49",
      "0x46",
      "0x00",
      "0x01"
    ], { mime: "image/jpeg", extension: "jpeg" });
    add("jpg", [
      "0xFF",
      "0xD8",
      "0xFF",
      "0xE1",
      "?",
      "?",
      "0x45",
      "0x78",
      "0x69",
      "0x66",
      "0x00",
      "0x00"
    ], { mime: "image/jpeg", extension: "jpeg" });
    add("webp", [
      "0x52",
      "0x49",
      "0x46",
      "0x46",
      "?",
      "?",
      "?",
      "?",
      "0x57",
      "0x45",
      "0x42",
      "0x50"
    ], { mime: "image/webp", extension: "webp" });
    add("heif", ["0x66", "0x74", "0x79", "0x70", "0x6D", "0x69", "0x66", "0x31"], { mime: "image/heif", extension: "heif" }, 4);
    add("heif", ["0x66", "0x74", "0x79", "0x70", "0x68", "0x65", "0x69", "0x63"], { mime: "image/heif", extension: "heic" }, 4);
    add("rpm", ["0xed", "0xab", "0xee", "0xdb"]);
    add("bin", ["0x53", "0x50", "0x30", "0x31"], {
      mime: "application/octet-stream",
      extension: "bin"
    });
    add("pic", ["0x00"]);
    add("pif", ["0x00"]);
    add("sea", ["0x00"]);
    add("ytr", ["0x00"]);
    add("mp4", ["0x66", "0x74", "0x79", "0x70"], { mime: "video/mp4", extension: "mp4" }, 4);
    add("ttf", ["0x00", "0x01", "0x00", "0x00", "0x00"], {
      mime: "font/ttf",
      extension: "ttf"
    });
    add("otf", ["0x4F", "0x54", "0x54", "0x4F"], {
      mime: "font/otf",
      extension: "otf"
    });
    add("eot", ["0x50", "0x4C"], {
      mime: "application/vnd.ms-fontobject",
      extension: "eot"
    });
    add("woff", ["0x77", "0x4F", "0x46", "0x46"], {
      mime: "font/woff",
      extension: "woff"
    });
    add("woff2", ["0x77", "0x4F", "0x46", "0x32"], {
      mime: "font/woff2",
      extension: "woff2"
    });
    add("pdb", [
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00"
    ]);
    add("dba", ["0xBE", "0xBA", "0xFE", "0xCA"]);
    add("dba2", ["0x00", "0x01", "0x42", "0x44"]);
    add("tda", ["0x00", "0x01", "0x44", "0x54"]);
    add("tda2", ["0x00", "0x01", "0x00", "0x00"]);
    add("ico", ["0x00", "0x00", "0x01", "0x00"], {
      mime: "image/x-icon",
      extension: "ico"
    });
    add("3gp", ["0x66", "0x74", "0x79", "0x70", "0x33", "0x67"]);
    add("z", ["0x1F", "0x9D"]);
    add("tar.z", ["0x1F", "0xA0"]);
    add("bac", [
      "0x42",
      "0x41",
      "0x43",
      "0x4B",
      "0x4D",
      "0x49",
      "0x4B",
      "0x45",
      "0x44",
      "0x49",
      "0x53",
      "0x4B"
    ]);
    add("bz2", ["0x42", "0x5A", "0x68"], {
      mime: "application/x-bzip2",
      extension: "bz2"
    });
    add("tif", ["0x49", "0x49", "0x2A", "0x00"], {
      mime: "image/tiff",
      extension: "tif"
    });
    add("tiff", ["0x4D", "0x4D", "0x00", "0x2A"], {
      mime: "image/tiff",
      extension: "tiff"
    });
    add("cr2", [
      "0x49",
      "0x49",
      "0x2A",
      "0x00",
      "0x10",
      "0x00",
      "0x00",
      "0x00",
      "0x43",
      "0x52"
    ]);
    add("cin", ["0x80", "0x2A", "0x5F", "0xD7"]);
    add("cin1", ["0x52", "0x4E", "0x43", "0x01"]);
    add("cin2", ["0x52", "0x4E", "0x43", "0x02"]);
    add("dpx", ["0x53", "0x44", "0x50", "0x58"]);
    add("dpx2", ["0x58", "0x50", "0x44", "0x53"]);
    add("exr", ["0x76", "0x2F", "0x31", "0x01"]);
    add("bpg", ["0x42", "0x50", "0x47", "0xFB"]);
    add("ilbm", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x49",
      "0x4C",
      "0x42",
      "0x4D"
    ]);
    add("8svx", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x38",
      "0x53",
      "0x56",
      "0x58"
    ]);
    add("acbm", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x41",
      "0x43",
      "0x42",
      "0x4D"
    ]);
    add("anbm", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x41",
      "0x4E",
      "0x42",
      "0x4D"
    ]);
    add("anim", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x41",
      "0x4E",
      "0x49",
      "0x4D"
    ]);
    add("faxx", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x46",
      "0x41",
      "0x58",
      "0x58"
    ]);
    add("ftxt", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x46",
      "0x54",
      "0x58",
      "0x54"
    ]);
    add("smus", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x53",
      "0x4D",
      "0x55",
      "0x53"
    ]);
    add("cmus", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x43",
      "0x4D",
      "0x55",
      "0x53"
    ]);
    add("yuvn", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x59",
      "0x55",
      "0x56",
      "0x4E"
    ]);
    add("iff", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x46",
      "0x41",
      "0x4E",
      "0x54"
    ]);
    add("aiff", [
      "0x46",
      "0x4F",
      "0x52",
      "0x4D",
      "?",
      "?",
      "?",
      "?",
      "0x41",
      "0x49",
      "0x46",
      "0x46"
    ], { mime: "audio/x-aiff", extension: "aiff" });
    add("idx", ["0x49", "0x4E", "0x44", "0x58"]);
    add("lz", ["0x4C", "0x5A", "0x49", "0x50"]);
    add("exe", ["0x4D", "0x5A"]);
    add("zip", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/zip",
      extension: "zip"
    });
    add("zip", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/zip",
      extension: "zip"
    });
    add("zip", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/zip",
      extension: "zip"
    });
    add("jar", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/java-archive",
      extension: "jar"
    });
    add("jar", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/java-archive",
      extension: "jar"
    });
    add("jar", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/java-archive",
      extension: "jar"
    });
    add("odt", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.oasis.opendocument.text",
      extension: "odt"
    });
    add("odt", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.oasis.opendocument.text",
      extension: "odt"
    });
    add("odt", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.oasis.opendocument.text",
      extension: "odt"
    });
    add("ods", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.oasis.opendocument.spreadsheet",
      extension: "ods"
    });
    add("ods", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.oasis.opendocument.spreadsheet",
      extension: "ods"
    });
    add("ods", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.oasis.opendocument.spreadsheet",
      extension: "ods"
    });
    add("odp", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.oasis.opendocument.presentation",
      extension: "odp"
    });
    add("odp", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.oasis.opendocument.presentation",
      extension: "odp"
    });
    add("odp", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.oasis.opendocument.presentation",
      extension: "odp"
    });
    add("docx", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      extension: "docx"
    });
    add("docx", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      extension: "docx"
    });
    add("docx", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      extension: "docx"
    });
    add("xlsx", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      extension: "xlsx"
    });
    add("xlsx", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      extension: "xlsx"
    });
    add("xlsx", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      extension: "xlsx"
    });
    add("pptx", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      extension: "pptx"
    });
    add("pptx", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      extension: "pptx"
    });
    add("pptx", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      extension: "pptx"
    });
    add("vsdx", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.ms-visio.drawing",
      extension: "vsdx"
    });
    add("vsdx", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.ms-visio.drawing",
      extension: "vsdx"
    });
    add("vsdx", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.ms-visio.drawing",
      extension: "vsdx"
    });
    add("apk", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.android.package-archive",
      extension: "apk"
    });
    add("apk", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.android.package-archive",
      extension: "apk"
    });
    add("apk", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.android.package-archive",
      extension: "apk"
    });
    add("aar", ["0x50", "0x4B", "0x03", "0x04"], {
      mime: "application/vnd.android.package-archive",
      extension: "aar"
    });
    add("aar", ["0x50", "0x4B", "0x05", "0x06"], {
      mime: "application/vnd.android.package-archive",
      extension: "aar"
    });
    add("aar", ["0x50", "0x4B", "0x07", "0x08"], {
      mime: "application/vnd.android.package-archive",
      extension: "aar"
    });
    add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x00"], {
      mime: "application/vnd.rar",
      extension: "rar"
    });
    add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x01", "0x00"], {
      mime: "application/vnd.rar",
      extension: "rar"
    });
    add("rar", ["0x7F", "0x45", "0x4C", "0x46"], {
      mime: "application/vnd.rar",
      extension: "rar"
    });
    add("png", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
      mime: "image/png",
      extension: "png"
    });
    add("apng", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
      mime: "image/apng",
      extension: "apng"
    });
    add("class", ["0xCA", "0xFE", "0xBA", "0xBE"]);
    add("class", ["0xEF", "0xBB", "0xBF"]);
    add("class", ["0xFE", "0xed", "0xFA", "0xCE"], void 0, 4096);
    add("class", ["0xFE", "0xed", "0xFA", "0xCF"], void 0, 4096);
    add("class", ["0xCE", "0xFA", "0xed", "0xFE"]);
    add("class", ["0xCF", "0xFA", "0xed", "0xFE"]);
    add("class", ["0xFF", "0xFE"]);
    add("class", ["0xFF", "0xFE"]);
    add("class", ["0xFF", "0xFE", "0x00", "0x00"]);
    add("ps", ["0x25", "0x21", "0x50", "0x53"]);
    add("pdf", ["0x25", "0x50", "0x44", "0x46"], {
      mime: "application/pdf",
      extension: "pdf"
    });
    add("asf", [
      "0x30",
      "0x26",
      "0xB2",
      "0x75",
      "0x8E",
      "0x66",
      "0xCF",
      "0x11",
      "0xA6",
      "0xD9",
      "0x00",
      "0xAA",
      "0x00",
      "0x62",
      "0xCE",
      "0x6C"
    ]);
    add("wma", [
      "0x30",
      "0x26",
      "0xB2",
      "0x75",
      "0x8E",
      "0x66",
      "0xCF",
      "0x11",
      "0xA6",
      "0xD9",
      "0x00",
      "0xAA",
      "0x00",
      "0x62",
      "0xCE",
      "0x6C"
    ]);
    add("wmv", [
      "0x30",
      "0x26",
      "0xB2",
      "0x75",
      "0x8E",
      "0x66",
      "0xCF",
      "0x11",
      "0xA6",
      "0xD9",
      "0x00",
      "0xAA",
      "0x00",
      "0x62",
      "0xCE",
      "0x6C"
    ]);
    add("deploymentimage", [
      "0x24",
      "0x53",
      "0x44",
      "0x49",
      "0x30",
      "0x30",
      "0x30",
      "0x31"
    ]);
    add("ogv", [
      "0x4F",
      "0x67",
      "0x67",
      "0x53",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "0x80",
      "0x74",
      "0x68",
      "0x65",
      "0x6F",
      "0x72",
      "0x61"
    ], {
      mime: "video/ogg",
      extension: "ogv"
    });
    add("ogm", [
      "0x4F",
      "0x67",
      "0x67",
      "0x53",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "0x01",
      "0x76",
      "0x69",
      "0x64",
      "0x65",
      "0x6F",
      "0x00"
    ], {
      mime: "video/ogg",
      extension: "ogm"
    });
    add("oga", [
      "0x4F",
      "0x67",
      "0x67",
      "0x53",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "0x7F",
      "0x46",
      "0x4C",
      "0x41",
      "0x43"
    ], {
      mime: "audio/ogg",
      extension: "oga"
    });
    add("spx", [
      "0x4F",
      "0x67",
      "0x67",
      "0x53",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "0x53",
      "0x70",
      "0x65",
      "0x65",
      "0x78",
      "0x20",
      "0x20"
    ], {
      mime: "audio/ogg",
      extension: "spx"
    });
    add("ogg", [
      "0x4F",
      "0x67",
      "0x67",
      "0x53",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "?",
      "0x01",
      "0x76",
      "0x6F",
      "0x72",
      "0x62",
      "0x69",
      "0x73"
    ], {
      mime: "audio/ogg",
      extension: "ogg"
    });
    add("ogx", ["0x4F", "0x67", "0x67", "0x53"], {
      mime: "application/ogg",
      extension: "ogx"
    });
    add("psd", ["0x38", "0x42", "0x50", "0x53"], {
      mime: "application/x-photoshop",
      extension: "psd"
    });
    add("clip", ["0x43", "0x53", "0x46", "0x43", "0x48", "0x55", "0x4e", "0x4b"]);
    add("wav", [
      "0x52",
      "0x49",
      "0x46",
      "0x46",
      "?",
      "?",
      "?",
      "?",
      "0x57",
      "0x41",
      "0x56",
      "0x45"
    ], { mime: "audio/x-wav", extension: "wav" });
    add("avi", [
      "0x52",
      "0x49",
      "0x46",
      "0x46",
      "?",
      "?",
      "?",
      "?",
      "0x41",
      "0x56",
      "0x49",
      "0x20"
    ], { mime: "video/x-msvideo", extension: "avi" });
    add("mp3", ["0xFF", "0xFB"], { mime: "audio/mpeg", extension: "mp3" });
    add("mp3", ["0xFF", "0xF3"], { mime: "audio/mpeg", extension: "mp3" });
    add("mp3", ["0xFF", "0xF2"], { mime: "audio/mpeg", extension: "mp3" });
    add("mp3", ["0x49", "0x44", "0x33"], { mime: "audio/mpeg", extension: "mp3" });
    add("bmp", ["0x42", "0x4D"], { mime: "image/bmp", extension: "bmp" });
    add("iso", ["0x43", "0x44", "0x30", "0x30", "0x31"]);
    add("flac", ["0x66", "0x4C", "0x61", "0x43"]);
    add("mid", ["0x4D", "0x54", "0x68", "0x64"], {
      mime: "audio/midi",
      extension: "mid"
    });
    add("midi", ["0x4D", "0x54", "0x68", "0x64"], {
      mime: "audio/midi",
      extension: "midi"
    });
    add("doc", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
      mime: "application/msword",
      extension: "doc"
    });
    add("xls", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
      mime: "application/vnd.ms-excel",
      extension: "xls"
    });
    add("ppt", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
      mime: "application/vnd.ms-powerpoint",
      extension: "ppt"
    });
    add("msg", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"]);
    add("dex", ["0x64", "0x65", "0x78", "0x0A", "0x30", "0x33", "0x35", "0x00"]);
    add("vmdk", ["0x4B", "0x44", "0x4D"]);
    add("crx", ["0x43", "0x72", "0x32", "0x34"]);
    add("fh8", ["0x41", "0x47", "0x44", "0x33"]);
    add("cwk", [
      "0x05",
      "0x07",
      "0x00",
      "0x00",
      "0x42",
      "0x4F",
      "0x42",
      "0x4F",
      "0x05",
      "0x07",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x01"
    ]);
    add("cwk", [
      "0x06",
      "0x07",
      "0xE1",
      "0x00",
      "0x42",
      "0x4F",
      "0x42",
      "0x4F",
      "0x06",
      "0x07",
      "0xE1",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x00",
      "0x01"
    ]);
    add("toast", ["0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
    add("toast", ["0x8B", "0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
    add("dmg", ["0x78", "0x01", "0x73", "0x0D", "0x62", "0x62", "0x60"]);
    add("xar", ["0x78", "0x61", "0x72", "0x21"]);
    add("dat", ["0x50", "0x4D", "0x4F", "0x43", "0x43", "0x4D", "0x4F", "0x43"]);
    add("nes", ["0x4E", "0x45", "0x53", "0x1A"]);
    add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x00", "0x30", "0x30"], void 0, 257);
    add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x20", "0x20", "0x00"], void 0, 257);
    add("tox", ["0x74", "0x6F", "0x78", "0x33"]);
    add("mlv", ["0x4D", "0x4C", "0x56", "0x49"]);
    add("windowsupdate", [
      "0x44",
      "0x43",
      "0x4D",
      "0x01",
      "0x50",
      "0x41",
      "0x33",
      "0x30"
    ]);
    add("7z", ["0x37", "0x7A", "0xBC", "0xAF", "0x27", "0x1C"], {
      mime: "application/x-7z-compressed",
      extension: "7z"
    });
    add("gz", ["0x1F", "0x8B"], { mime: "application/gzip", extension: "gz" });
    add("tar.gz", ["0x1F", "0x8B"], {
      mime: "application/gzip",
      extension: "tar.gz"
    });
    add("xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
      mime: "application/gzip",
      extension: "xz"
    });
    add("tar.xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
      mime: "application/gzip",
      extension: "tar.xz"
    });
    add("lz2", ["0x04", "0x22", "0x4D", "0x18"]);
    add("cab", ["0x4D", "0x53", "0x43", "0x46"]);
    add("mkv", ["0x1A", "0x45", "0xDF", "0xA3"], {
      mime: "video/x-matroska",
      extension: "mkv"
    });
    add("mka", ["0x1A", "0x45", "0xDF", "0xA3"], {
      mime: "audio/x-matroska",
      extension: "mka"
    });
    add("mks", ["0x1A", "0x45", "0xDF", "0xA3"], {
      mime: "video/x-matroska",
      extension: "mks"
    });
    add("mk3d", ["0x1A", "0x45", "0xDF", "0xA3"]);
    add("webm", ["0x1A", "0x45", "0xDF", "0xA3"], {
      mime: "audio/webm",
      extension: "webm"
    });
    add("dcm", ["0x44", "0x49", "0x43", "0x4D"], void 0, 128);
    add("xml", ["0x3C", "0x3f", "0x78", "0x6d", "0x6C", "0x20"], {
      mime: "application/xml",
      extension: "xml"
    });
    add("wasm", ["0x00", "0x61", "0x73", "0x6d"], {
      mime: "application/wasm",
      extension: "wasm"
    });
    add("lep", ["0xCF", "0x84", "0x01"]);
    add("swf", ["0x43", "0x57", "0x53"], {
      mime: "application/x-shockwave-flash",
      extension: "swf"
    });
    add("swf", ["0x46", "0x57", "0x53"], {
      mime: "application/x-shockwave-flash",
      extension: "swf"
    });
    add("deb", ["0x21", "0x3C", "0x61", "0x72", "0x63", "0x68", "0x3E"]);
    add("rtf", ["0x7B", "0x5C", "0x72", "0x74", "0x66", "0x31"], {
      mime: "application/rtf",
      extension: "rtf"
    });
    add("m2p", ["0x00", "0x00", "0x01", "0xBA"]);
    add("vob", ["0x00", "0x00", "0x01", "0xBA"]);
    add("mpg", ["0x00", "0x00", "0x01", "0xBA"], {
      mime: "video/mpeg",
      extension: "mpg"
    });
    add("mpeg", ["0x00", "0x00", "0x01", "0xBA"], {
      mime: "video/mpeg",
      extension: "mpeg"
    });
    add("mpeg", ["0x47"], { mime: "video/mpeg", extension: "mpeg" });
    add("mpeg", ["0x00", "0x00", "0x01", "0xB3"], {
      mime: "video/mpeg",
      extension: "mpeg"
    });
    add("mov", ["0x66", "0x72", "0x65", "0x65"], {
      mime: "video/quicktime",
      extension: "mov"
    }, 4);
    add("mov", ["0x6D", "0x64", "0x61", "0x74"], {
      mime: "video/quicktime",
      extension: "mov"
    }, 4);
    add("mov", ["0x6D", "0x6F", "0x6F", "0x76"], {
      mime: "video/quicktime",
      extension: "mov"
    }, 4);
    add("mov", ["0x77", "0x69", "0x64", "0x65"], {
      mime: "video/quicktime",
      extension: "mov"
    }, 4);
    add("mov", ["0x66", "0x74", "0x79", "0x70", "0x71", "0x74"], {
      mime: "video/quicktime",
      extension: "mov"
    }, 4);
    add("hl2demo", ["0x48", "0x4C", "0x32", "0x44", "0x45", "0x4D", "0x4F"]);
    add("txt", ["0xEF", "0xBB", "0xBF"], {
      mime: "text/plain; charset=UTF-8",
      extension: "txt"
    });
    add("txt", ["0xFF", "0xFE"], {
      mime: "text/plain; charset=UTF-16LE",
      extension: "txt"
    });
    add("txt", ["0xFE", "0xFF"], {
      mime: "text/plain; charset=UTF-16BE",
      extension: "txt"
    });
    add("txt", ["0xFF", "0xFE", "0x00", "0x00"], {
      mime: "text/plain; charset=UTF-32LE",
      extension: "txt"
    });
    add("txt", ["0x00", "0x00", "0xFE", "0xFF"], {
      mime: "text/plain; charset=UTF-32BE",
      extension: "txt"
    });
    add("SubRip", ["0x31", "0x0D", "0x0A", "0x30", "0x30", "0x3A"], {
      mime: "application/x-subrip",
      extension: "srt"
    });
    add("WebVTT", [
      "0xEF",
      "0xBB",
      "0xBF",
      "0x57",
      "0x45",
      "0x42",
      "0x56",
      "0x54",
      "0x54",
      "0x0A"
    ], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", [
      "0xEF",
      "0xBB",
      "0xBF",
      "0x57",
      "0x45",
      "0x42",
      "0x56",
      "0x54",
      "0x54",
      "0x0D"
    ], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", [
      "0xEF",
      "0xBB",
      "0xBF",
      "0x57",
      "0x45",
      "0x42",
      "0x56",
      "0x54",
      "0x54",
      "0x20"
    ], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", [
      "0xEF",
      "0xBB",
      "0xBF",
      "0x57",
      "0x45",
      "0x42",
      "0x56",
      "0x54",
      "0x54",
      "0x09"
    ], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0A"], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0D"], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x20"], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x09"], {
      mime: "text/vtt",
      extension: "vtt"
    });
    add("Json", ["0x7B"], {
      mime: "application/json",
      extension: ".json"
    });
    add("Json", ["0x5B"], {
      mime: "application/json",
      extension: ".json"
    });
    add("ELF", ["0x7F", "0x45", "0x4C", "0x46"], {
      mime: "application/x-executable",
      extension: ".elf"
    });
    add("Mach-O", ["0xFE", "0xED", "0xFA", "0xC"], {
      mime: "application/x-mach-binary",
      extension: ".o"
    });
    add("Mach-O", ["0xFE", "0xED", "0xFA", "0xCF"], {
      mime: "application/x-executable",
      extension: "elf"
    });
    add("EML", ["0x52", "0x65", "0x63", "0x65", "0x69", "0x76", "0x65", "0x64", "0x3A"], {
      mime: "message/rfc822",
      extension: ".eml"
    });
    exports2.default = () => tree;
  }
});

// node_modules/magic-bytes.js/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/magic-bytes.js/dist/index.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filetypeextension = exports2.filetypemime = exports2.filetypename = exports2.filetypeinfo = void 0;
    var pattern_tree_1 = __importDefault2(require_pattern_tree());
    var toHex_1 = require_toHex();
    var patternTree = pattern_tree_1.default();
    var filetypeinfo = (bytes) => {
      let tree = patternTree;
      for (const k of Object.keys(tree.offset)) {
        const offset = toHex_1.fromHex(k);
        const offsetExceedsFile = offset >= bytes.length;
        if (offsetExceedsFile) {
          continue;
        }
        const node = patternTree.offset[k];
        const guessed = walkTree(offset, bytes, node);
        if (guessed.length > 0) {
          return guessed;
        }
      }
      if (tree.noOffset === null) {
        return [];
      }
      return walkTree(0, bytes, tree.noOffset);
    };
    exports2.filetypeinfo = filetypeinfo;
    var walkTree = (index, bytes, node) => {
      let step = node;
      let guessFile = [];
      while (true) {
        const currentByte = toHex_1.toHex(bytes[index]);
        if (step.bytes["?"] && !step.bytes[currentByte]) {
          step = step.bytes["?"];
        } else {
          step = step.bytes[currentByte];
        }
        if (!step) {
          return guessFile;
        }
        if (step && step.matches) {
          guessFile = step.matches.slice(0);
        }
        index += 1;
      }
    };
    exports2.default = exports2.filetypeinfo;
    var filetypename = (bytes) => exports2.filetypeinfo(bytes).map((e) => e.typename);
    exports2.filetypename = filetypename;
    var filetypemime = (bytes) => exports2.filetypeinfo(bytes).map((e) => e.mime ? e.mime : null).filter((x) => x !== null);
    exports2.filetypemime = filetypemime;
    var filetypeextension = (bytes) => exports2.filetypeinfo(bytes).map((e) => e.extension ? e.extension : null).filter((x) => x !== null);
    exports2.filetypeextension = filetypeextension;
  }
});

// node_modules/@sapphire/async-queue/dist/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/@sapphire/async-queue/dist/cjs/index.cjs"(exports2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __publicField2 = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var _AsyncQueueEntry = class _AsyncQueueEntry {
      constructor(queue) {
        __publicField2(this, "promise");
        __publicField2(this, "resolve");
        __publicField2(this, "reject");
        __publicField2(this, "queue");
        __publicField2(this, "signal", null);
        __publicField2(this, "signalListener", null);
        this.queue = queue;
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
      setSignal(signal) {
        if (signal.aborted)
          return this;
        this.signal = signal;
        this.signalListener = () => {
          const index = this.queue["promises"].indexOf(this);
          if (index !== -1)
            this.queue["promises"].splice(index, 1);
          this.reject(new Error("Request aborted manually"));
        };
        this.signal.addEventListener("abort", this.signalListener);
        return this;
      }
      use() {
        this.dispose();
        this.resolve();
        return this;
      }
      abort() {
        this.dispose();
        this.reject(new Error("Request aborted manually"));
        return this;
      }
      dispose() {
        if (this.signal) {
          this.signal.removeEventListener("abort", this.signalListener);
          this.signal = null;
          this.signalListener = null;
        }
      }
    };
    __name(_AsyncQueueEntry, "AsyncQueueEntry");
    var AsyncQueueEntry = _AsyncQueueEntry;
    var _AsyncQueue = class _AsyncQueue {
      constructor() {
        __publicField2(this, "promises", []);
      }
      /**
       * The amount of entries in the queue, including the head.
       * @seealso {@link queued} for the queued count.
       */
      get remaining() {
        return this.promises.length;
      }
      /**
       * The amount of queued entries.
       * @seealso {@link remaining} for the count with the head.
       */
      get queued() {
        return this.remaining === 0 ? 0 : this.remaining - 1;
      }
      /**
       * Waits for last promise and queues a new one
       * @example
       * ```typescript
       * const queue = new AsyncQueue();
       * async function request(url, options) {
       *     await queue.wait({ signal: options.signal });
       *     try {
       *         const result = await fetch(url, options);
       *         // Do some operations with 'result'
       *     } finally {
       *         // Remove first entry from the queue and resolve for the next entry
       *         queue.shift();
       *     }
       * }
       *
       * request(someUrl1, someOptions1); // Will call fetch() immediately
       * request(someUrl2, someOptions2); // Will call fetch() after the first finished
       * request(someUrl3, someOptions3); // Will call fetch() after the second finished
       * ```
       */
      wait(options) {
        const entry = new AsyncQueueEntry(this);
        if (this.promises.length === 0) {
          this.promises.push(entry);
          return Promise.resolve();
        }
        this.promises.push(entry);
        if (options == null ? void 0 : options.signal)
          entry.setSignal(options.signal);
        return entry.promise;
      }
      /**
       * Unlocks the head lock and transfers the next lock (if any) to the head.
       */
      shift() {
        if (this.promises.length === 0)
          return;
        if (this.promises.length === 1) {
          this.promises.shift();
          return;
        }
        this.promises.shift();
        this.promises[0].use();
      }
      /**
       * Aborts all the pending promises.
       * @note To avoid race conditions, this does **not** unlock the head lock.
       */
      abortAll() {
        if (this.queued === 0)
          return;
        for (let i = 1; i < this.promises.length; ++i) {
          this.promises[i].abort();
        }
        this.promises.length = 1;
      }
    };
    __name(_AsyncQueue, "AsyncQueue");
    var AsyncQueue = _AsyncQueue;
    exports2.AsyncQueue = AsyncQueue;
  }
});

// node_modules/@discordjs/rest/dist/web.js
var require_web = __commonJS({
  "node_modules/@discordjs/rest/dist/web.js"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var web_exports = {};
    __export2(web_exports, {
      ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
      ALLOWED_SIZES: () => ALLOWED_SIZES,
      ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
      BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
      CDN: () => CDN,
      DEPRECATION_WARNING_PREFIX: () => DEPRECATION_WARNING_PREFIX,
      DefaultRestOptions: () => DefaultRestOptions,
      DefaultUserAgent: () => DefaultUserAgent,
      DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
      DiscordAPIError: () => DiscordAPIError,
      HTTPError: () => HTTPError,
      OverwrittenMimeTypes: () => OverwrittenMimeTypes,
      REST: () => REST,
      RESTEvents: () => RESTEvents,
      RateLimitError: () => RateLimitError,
      RequestMethod: () => RequestMethod,
      calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
      makeURLSearchParams: () => makeURLSearchParams2,
      parseResponse: () => parseResponse,
      version: () => version
    });
    module2.exports = __toCommonJS2(web_exports);
    var defaultStrategy;
    function setDefaultStrategy(newStrategy) {
      defaultStrategy = newStrategy;
    }
    __name(setDefaultStrategy, "setDefaultStrategy");
    function getDefaultStrategy() {
      return defaultStrategy;
    }
    __name(getDefaultStrategy, "getDefaultStrategy");
    var import_util = require_dist();
    var import_v10 = require_v106();
    var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.2.0)`;
    var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
    var DefaultRestOptions = {
      agent: null,
      api: "https://discord.com/api",
      authPrefix: "Bot",
      cdn: "https://cdn.discordapp.com",
      headers: {},
      invalidRequestWarningInterval: 0,
      globalRequestsPerSecond: 50,
      offset: 50,
      rejectOnRateLimit: null,
      retries: 3,
      timeout: 15e3,
      userAgentAppendix: DefaultUserAgentAppendix,
      version: import_v10.APIVersion,
      hashSweepInterval: 144e5,
      // 4 Hours
      hashLifetime: 864e5,
      // 24 Hours
      handlerSweepInterval: 36e5,
      // 1 Hour
      async makeRequest(...args) {
        return getDefaultStrategy()(...args);
      }
    };
    var RESTEvents = ((RESTEvents2) => {
      RESTEvents2["Debug"] = "restDebug";
      RESTEvents2["HandlerSweep"] = "handlerSweep";
      RESTEvents2["HashSweep"] = "hashSweep";
      RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
      RESTEvents2["RateLimited"] = "rateLimited";
      RESTEvents2["Response"] = "response";
      return RESTEvents2;
    })(RESTEvents || {});
    var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
    var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
    var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
    var OverwrittenMimeTypes = {
      // https://github.com/discordjs/discord.js/issues/8557
      "image/apng": "image/png"
    };
    var BurstHandlerMajorIdKey = "burst";
    var DEPRECATION_WARNING_PREFIX = "DeprecationWarning";
    var _a;
    var RateLimitError = (_a = class extends Error {
      constructor({
        timeToReset,
        limit,
        method,
        hash,
        url,
        route,
        majorParameter,
        global: global2,
        retryAfter,
        sublimitTimeout,
        scope
      }) {
        super();
        __publicField(this, "timeToReset");
        __publicField(this, "limit");
        __publicField(this, "method");
        __publicField(this, "hash");
        __publicField(this, "url");
        __publicField(this, "route");
        __publicField(this, "majorParameter");
        __publicField(this, "global");
        __publicField(this, "retryAfter");
        __publicField(this, "sublimitTimeout");
        __publicField(this, "scope");
        this.timeToReset = timeToReset;
        this.limit = limit;
        this.method = method;
        this.hash = hash;
        this.url = url;
        this.route = route;
        this.majorParameter = majorParameter;
        this.global = global2;
        this.retryAfter = retryAfter;
        this.sublimitTimeout = sublimitTimeout;
        this.scope = scope;
      }
      /**
       * The name of the error
       */
      get name() {
        return `${_a.name}[${this.route}]`;
      }
    }, __name(_a, "RateLimitError"), _a);
    var RequestMethod = ((RequestMethod2) => {
      RequestMethod2["Delete"] = "DELETE";
      RequestMethod2["Get"] = "GET";
      RequestMethod2["Patch"] = "PATCH";
      RequestMethod2["Post"] = "POST";
      RequestMethod2["Put"] = "PUT";
      return RequestMethod2;
    })(RequestMethod || {});
    function serializeSearchParam(value) {
      switch (typeof value) {
        case "string":
          return value;
        case "number":
        case "bigint":
        case "boolean":
          return value.toString();
        case "object":
          if (value === null)
            return null;
          if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value.toISOString();
          }
          if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
            return value.toString();
          return null;
        default:
          return null;
      }
    }
    __name(serializeSearchParam, "serializeSearchParam");
    function makeURLSearchParams2(options) {
      const params = new URLSearchParams();
      if (!options)
        return params;
      for (const [key, value] of Object.entries(options)) {
        const serialized = serializeSearchParam(value);
        if (serialized !== null)
          params.append(key, serialized);
      }
      return params;
    }
    __name(makeURLSearchParams2, "makeURLSearchParams");
    async function parseResponse(res) {
      var _a8;
      if ((_a8 = res.headers.get("Content-Type")) == null ? void 0 : _a8.startsWith("application/json")) {
        return res.json();
      }
      return res.arrayBuffer();
    }
    __name(parseResponse, "parseResponse");
    function hasSublimit(bucketRoute, body, method) {
      if (bucketRoute === "/channels/:id") {
        if (typeof body !== "object" || body === null)
          return false;
        if (method !== "PATCH")
          return false;
        const castedBody = body;
        return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
      }
      return true;
    }
    __name(hasSublimit, "hasSublimit");
    function shouldRetry(error) {
      if (error.name === "AbortError")
        return true;
      return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
    }
    __name(shouldRetry, "shouldRetry");
    async function onRateLimit(manager, rateLimitData) {
      const { options } = manager;
      if (!options.rejectOnRateLimit)
        return;
      const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
      if (shouldThrow) {
        throw new RateLimitError(rateLimitData);
      }
    }
    __name(onRateLimit, "onRateLimit");
    function calculateUserDefaultAvatarIndex(userId) {
      return Number(BigInt(userId) >> 22n) % 6;
    }
    __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
    async function sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(() => resolve(), ms);
      });
    }
    __name(sleep, "sleep");
    function isBufferLike(value) {
      return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
    }
    __name(isBufferLike, "isBufferLike");
    function deprecationWarning(message) {
      if (typeof globalThis.process === "undefined") {
        console.warn(`${DEPRECATION_WARNING_PREFIX}: ${message}`);
      } else {
        process.emitWarning(message, DEPRECATION_WARNING_PREFIX);
      }
    }
    __name(deprecationWarning, "deprecationWarning");
    var deprecationEmittedForEmoji = false;
    var _a2;
    var CDN = (_a2 = class {
      constructor(base = DefaultRestOptions.cdn) {
        this.base = base;
      }
      /**
       * Generates an app asset URL for a client's asset.
       *
       * @param clientId - The client id that has the asset
       * @param assetHash - The hash provided by Discord for this asset
       * @param options - Optional options for the asset
       */
      appAsset(clientId, assetHash, options) {
        return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
      }
      /**
       * Generates an app icon URL for a client's icon.
       *
       * @param clientId - The client id that has the icon
       * @param iconHash - The hash provided by Discord for this icon
       * @param options - Optional options for the icon
       */
      appIcon(clientId, iconHash, options) {
        return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
      }
      /**
       * Generates an avatar URL, e.g. for a user or a webhook.
       *
       * @param id - The id that has the icon
       * @param avatarHash - The hash provided by Discord for this avatar
       * @param options - Optional options for the avatar
       */
      avatar(id, avatarHash, options) {
        return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
      }
      /**
       * Generates a user avatar decoration URL.
       *
       * @param userId - The id of the user
       * @param userAvatarDecoration - The hash provided by Discord for this avatar decoration
       * @param options - Optional options for the avatar decoration
       */
      avatarDecoration(userId, userAvatarDecoration, options) {
        return this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);
      }
      /**
       * Generates a banner URL, e.g. for a user or a guild.
       *
       * @param id - The id that has the banner splash
       * @param bannerHash - The hash provided by Discord for this banner
       * @param options - Optional options for the banner
       */
      banner(id, bannerHash, options) {
        return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
      }
      /**
       * Generates an icon URL for a channel, e.g. a group DM.
       *
       * @param channelId - The channel id that has the icon
       * @param iconHash - The hash provided by Discord for this channel
       * @param options - Optional options for the icon
       */
      channelIcon(channelId, iconHash, options) {
        return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
      }
      /**
       * Generates a default avatar URL
       *
       * @param index - The default avatar index
       * @remarks
       * To calculate the index for a user do `(userId >> 22) % 6`,
       * or `discriminator % 5` if they're using the legacy username system.
       */
      defaultAvatar(index) {
        return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
      }
      /**
       * Generates a discovery splash URL for a guild's discovery splash.
       *
       * @param guildId - The guild id that has the discovery splash
       * @param splashHash - The hash provided by Discord for this splash
       * @param options - Optional options for the splash
       */
      discoverySplash(guildId, splashHash, options) {
        return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
      }
      emoji(emojiId, options) {
        let resolvedOptions;
        if (typeof options === "string") {
          if (!deprecationEmittedForEmoji) {
            deprecationWarning(
              "Passing a string for the second parameter of CDN#emoji() is deprecated. Use an object instead."
            );
            deprecationEmittedForEmoji = true;
          }
          resolvedOptions = { extension: options };
        } else {
          resolvedOptions = options;
        }
        return this.makeURL(`/emojis/${emojiId}`, resolvedOptions);
      }
      /**
       * Generates a guild member avatar URL.
       *
       * @param guildId - The id of the guild
       * @param userId - The id of the user
       * @param avatarHash - The hash provided by Discord for this avatar
       * @param options - Optional options for the avatar
       */
      guildMemberAvatar(guildId, userId, avatarHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
      }
      /**
       * Generates a guild member banner URL.
       *
       * @param guildId - The id of the guild
       * @param userId - The id of the user
       * @param bannerHash - The hash provided by Discord for this banner
       * @param options - Optional options for the banner
       */
      guildMemberBanner(guildId, userId, bannerHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
      }
      /**
       * Generates an icon URL, e.g. for a guild.
       *
       * @param id - The id that has the icon splash
       * @param iconHash - The hash provided by Discord for this icon
       * @param options - Optional options for the icon
       */
      icon(id, iconHash, options) {
        return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
      }
      /**
       * Generates a URL for the icon of a role
       *
       * @param roleId - The id of the role that has the icon
       * @param roleIconHash - The hash provided by Discord for this role icon
       * @param options - Optional options for the role icon
       */
      roleIcon(roleId, roleIconHash, options) {
        return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
      }
      /**
       * Generates a guild invite splash URL for a guild's invite splash.
       *
       * @param guildId - The guild id that has the invite splash
       * @param splashHash - The hash provided by Discord for this splash
       * @param options - Optional options for the splash
       */
      splash(guildId, splashHash, options) {
        return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
      }
      /**
       * Generates a sticker URL.
       *
       * @param stickerId - The sticker id
       * @param extension - The extension of the sticker
       * @privateRemarks
       * Stickers cannot have a `.webp` extension, so we default to a `.png`
       */
      sticker(stickerId, extension = "png") {
        return this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });
      }
      /**
       * Generates a sticker pack banner URL.
       *
       * @param bannerId - The banner id
       * @param options - Optional options for the banner
       */
      stickerPackBanner(bannerId, options) {
        return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
      }
      /**
       * Generates a team icon URL for a team's icon.
       *
       * @param teamId - The team id that has the icon
       * @param iconHash - The hash provided by Discord for this icon
       * @param options - Optional options for the icon
       */
      teamIcon(teamId, iconHash, options) {
        return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
      }
      /**
       * Generates a cover image for a guild scheduled event.
       *
       * @param scheduledEventId - The scheduled event id
       * @param coverHash - The hash provided by discord for this cover image
       * @param options - Optional options for the cover image
       */
      guildScheduledEventCover(scheduledEventId, coverHash, options) {
        return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
      }
      /**
       * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
       *
       * @param route - The base cdn route
       * @param hash - The hash provided by Discord for this icon
       * @param options - Optional options for the link
       */
      dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
        return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
      }
      /**
       * Constructs the URL for the resource
       *
       * @param route - The base cdn route
       * @param options - The extension/size options for the link
       */
      makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
        extension = String(extension).toLowerCase();
        if (!allowedExtensions.includes(extension)) {
          throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
        }
        if (size && !ALLOWED_SIZES.includes(size)) {
          throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
        }
        const url = new URL(`${this.base}${route}.${extension}`);
        if (size) {
          url.searchParams.set("size", String(size));
        }
        return url.toString();
      }
    }, __name(_a2, "CDN"), _a2);
    function isErrorGroupWrapper(error) {
      return Reflect.has(error, "_errors");
    }
    __name(isErrorGroupWrapper, "isErrorGroupWrapper");
    function isErrorResponse(error) {
      return typeof Reflect.get(error, "message") === "string";
    }
    __name(isErrorResponse, "isErrorResponse");
    var _a3;
    var DiscordAPIError = (_a3 = class extends Error {
      /**
       * @param rawError - The error reported by Discord
       * @param code - The error code reported by Discord
       * @param status - The status code of the response
       * @param method - The method of the request that erred
       * @param url - The url of the request that erred
       * @param bodyData - The unparsed data for the request that errored
       */
      constructor(rawError, code, status, method, url, bodyData) {
        super(_a3.getMessage(rawError));
        __publicField(this, "requestBody");
        this.rawError = rawError;
        this.code = code;
        this.status = status;
        this.method = method;
        this.url = url;
        this.requestBody = { files: bodyData.files, json: bodyData.body };
      }
      /**
       * The name of the error
       */
      get name() {
        return `${_a3.name}[${this.code}]`;
      }
      static getMessage(error) {
        let flattened = "";
        if ("code" in error) {
          if (error.errors) {
            flattened = [...this.flattenDiscordError(error.errors)].join("\n");
          }
          return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
        }
        return error.error_description ?? "No Description";
      }
      static *flattenDiscordError(obj, key = "") {
        if (isErrorResponse(obj)) {
          return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
        }
        for (const [otherKey, val] of Object.entries(obj)) {
          const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
          if (typeof val === "string") {
            yield val;
          } else if (isErrorGroupWrapper(val)) {
            for (const error of val._errors) {
              yield* this.flattenDiscordError(error, nextKey);
            }
          } else {
            yield* this.flattenDiscordError(val, nextKey);
          }
        }
      }
    }, __name(_a3, "DiscordAPIError"), _a3);
    var _a4;
    var HTTPError = (_a4 = class extends Error {
      /**
       * @param status - The status code of the response
       * @param statusText - The status text of the response
       * @param method - The method of the request that erred
       * @param url - The url of the request that erred
       * @param bodyData - The unparsed data for the request that errored
       */
      constructor(status, statusText, method, url, bodyData) {
        super(statusText);
        __publicField(this, "requestBody");
        __publicField(this, "name", _a4.name);
        this.status = status;
        this.method = method;
        this.url = url;
        this.requestBody = { files: bodyData.files, json: bodyData.body };
      }
    }, __name(_a4, "HTTPError"), _a4);
    var import_collection = require_dist2();
    var import_snowflake = require_dist3();
    var import_async_event_emitter = require_dist4();
    var import_magic_bytes = require_dist5();
    var invalidCount = 0;
    var invalidCountResetTime = null;
    function incrementInvalidCount(manager) {
      if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
        invalidCount = 0;
      }
      invalidCount++;
      const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
      if (emitInvalid) {
        manager.emit("invalidRequestWarning", {
          count: invalidCount,
          remainingTime: invalidCountResetTime - Date.now()
        });
      }
    }
    __name(incrementInvalidCount, "incrementInvalidCount");
    async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
      if (requestData.signal) {
        if (requestData.signal.aborted)
          controller.abort();
        else
          requestData.signal.addEventListener("abort", () => controller.abort());
      }
      let res;
      try {
        res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
      } catch (error) {
        if (!(error instanceof Error))
          throw error;
        if (shouldRetry(error) && retries !== manager.options.retries) {
          return null;
        }
        throw error;
      } finally {
        clearTimeout(timeout);
      }
      if (manager.listenerCount(
        "response"
        /* Response */
      )) {
        manager.emit(
          "response",
          {
            method: options.method ?? "get",
            path: routeId.original,
            route: routeId.bucketRoute,
            options,
            data: requestData,
            retries
          },
          res instanceof Response ? res.clone() : { ...res }
        );
      }
      return res;
    }
    __name(makeNetworkRequest, "makeNetworkRequest");
    async function handleErrors(manager, res, method, url, requestData, retries) {
      const status = res.status;
      if (status >= 500 && status < 600) {
        if (retries !== manager.options.retries) {
          return null;
        }
        throw new HTTPError(status, res.statusText, method, url, requestData);
      } else {
        if (status >= 400 && status < 500) {
          if (status === 401 && requestData.auth) {
            manager.setToken(null);
          }
          const data = await parseResponse(res);
          throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
        }
        return res;
      }
    }
    __name(handleErrors, "handleErrors");
    var _a5;
    var BurstHandler = (_a5 = class {
      /**
       * @param manager - The request manager
       * @param hash - The hash that this RequestHandler handles
       * @param majorParameter - The major parameter for this handler
       */
      constructor(manager, hash, majorParameter) {
        /**
         * {@inheritdoc IHandler.id}
         */
        __publicField(this, "id");
        /**
         * {@inheritDoc IHandler.inactive}
         */
        __publicField(this, "inactive", false);
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
      }
      /**
       * Emits a debug message
       *
       * @param message - The message to debug
       */
      debug(message) {
        this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
      }
      /**
       * {@inheritDoc IHandler.queueRequest}
       */
      async queueRequest(routeId, url, options, requestData) {
        return this.runRequest(routeId, url, options, requestData);
      }
      /**
       * The method that actually makes the request to the API, and updates info about the bucket accordingly
       *
       * @param routeId - The generalized API route with literal ids for major parameters
       * @param url - The fully resolved URL to make the request to
       * @param options - The fetch options needed to make the request
       * @param requestData - Extra data from the user's request needed for errors and additional processing
       * @param retries - The number of retries this request has already attempted (recursion)
       */
      async runRequest(routeId, url, options, requestData, retries = 0) {
        const method = options.method ?? "get";
        const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
        if (res === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        const status = res.status;
        let retryAfter = 0;
        const retry = res.headers.get("Retry-After");
        if (retry)
          retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
        if (status === 401 || status === 403 || status === 429) {
          incrementInvalidCount(this.manager);
        }
        if (status >= 200 && status < 300) {
          return res;
        } else if (status === 429) {
          const isGlobal = res.headers.has("X-RateLimit-Global");
          const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
          await onRateLimit(this.manager, {
            global: isGlobal,
            method,
            url,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            hash: this.hash,
            limit: Number.POSITIVE_INFINITY,
            timeToReset: retryAfter,
            retryAfter,
            sublimitTimeout: 0,
            scope
          });
          this.debug(
            [
              "Encountered unexpected 429 rate limit",
              `  Global         : ${isGlobal}`,
              `  Method         : ${method}`,
              `  URL            : ${url}`,
              `  Bucket         : ${routeId.bucketRoute}`,
              `  Major parameter: ${routeId.majorParameter}`,
              `  Hash           : ${this.hash}`,
              `  Limit          : ${Number.POSITIVE_INFINITY}`,
              `  Retry After    : ${retryAfter}ms`,
              `  Sublimit       : None`,
              `  Scope          : ${scope}`
            ].join("\n")
          );
          await sleep(retryAfter);
          return this.runRequest(routeId, url, options, requestData, retries);
        } else {
          const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
          if (handled === null) {
            return this.runRequest(routeId, url, options, requestData, ++retries);
          }
          return handled;
        }
      }
    }, __name(_a5, "BurstHandler"), _a5);
    var import_async_queue = require_cjs();
    var _asyncQueue, _sublimitedQueue, _sublimitPromise, _shiftSublimit, _a6;
    var SequentialHandler = (_a6 = class {
      /**
       * @param manager - The request manager
       * @param hash - The hash that this RequestHandler handles
       * @param majorParameter - The major parameter for this handler
       */
      constructor(manager, hash, majorParameter) {
        /**
         * {@inheritDoc IHandler.id}
         */
        __publicField(this, "id");
        /**
         * The time this rate limit bucket will reset
         */
        __publicField(this, "reset", -1);
        /**
         * The remaining requests that can be made before we are rate limited
         */
        __publicField(this, "remaining", 1);
        /**
         * The total number of requests that can be made before we are rate limited
         */
        __publicField(this, "limit", Number.POSITIVE_INFINITY);
        /**
         * The interface used to sequence async requests sequentially
         */
        __privateAdd(this, _asyncQueue, new import_async_queue.AsyncQueue());
        /**
         * The interface used to sequence sublimited async requests sequentially
         */
        __privateAdd(this, _sublimitedQueue, null);
        /**
         * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed
         */
        __privateAdd(this, _sublimitPromise, null);
        /**
         * Whether the sublimit queue needs to be shifted in the finally block
         */
        __privateAdd(this, _shiftSublimit, false);
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
      }
      /**
       * {@inheritDoc IHandler.inactive}
       */
      get inactive() {
        return __privateGet(this, _asyncQueue).remaining === 0 && (__privateGet(this, _sublimitedQueue) === null || __privateGet(this, _sublimitedQueue).remaining === 0) && !this.limited;
      }
      /**
       * If the rate limit bucket is currently limited by the global limit
       */
      get globalLimited() {
        return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
      }
      /**
       * If the rate limit bucket is currently limited by its limit
       */
      get localLimited() {
        return this.remaining <= 0 && Date.now() < this.reset;
      }
      /**
       * If the rate limit bucket is currently limited
       */
      get limited() {
        return this.globalLimited || this.localLimited;
      }
      /**
       * The time until queued requests can continue
       */
      get timeToReset() {
        return this.reset + this.manager.options.offset - Date.now();
      }
      /**
       * Emits a debug message
       *
       * @param message - The message to debug
       */
      debug(message) {
        this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
      }
      /**
       * Delay all requests for the specified amount of time, handling global rate limits
       *
       * @param time - The amount of time to delay all requests for
       */
      async globalDelayFor(time) {
        await sleep(time);
        this.manager.globalDelay = null;
      }
      /**
       * {@inheritDoc IHandler.queueRequest}
       */
      async queueRequest(routeId, url, options, requestData) {
        var _a8, _b, _c;
        let queue = __privateGet(this, _asyncQueue);
        let queueType = 0;
        if (__privateGet(this, _sublimitedQueue) && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = __privateGet(this, _sublimitedQueue);
          queueType = 1;
        }
        await queue.wait({ signal: requestData.signal });
        if (queueType === 0) {
          if (__privateGet(this, _sublimitedQueue) && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
            queue = __privateGet(this, _sublimitedQueue);
            const wait = queue.wait();
            __privateGet(this, _asyncQueue).shift();
            await wait;
          } else if (__privateGet(this, _sublimitPromise)) {
            await __privateGet(this, _sublimitPromise).promise;
          }
        }
        try {
          return await this.runRequest(routeId, url, options, requestData);
        } finally {
          queue.shift();
          if (__privateGet(this, _shiftSublimit)) {
            __privateSet(this, _shiftSublimit, false);
            (_a8 = __privateGet(this, _sublimitedQueue)) == null ? void 0 : _a8.shift();
          }
          if (((_b = __privateGet(this, _sublimitedQueue)) == null ? void 0 : _b.remaining) === 0) {
            (_c = __privateGet(this, _sublimitPromise)) == null ? void 0 : _c.resolve();
            __privateSet(this, _sublimitedQueue, null);
          }
        }
      }
      /**
       * The method that actually makes the request to the api, and updates info about the bucket accordingly
       *
       * @param routeId - The generalized api route with literal ids for major parameters
       * @param url - The fully resolved url to make the request to
       * @param options - The fetch options needed to make the request
       * @param requestData - Extra data from the user's request needed for errors and additional processing
       * @param retries - The number of retries this request has already attempted (recursion)
       */
      async runRequest(routeId, url, options, requestData, retries = 0) {
        var _a8;
        while (this.limited) {
          const isGlobal = this.globalLimited;
          let limit2;
          let timeout;
          let delay;
          if (isGlobal) {
            limit2 = this.manager.options.globalRequestsPerSecond;
            timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
            if (!this.manager.globalDelay) {
              this.manager.globalDelay = this.globalDelayFor(timeout);
            }
            delay = this.manager.globalDelay;
          } else {
            limit2 = this.limit;
            timeout = this.timeToReset;
            delay = sleep(timeout);
          }
          const rateLimitData = {
            global: isGlobal,
            method: options.method ?? "get",
            url,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            hash: this.hash,
            limit: limit2,
            timeToReset: timeout,
            retryAfter: timeout,
            sublimitTimeout: 0,
            scope: "user"
          };
          this.manager.emit("rateLimited", rateLimitData);
          await onRateLimit(this.manager, rateLimitData);
          if (isGlobal) {
            this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
          } else {
            this.debug(`Waiting ${timeout}ms for rate limit to pass`);
          }
          await delay;
        }
        if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
          this.manager.globalReset = Date.now() + 1e3;
          this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
        }
        this.manager.globalRemaining--;
        const method = options.method ?? "get";
        const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
        if (res === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        const status = res.status;
        let retryAfter = 0;
        const limit = res.headers.get("X-RateLimit-Limit");
        const remaining = res.headers.get("X-RateLimit-Remaining");
        const reset = res.headers.get("X-RateLimit-Reset-After");
        const hash = res.headers.get("X-RateLimit-Bucket");
        const retry = res.headers.get("Retry-After");
        const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
        this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
        this.remaining = remaining ? Number(remaining) : 1;
        this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();
        if (retry)
          retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
        if (hash && hash !== this.hash) {
          this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
          this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
        } else if (hash) {
          const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
          if (hashData) {
            hashData.lastAccess = Date.now();
          }
        }
        let sublimitTimeout = null;
        if (retryAfter > 0) {
          if (res.headers.has("X-RateLimit-Global")) {
            this.manager.globalRemaining = 0;
            this.manager.globalReset = Date.now() + retryAfter;
          } else if (!this.localLimited) {
            sublimitTimeout = retryAfter;
          }
        }
        if (status === 401 || status === 403 || status === 429) {
          incrementInvalidCount(this.manager);
        }
        if (res.ok) {
          return res;
        } else if (status === 429) {
          const isGlobal = this.globalLimited;
          let limit2;
          let timeout;
          if (isGlobal) {
            limit2 = this.manager.options.globalRequestsPerSecond;
            timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
          } else {
            limit2 = this.limit;
            timeout = this.timeToReset;
          }
          await onRateLimit(this.manager, {
            global: isGlobal,
            method,
            url,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            hash: this.hash,
            limit: limit2,
            timeToReset: timeout,
            retryAfter,
            sublimitTimeout: sublimitTimeout ?? 0,
            scope
          });
          this.debug(
            [
              "Encountered unexpected 429 rate limit",
              `  Global         : ${isGlobal.toString()}`,
              `  Method         : ${method}`,
              `  URL            : ${url}`,
              `  Bucket         : ${routeId.bucketRoute}`,
              `  Major parameter: ${routeId.majorParameter}`,
              `  Hash           : ${this.hash}`,
              `  Limit          : ${limit2}`,
              `  Retry After    : ${retryAfter}ms`,
              `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`,
              `  Scope          : ${scope}`
            ].join("\n")
          );
          if (sublimitTimeout) {
            const firstSublimit = !__privateGet(this, _sublimitedQueue);
            if (firstSublimit) {
              __privateSet(this, _sublimitedQueue, new import_async_queue.AsyncQueue());
              void __privateGet(this, _sublimitedQueue).wait();
              __privateGet(this, _asyncQueue).shift();
            }
            (_a8 = __privateGet(this, _sublimitPromise)) == null ? void 0 : _a8.resolve();
            __privateSet(this, _sublimitPromise, null);
            await sleep(sublimitTimeout);
            let resolve;
            const promise = new Promise((res2) => resolve = res2);
            __privateSet(this, _sublimitPromise, { promise, resolve });
            if (firstSublimit) {
              await __privateGet(this, _asyncQueue).wait();
              __privateSet(this, _shiftSublimit, true);
            }
          }
          return this.runRequest(routeId, url, options, requestData, retries);
        } else {
          const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
          if (handled === null) {
            return this.runRequest(routeId, url, options, requestData, ++retries);
          }
          return handled;
        }
      }
    }, _asyncQueue = new WeakMap(), _sublimitedQueue = new WeakMap(), _sublimitPromise = new WeakMap(), _shiftSublimit = new WeakMap(), __name(_a6, "SequentialHandler"), _a6);
    var _token, _a7;
    var REST = (_a7 = class extends import_async_event_emitter.AsyncEventEmitter {
      constructor(options = {}) {
        super();
        /**
         * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
         * performed by this manager.
         */
        __publicField(this, "agent", null);
        __publicField(this, "cdn");
        /**
         * The number of requests remaining in the global bucket
         */
        __publicField(this, "globalRemaining");
        /**
         * The promise used to wait out the global rate limit
         */
        __publicField(this, "globalDelay", null);
        /**
         * The timestamp at which the global bucket resets
         */
        __publicField(this, "globalReset", -1);
        /**
         * API bucket hashes that are cached from provided routes
         */
        __publicField(this, "hashes", new import_collection.Collection());
        /**
         * Request handlers created from the bucket hash and the major parameters
         */
        __publicField(this, "handlers", new import_collection.Collection());
        __privateAdd(this, _token, null);
        __publicField(this, "hashTimer");
        __publicField(this, "handlerTimer");
        __publicField(this, "options");
        this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
        this.options = { ...DefaultRestOptions, ...options };
        this.options.offset = Math.max(0, this.options.offset);
        this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
        this.agent = options.agent ?? null;
        this.setupSweepers();
      }
      setupSweepers() {
        var _a8, _b, _c, _d;
        const validateMaxInterval = __name((interval) => {
          if (interval > 144e5) {
            throw new Error("Cannot set an interval greater than 4 hours");
          }
        }, "validateMaxInterval");
        if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
          validateMaxInterval(this.options.hashSweepInterval);
          this.hashTimer = setInterval(() => {
            const sweptHashes = new import_collection.Collection();
            const currentDate = Date.now();
            this.hashes.sweep((val, key) => {
              if (val.lastAccess === -1)
                return false;
              const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
              if (shouldSweep) {
                sweptHashes.set(key, val);
                this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
              }
              return shouldSweep;
            });
            this.emit("hashSweep", sweptHashes);
          }, this.options.hashSweepInterval);
          (_b = (_a8 = this.hashTimer).unref) == null ? void 0 : _b.call(_a8);
        }
        if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
          validateMaxInterval(this.options.handlerSweepInterval);
          this.handlerTimer = setInterval(() => {
            const sweptHandlers = new import_collection.Collection();
            this.handlers.sweep((val, key) => {
              const { inactive } = val;
              if (inactive) {
                sweptHandlers.set(key, val);
                this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
              }
              return inactive;
            });
            this.emit("handlerSweep", sweptHandlers);
          }, this.options.handlerSweepInterval);
          (_d = (_c = this.handlerTimer).unref) == null ? void 0 : _d.call(_c);
        }
      }
      /**
       * Runs a get request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async get(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "GET"
          /* Get */
        });
      }
      /**
       * Runs a delete request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async delete(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "DELETE"
          /* Delete */
        });
      }
      /**
       * Runs a post request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async post(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "POST"
          /* Post */
        });
      }
      /**
       * Runs a put request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async put(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "PUT"
          /* Put */
        });
      }
      /**
       * Runs a patch request from the api
       *
       * @param fullRoute - The full route to query
       * @param options - Optional request options
       */
      async patch(fullRoute, options = {}) {
        return this.request({
          ...options,
          fullRoute,
          method: "PATCH"
          /* Patch */
        });
      }
      /**
       * Runs a request from the api
       *
       * @param options - Request options
       */
      async request(options) {
        const response = await this.queueRequest(options);
        return parseResponse(response);
      }
      /**
       * Sets the default agent to use for requests performed by this manager
       *
       * @param agent - The agent to use
       */
      setAgent(agent) {
        this.agent = agent;
        return this;
      }
      /**
       * Sets the authorization token that should be used for requests
       *
       * @param token - The authorization token to use
       */
      setToken(token) {
        __privateSet(this, _token, token);
        return this;
      }
      /**
       * Queues a request to be sent
       *
       * @param request - All the information needed to make a request
       * @returns The response from the api request
       */
      async queueRequest(request) {
        const routeId = _a7.generateRouteData(request.fullRoute, request.method);
        const hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {
          value: `Global(${request.method}:${routeId.bucketRoute})`,
          lastAccess: -1
        };
        const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
        const { url, fetchOptions } = await this.resolveRequest(request);
        return handler.queueRequest(routeId, url, fetchOptions, {
          body: request.body,
          files: request.files,
          auth: request.auth !== false,
          signal: request.signal
        });
      }
      /**
       * Creates a new rate limit handler from a hash, based on the hash and the major parameter
       *
       * @param hash - The hash for the route
       * @param majorParameter - The major parameter for this handler
       * @internal
       */
      createHandler(hash, majorParameter) {
        const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
        this.handlers.set(queue.id, queue);
        return queue;
      }
      /**
       * Formats the request data to a usable format for fetch
       *
       * @param request - The request data
       */
      async resolveRequest(request) {
        var _a8, _b;
        const { options } = this;
        let query = "";
        if (request.query) {
          const resolvedQuery = request.query.toString();
          if (resolvedQuery !== "") {
            query = `?${resolvedQuery}`;
          }
        }
        const headers = {
          ...this.options.headers,
          "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
        };
        if (request.auth !== false) {
          if (!__privateGet(this, _token)) {
            throw new Error("Expected token to be set for this request, but none was present");
          }
          headers.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${__privateGet(this, _token)}`;
        }
        if ((_a8 = request.reason) == null ? void 0 : _a8.length) {
          headers["X-Audit-Log-Reason"] = encodeURIComponent(request.reason);
        }
        const url = `${options.api}${request.versioned === false ? "" : `/v${options.version}`}${request.fullRoute}${query}`;
        let finalBody;
        let additionalHeaders = {};
        if ((_b = request.files) == null ? void 0 : _b.length) {
          const formData = new FormData();
          for (const [index, file] of request.files.entries()) {
            const fileKey = file.key ?? `files[${index}]`;
            if (isBufferLike(file.data)) {
              let contentType = file.contentType;
              if (!contentType) {
                const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
                if (parsedType) {
                  contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
                }
              }
              formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
            } else {
              formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
            }
          }
          if (request.body != null) {
            if (request.appendToFormData) {
              for (const [key, value] of Object.entries(request.body)) {
                formData.append(key, value);
              }
            } else {
              formData.append("payload_json", JSON.stringify(request.body));
            }
          }
          finalBody = formData;
        } else if (request.body != null) {
          if (request.passThroughBody) {
            finalBody = request.body;
          } else {
            finalBody = JSON.stringify(request.body);
            additionalHeaders = { "Content-Type": "application/json" };
          }
        }
        const method = request.method.toUpperCase();
        const fetchOptions = {
          // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing
          body: ["GET", "HEAD"].includes(method) ? null : finalBody,
          headers: { ...request.headers, ...additionalHeaders, ...headers },
          method,
          // Prioritize setting an agent per request, use the agent for this instance otherwise.
          dispatcher: request.dispatcher ?? this.agent ?? void 0
        };
        return { url, fetchOptions };
      }
      /**
       * Stops the hash sweeping interval
       */
      clearHashSweeper() {
        clearInterval(this.hashTimer);
      }
      /**
       * Stops the request handler sweeping interval
       */
      clearHandlerSweeper() {
        clearInterval(this.handlerTimer);
      }
      /**
       * Generates route data for an endpoint:method
       *
       * @param endpoint - The raw endpoint to generalize
       * @param method - The HTTP method this endpoint is called without
       * @internal
       */
      static generateRouteData(endpoint, method) {
        if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
          return {
            majorParameter: BurstHandlerMajorIdKey,
            bucketRoute: "/interactions/:id/:token/callback",
            original: endpoint
          };
        }
        const majorIdMatch = /(?:^\/webhooks\/(\d{17,19}\/[^/?]+))|(?:^\/(?:channels|guilds|webhooks)\/(\d{17,19}))/.exec(
          endpoint
        );
        const majorId = (majorIdMatch == null ? void 0 : majorIdMatch[2]) ?? (majorIdMatch == null ? void 0 : majorIdMatch[1]) ?? "global";
        const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction").replace(/\/webhooks\/:id\/[^/?]+/, "/webhooks/:id/:token");
        let exceptions = "";
        if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
          const id = /\d{17,19}$/.exec(endpoint)[0];
          const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
          if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
            exceptions += "/Delete Old Message";
          }
        }
        return {
          majorParameter: majorId,
          bucketRoute: baseRoute + exceptions,
          original: endpoint
        };
      }
    }, _token = new WeakMap(), __name(_a7, "REST"), _a7);
    var version = "2.2.0";
    setDefaultStrategy(fetch);
  }
});

// node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS({
  "node_modules/discord.js/src/errors/ErrorCodes.js"(exports2, module2) {
    "use strict";
    var keys = [
      "ClientInvalidOption",
      "ClientInvalidProvidedShards",
      "ClientMissingIntents",
      "ClientNotReady",
      "TokenInvalid",
      "TokenMissing",
      "ApplicationCommandPermissionsTokenMissing",
      "WSCloseRequested",
      "WSConnectionExists",
      "WSNotOpen",
      "ManagerDestroyed",
      "BitFieldInvalid",
      "ShardingInvalid",
      "ShardingRequired",
      "InvalidIntents",
      "DisallowedIntents",
      "ShardingNoShards",
      "ShardingInProcess",
      "ShardingInvalidEvalBroadcast",
      "ShardingShardNotFound",
      "ShardingAlreadySpawned",
      "ShardingProcessExists",
      "ShardingWorkerExists",
      "ShardingReadyTimeout",
      "ShardingReadyDisconnected",
      "ShardingReadyDied",
      "ShardingNoChildExists",
      "ShardingShardMiscalculation",
      "ColorRange",
      "ColorConvert",
      "InviteOptionsMissingChannel",
      "ButtonLabel",
      "ButtonURL",
      "ButtonCustomId",
      "SelectMenuCustomId",
      "SelectMenuPlaceholder",
      "SelectOptionLabel",
      "SelectOptionValue",
      "SelectOptionDescription",
      "InteractionCollectorError",
      "FileNotFound",
      "UserBannerNotFetched",
      "UserNoDMChannel",
      "VoiceNotStageChannel",
      "VoiceStateNotOwn",
      "VoiceStateInvalidType",
      "ReqResourceType",
      "ImageFormat",
      "ImageSize",
      "MessageBulkDeleteType",
      "MessageNonceType",
      "MessageContentType",
      "SplitMaxLen",
      "BanResolveId",
      "FetchBanResolveId",
      "PruneDaysType",
      "GuildChannelResolve",
      "GuildVoiceChannelResolve",
      "GuildChannelOrphan",
      "GuildChannelUnowned",
      "GuildOwned",
      "GuildMembersTimeout",
      "GuildUncachedMe",
      "ChannelNotCached",
      "StageChannelResolve",
      "GuildScheduledEventResolve",
      "FetchOwnerId",
      "InvalidType",
      "InvalidElement",
      "MessageThreadParent",
      "MessageExistingThread",
      "ThreadInvitableType",
      "WebhookMessage",
      "WebhookTokenUnavailable",
      "WebhookURLInvalid",
      "WebhookApplication",
      "MessageReferenceMissing",
      "EmojiType",
      "EmojiManaged",
      "MissingManageGuildExpressionsPermission",
      "MissingManageEmojisAndStickersPermission",
      "NotGuildSticker",
      "ReactionResolveUser",
      "VanityURL",
      "InviteResolveCode",
      "InviteNotFound",
      "DeleteGroupDMChannel",
      "FetchGroupDMChannel",
      "MemberFetchNonceLength",
      "GlobalCommandPermissions",
      "GuildUncachedEntityResolve",
      "InteractionAlreadyReplied",
      "InteractionNotReplied",
      "InteractionEphemeralReplied",
      "CommandInteractionOptionNotFound",
      "CommandInteractionOptionType",
      "CommandInteractionOptionEmpty",
      "CommandInteractionOptionNoSubcommand",
      "CommandInteractionOptionNoSubcommandGroup",
      "CommandInteractionOptionInvalidChannelType",
      "AutocompleteInteractionOptionNoFocusedOption",
      "ModalSubmitInteractionFieldNotFound",
      "ModalSubmitInteractionFieldType",
      "InvalidMissingScopes",
      "InvalidScopesWithPermissions",
      "NotImplemented",
      "SweepFilterReturn",
      "GuildForumMessageRequired"
    ];
    module2.exports = Object.fromEntries(keys.map((key) => [key, key]));
  }
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS({
  "node_modules/discord.js/src/errors/Messages.js"(exports2, module2) {
    "use strict";
    var DjsErrorCodes = require_ErrorCodes();
    var Messages = {
      [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
      [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
      [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
      [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
      [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
      [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
      [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
      [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
      [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
      [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
      [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
      [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
      [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
      [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
      [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
      [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
      [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
      [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
      [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
      [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
      [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
      [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
      [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
      [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
      [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
      [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
      [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
      [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
      [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
      [DjsErrorCodes.ColorConvert]: "Unable to convert color to a number.",
      [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
      [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
      [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
      [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
      [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
      [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
      [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
      [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
      [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
      [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
      [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
      [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
      [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
      [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
      [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
      [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
      [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
      [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
      [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
      [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
      [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
      [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
      [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
      [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
      [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
      [DjsErrorCodes.PruneDaysType]: "Days must be a number",
      [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
      [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
      [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
      [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
      [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
      [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
      [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
      [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
      [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
      [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
      [DjsErrorCodes.FetchOwnerId]: "Couldn't resolve the guild ownerId to fetch the member.",
      [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
      [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
      [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
      [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
      [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
      [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
      [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
      [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
      [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
      [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
      [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
      [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
      [DjsErrorCodes.MissingManageGuildExpressionsPermission]: (guild) => `Client must have Manage Guild Expressions permission in guild ${guild} to see emoji authors.`,
      [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
      [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
      [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
      [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
      [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
      [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
      [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
      [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
      [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
      [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable or from a guild's application command manager.",
      [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
      [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
      [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
      [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
      [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
      [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
      [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
      [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
      [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
      [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
      [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
      [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
      [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
      [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
      [DjsErrorCodes.InvalidScopesWithPermissions]: "Permissions cannot be set without the bot scope.",
      [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
      [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
      [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread"
    };
    module2.exports = Messages;
  }
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS({
  "node_modules/discord.js/src/errors/DJSError.js"(exports2, module2) {
    "use strict";
    var ErrorCodes2 = require_ErrorCodes();
    var Messages = require_Messages();
    function makeDiscordjsError(Base) {
      return class DiscordjsError2 extends Base {
        constructor(code, ...args) {
          var _a;
          super(message(code, args));
          this.code = code;
          (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, DiscordjsError2);
        }
        get name() {
          return `${super.name} [${this.code}]`;
        }
      };
    }
    function message(code, args) {
      if (!(code in ErrorCodes2))
        throw new Error("Error code must be a valid DiscordjsErrorCodes");
      const msg = Messages[code];
      if (!msg)
        throw new Error(`No message associated with error code: ${code}.`);
      if (typeof msg === "function")
        return msg(...args);
      if (!(args == null ? void 0 : args.length))
        return msg;
      args.unshift(msg);
      return String(...args);
    }
    module2.exports = {
      DiscordjsError: makeDiscordjsError(Error),
      DiscordjsTypeError: makeDiscordjsError(TypeError),
      DiscordjsRangeError: makeDiscordjsError(RangeError)
    };
  }
});

// node_modules/discord.js/src/errors/index.js
var require_errors = __commonJS({
  "node_modules/discord.js/src/errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_DJSError();
    module2.exports.ErrorCodes = require_ErrorCodes();
    module2.exports.Messages = require_Messages();
  }
});

// node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.snakecase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = snakeCase;
  }
});

// node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS({
  "node_modules/discord.js/src/util/Transformers.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist();
    var snakeCase = require_lodash();
    function toSnakeCase(obj) {
      if (typeof obj !== "object" || !obj)
        return obj;
      if (obj instanceof Date)
        return obj;
      if (isJSONEncodable(obj))
        return toSnakeCase(obj.toJSON());
      if (Array.isArray(obj))
        return obj.map(toSnakeCase);
      return Object.fromEntries(Object.entries(obj).map(([key, value]) => [snakeCase(key), toSnakeCase(value)]));
    }
    function _transformAPIAutoModerationAction(autoModerationAction) {
      return {
        type: autoModerationAction.type,
        metadata: {
          durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
          channelId: autoModerationAction.metadata.channel_id ?? null,
          customMessage: autoModerationAction.metadata.custom_message ?? null
        }
      };
    }
    module2.exports = { toSnakeCase, _transformAPIAutoModerationAction };
  }
});

// node_modules/discord.js/package.json
var require_package = __commonJS({
  "node_modules/discord.js/package.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json.schemastore.org/package.json",
      name: "discord.js",
      version: "14.14.1",
      description: "A powerful library for interacting with the Discord API",
      main: "./src/index.js",
      types: "./typings/index.d.ts",
      directories: {
        lib: "src",
        test: "test"
      },
      files: [
        "src",
        "typings"
      ],
      contributors: [
        "Crawl <icrawltogo@gmail.com>",
        "Amish Shah <amishshah.2k@gmail.com>",
        "Vlad Frangu <kingdgrizzle@gmail.com>",
        "SpaceEEC <spaceeec@yahoo.com>",
        "Aura Romn <kyradiscord@gmail.com>"
      ],
      license: "Apache-2.0",
      keywords: [
        "discord",
        "api",
        "bot",
        "client",
        "node",
        "discordapp"
      ],
      repository: {
        type: "git",
        url: "https://github.com/discordjs/discord.js.git",
        directory: "packages/discord.js"
      },
      bugs: {
        url: "https://github.com/discordjs/discord.js/issues"
      },
      homepage: "https://discord.js.org",
      dependencies: {
        "@discordjs/collection": "1.5.3",
        "@sapphire/snowflake": "3.5.1",
        "@types/ws": "8.5.9",
        "discord-api-types": "0.37.61",
        "fast-deep-equal": "3.1.3",
        "lodash.snakecase": "4.1.1",
        tslib: "2.6.2",
        undici: "5.27.2",
        ws: "8.14.2",
        "@discordjs/builders": "^1.7.0",
        "@discordjs/formatters": "^0.3.3",
        "@discordjs/util": "^1.0.2",
        "@discordjs/rest": "^2.1.0",
        "@discordjs/ws": "^1.0.2"
      },
      devDependencies: {
        "@favware/cliff-jumper": "2.2.1",
        "@types/node": "16.18.60",
        "@typescript-eslint/eslint-plugin": "^6.10.0",
        "@typescript-eslint/parser": "^6.10.0",
        "cross-env": "^7.0.3",
        dtslint: "4.2.1",
        eslint: "8.53.0",
        "eslint-formatter-pretty": "5.0.0",
        jest: "29.7.0",
        prettier: "3.0.3",
        tsd: "0.29.0",
        tslint: "6.1.3",
        turbo: "^1.10.17-canary.0",
        typescript: "5.2.2",
        "@discordjs/api-extractor": "^7.38.1",
        "@discordjs/docgen": "^0.12.1"
      },
      engines: {
        node: ">=16.11.0"
      },
      scripts: {
        test: "pnpm run docs:test && pnpm run test:typescript",
        "test:typescript": "tsc --noEmit && tsd",
        lint: "prettier --check . && tslint typings/index.d.ts && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --format=pretty src typings",
        format: "prettier --write . && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --fix --format=pretty src",
        fmt: "pnpm run format",
        docs: "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../ -o ./docs/docs.json && pnpm run docs:new",
        "docs:test": "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../",
        "docs:new": "api-extractor -d run --local",
        changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
        release: "cliff-jumper"
      }
    };
  }
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@discordjs/collection/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Collection: () => Collection2,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var _a;
    var Collection2 = (_a = class extends Map {
      /**
       * Obtains the value of the given key if it exists, otherwise sets and returns the value provided by the default value generator.
       *
       * @param key - The key to get if it exists, or set otherwise
       * @param defaultValueGenerator - A function that generates the default value
       * @example
       * ```ts
       * collection.ensure(guildId, () => defaultGuildConfig);
       * ```
       */
      ensure(key, defaultValueGenerator) {
        if (this.has(key))
          return this.get(key);
        if (typeof defaultValueGenerator !== "function")
          throw new TypeError(`${defaultValueGenerator} is not a function`);
        const defaultValue = defaultValueGenerator(key, this);
        this.set(key, defaultValue);
        return defaultValue;
      }
      /**
       * Checks if all of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if all of the elements exist, `false` if at least one does not exist.
       */
      hasAll(...keys) {
        return keys.every((key) => super.has(key));
      }
      /**
       * Checks if any of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if any of the elements exist, `false` if none exist.
       */
      hasAny(...keys) {
        return keys.some((key) => super.has(key));
      }
      first(amount) {
        if (amount === void 0)
          return this.values().next().value;
        if (amount < 0)
          return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      firstKey(amount) {
        if (amount === void 0)
          return this.keys().next().value;
        if (amount < 0)
          return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      last(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.first(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      lastKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.firstKey(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the item at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the element to obtain
       */
      at(index) {
        index = Math.floor(index);
        const arr = [...this.values()];
        return arr.at(index);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the key at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the key to obtain
       */
      keyAt(index) {
        index = Math.floor(index);
        const arr = [...this.keys()];
        return arr.at(index);
      }
      random(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      randomKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse | Array.reverse()}
       * but returns a Collection instead of an Array.
       */
      reverse() {
        const entries = [...this.entries()].reverse();
        this.clear();
        for (const [key, value] of entries)
          this.set(key, value);
        return this;
      }
      find(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      sweep(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this) {
          if (fn(val, key, this))
            this.delete(key);
        }
        return previousSize - this.size;
      }
      filter(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this) {
          if (fn(val, key, this))
            results.set(key, val);
        }
        return results;
      }
      partition(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = [
          new this.constructor[Symbol.species](),
          new this.constructor[Symbol.species]()
        ];
        for (const [key, val] of this) {
          if (fn(val, key, this)) {
            results[0].set(key, val);
          } else {
            results[1].set(key, val);
          }
        }
        return results;
      }
      flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
      }
      map(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({ length: this.size }, () => {
          const [key, value] = iter.next().value;
          return fn(value, key, this);
        });
      }
      mapValues(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
          coll.set(key, fn(val, key, this));
        return coll;
      }
      some(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return true;
        }
        return false;
      }
      every(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (!fn(val, key, this))
            return false;
        }
        return true;
      }
      /**
       * Applies a function to produce a single value. Identical in behavior to
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce | Array.reduce()}.
       *
       * @param fn - Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,
       * and `collection`
       * @param initialValue - Starting value for the accumulator
       * @example
       * ```ts
       * collection.reduce((acc, guild) => acc + guild.memberCount, 0);
       * ```
       */
      reduce(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        let accumulator;
        const iterator = this.entries();
        if (initialValue === void 0) {
          if (this.size === 0)
            throw new TypeError("Reduce of empty collection with no initial value");
          accumulator = iterator.next().value[1];
        } else {
          accumulator = initialValue;
        }
        for (const [key, value] of iterator) {
          accumulator = fn(accumulator, value, key, this);
        }
        return accumulator;
      }
      each(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, value] of this) {
          fn(value, key, this);
        }
        return this;
      }
      tap(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        fn(this);
        return this;
      }
      /**
       * Creates an identical shallow copy of this collection.
       *
       * @example
       * ```ts
       * const newColl = someColl.clone();
       * ```
       */
      clone() {
        return new this.constructor[Symbol.species](this);
      }
      /**
       * Combines this collection with others into a new collection. None of the source collections are modified.
       *
       * @param collections - Collections to merge
       * @example
       * ```ts
       * const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);
       * ```
       */
      concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections) {
          for (const [key, val] of coll)
            newColl.set(key, val);
        }
        return newColl;
      }
      /**
       * Checks if this collection shares identical items with another.
       * This is different to checking for equality using equal-signs, because
       * the collections may be different objects, but contain the same data.
       *
       * @param collection - Collection to compare with
       * @returns Whether the collections have identical contents
       */
      equals(collection) {
        if (!collection)
          return false;
        if (this === collection)
          return true;
        if (this.size !== collection.size)
          return false;
        for (const [key, value] of this) {
          if (!collection.has(key) || value !== collection.get(key)) {
            return false;
          }
        }
        return true;
      }
      /**
       * The sort method sorts the items of a collection in place and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value, according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      sort(compareFunction = _a.defaultSort) {
        const entries = [...this.entries()];
        entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
        super.clear();
        for (const [key, value] of entries) {
          super.set(key, value);
        }
        return this;
      }
      /**
       * The intersect method returns a new structure containing items where the keys and values are present in both original structures.
       *
       * @param other - The other Collection to filter against
       */
      intersect(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of other) {
          if (this.has(key) && Object.is(value, this.get(key))) {
            coll.set(key, value);
          }
        }
        return coll;
      }
      /**
       * The subtract method returns a new structure containing items where the keys and values of the original structure are not present in the other.
       *
       * @param other - The other Collection to filter against
       */
      subtract(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (!other.has(key) || !Object.is(value, other.get(key))) {
            coll.set(key, value);
          }
        }
        return coll;
      }
      /**
       * The difference method returns a new structure containing items where the key is present in one of the original structures but not the other.
       *
       * @param other - The other Collection to filter against
       */
      difference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of other) {
          if (!this.has(key))
            coll.set(key, value);
        }
        for (const [key, value] of this) {
          if (!other.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Merges two Collections together into a new Collection.
       *
       * @param other - The other Collection to merge with
       * @param whenInSelf - Function getting the result if the entry only exists in this Collection
       * @param whenInOther - Function getting the result if the entry only exists in the other Collection
       * @param whenInBoth - Function getting the result if the entry exists in both Collections
       * @example
       * ```ts
       * // Sums up the entries in two collections.
       * coll.merge(
       *  other,
       *  x => ({ keep: true, value: x }),
       *  y => ({ keep: true, value: y }),
       *  (x, y) => ({ keep: true, value: x + y }),
       * );
       * ```
       * @example
       * ```ts
       * // Intersects two collections in a left-biased manner.
       * coll.merge(
       *  other,
       *  x => ({ keep: false }),
       *  y => ({ keep: false }),
       *  (x, _) => ({ keep: true, value: x }),
       * );
       * ```
       */
      merge(other, whenInSelf, whenInOther, whenInBoth) {
        const coll = new this.constructor[Symbol.species]();
        const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
        for (const key of keys) {
          const hasInSelf = this.has(key);
          const hasInOther = other.has(key);
          if (hasInSelf && hasInOther) {
            const result = whenInBoth(this.get(key), other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInSelf) {
            const result = whenInSelf(this.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInOther) {
            const result = whenInOther(other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          }
        }
        return coll;
      }
      /**
       * The sorted method sorts the items of a collection and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value,
       * according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      sorted(compareFunction = _a.defaultSort) {
        return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
      }
      toJSON() {
        return [...this.values()];
      }
      static defaultSort(firstValue, secondValue) {
        return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
      }
      /**
       * Creates a Collection from a list of entries.
       *
       * @param entries - The list of entries
       * @param combine - Function to combine an existing entry with a new one
       * @example
       * ```ts
       * Collection.combineEntries([["a", 1], ["b", 2], ["a", 2]], (x, y) => x + y);
       * // returns Collection { "a" => 3, "b" => 2 }
       * ```
       */
      static combineEntries(entries, combine) {
        const coll = new _a();
        for (const [key, value] of entries) {
          if (coll.has(key)) {
            coll.set(key, combine(coll.get(key), value, key));
          } else {
            coll.set(key, value);
          }
        }
        return coll;
      }
    }, __name(_a, "Collection"), _a);
    var version = "1.5.3";
  }
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS({
  "node_modules/discord.js/src/util/LimitedCollection.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var LimitedCollection = class extends Collection2 {
      constructor(options = {}, iterable) {
        if (typeof options !== "object" || options === null) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        }
        const { maxSize = Infinity, keepOverLimit = null } = options;
        if (typeof maxSize !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "maxSize", "number");
        }
        if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "keepOverLimit", "function");
        }
        super(iterable);
        this.maxSize = maxSize;
        this.keepOverLimit = keepOverLimit;
      }
      set(key, value) {
        var _a, _b;
        if (this.maxSize === 0 && !((_a = this.keepOverLimit) == null ? void 0 : _a.call(this, value, key, this)))
          return this;
        if (this.size >= this.maxSize && !this.has(key)) {
          for (const [k, v] of this.entries()) {
            const keep = ((_b = this.keepOverLimit) == null ? void 0 : _b.call(this, v, k, this)) ?? false;
            if (!keep) {
              this.delete(k);
              break;
            }
          }
        }
        return super.set(key, value);
      }
      static get [Symbol.species]() {
        return Collection2;
      }
    };
    module2.exports = LimitedCollection;
  }
});

// node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS({
  "node_modules/discord.js/src/util/Options.js"(exports2, module2) {
    "use strict";
    var { DefaultRestOptions, DefaultUserAgentAppendix } = require_web();
    var { toSnakeCase } = require_Transformers();
    var { version } = require_package();
    var Options2 = class extends null {
      /**
       * The default client options.
       * @returns {ClientOptions}
       */
      static createDefault() {
        return {
          closeTimeout: 5e3,
          waitGuildTimeout: 15e3,
          shardCount: 1,
          makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
          partials: [],
          failIfNotExists: true,
          presence: {},
          sweepers: this.DefaultSweeperSettings,
          ws: {
            large_threshold: 50,
            version: 10
          },
          rest: {
            ...DefaultRestOptions,
            userAgentAppendix: this.userAgentAppendix
          },
          jsonTransformer: toSnakeCase
        };
      }
      /**
       * Create a cache factory using predefined settings to sweep or limit.
       * @param {Object<string, LimitedCollectionOptions|number>} [settings={}] Settings passed to the relevant constructor.
       * If no setting is provided for a manager, it uses Collection.
       * If a number is provided for a manager, it uses that number as the max size for a LimitedCollection.
       * If LimitedCollectionOptions are provided for a manager, it uses those settings to form a LimitedCollection.
       * @returns {CacheFactory}
       * @example
       * // Store up to 200 messages per channel and 200 members per guild, always keeping the client member.
       * Options.cacheWithLimits({
       *    MessageManager: 200,
       *    GuildMemberManager: {
       *      maxSize: 200,
       *      keepOverLimit: (member) => member.id === client.user.id,
       *    },
       *  });
       */
      static cacheWithLimits(settings2 = {}) {
        const { Collection: Collection2 } = require_dist6();
        const LimitedCollection = require_LimitedCollection();
        return (managerType, _, manager) => {
          const setting = settings2[manager.name] ?? settings2[managerType.name];
          if (setting == null) {
            return new Collection2();
          }
          if (typeof setting === "number") {
            if (setting === Infinity) {
              return new Collection2();
            }
            return new LimitedCollection({ maxSize: setting });
          }
          const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
          if (noLimit) {
            return new Collection2();
          }
          return new LimitedCollection(setting);
        };
      }
      /**
       * Create a cache factory that always caches everything.
       * @returns {CacheFactory}
       */
      static cacheEverything() {
        const { Collection: Collection2 } = require_dist6();
        return () => new Collection2();
      }
      /**
       * The default settings passed to {@link ClientOptions.makeCache}.
       * The caches that this changes are:
       * * `MessageManager` - Limit to 200 messages
       * <info>If you want to keep default behavior and add on top of it you can use this object and add on to it, e.g.
       * `makeCache: Options.cacheWithLimits({ ...Options.DefaultMakeCacheSettings, ReactionManager: 0 })`</info>
       * @type {Object<string, LimitedCollectionOptions|number>}
       */
      static get DefaultMakeCacheSettings() {
        return {
          MessageManager: 200
        };
      }
      /**
       * The default settings passed to {@link ClientOptions.sweepers}.
       * The sweepers that this changes are:
       * * `threads` - Sweep archived threads every hour, removing those archived more than 4 hours ago
       * <info>If you want to keep default behavior and add on top of it you can use this object and add on to it, e.g.
       * `sweepers: { ...Options.DefaultSweeperSettings, messages: { interval: 300, lifetime: 600 } }`</info>
       * @type {SweeperOptions}
       */
      static get DefaultSweeperSettings() {
        return {
          threads: {
            interval: 3600,
            lifetime: 14400
          }
        };
      }
    };
    /**
     * The default user agent appendix.
     * @type {string}
     * @memberof Options
     * @private
     */
    __publicField(Options2, "userAgentAppendix", `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd());
    module2.exports = Options2;
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors2 = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError
    };
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream/web
var require_web2 = __commonJS({
  "browser-external:stream/web"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream/web" has been externalized for browser compatibility. Cannot access "stream/web.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/core/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require_assert();
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require_http();
    var stream = require_stream();
    var net = require_net();
    var { InvalidArgumentError } = require_errors2();
    var { Blob: Blob2 } = require_buffer();
    var nodeUtil = require_util();
    var { stringify } = require_querystring();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(origin + path);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substr(1, idx2 - 1);
      }
      const idx = host.indexOf(":");
      if (idx === -1)
        return host;
      return host.substr(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers))
        return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1];
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require_web2().ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    var events;
    function addAbortListener(signal, listener) {
      if (typeof Symbol.dispose === "symbol") {
        if (!events) {
          events = require_events();
        }
        if (typeof events.addAbortListener === "function" && "aborted" in signal) {
          return events.addAbortListener(signal, listener);
        }
      }
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers2 = __commonJS({
  "node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// browser-external:diagnostics_channel
var require_diagnostics_channel = __commonJS({
  "browser-external:diagnostics_channel"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "diagnostics_channel" has been externalized for browser compatibility. Cannot access "diagnostics_channel.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events().EventEmitter;
    var inherits = require_node_util().inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require_node_util().inherits;
    var ReadableStream = require_node_stream().Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module2.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events().EventEmitter;
    var inherits = require_node_util().inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start;
          }
          self2.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require_node_stream().Writable;
    var inherits = require_node_util().inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this._events.preamble) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self2 = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this._events.trailer) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self2._unpause();
        };
        if (this._isPreamble && this._events.preamble) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this._events.part) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports2.toString())) {
          try {
            return textDecoders.get(exports2).decode(data);
          } catch (e) {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module2.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "",
      "%7F": "",
      "%80": "",
      "%81": "",
      "%82": "",
      "%83": "",
      "%84": "",
      "%85": "",
      "%86": "",
      "%87": "",
      "%88": "",
      "%89": "",
      "%8a": "",
      "%8A": "",
      "%8b": "",
      "%8B": "",
      "%8c": "",
      "%8C": "",
      "%8d": "",
      "%8D": "",
      "%8e": "",
      "%8E": "",
      "%8f": "",
      "%8F": "",
      "%90": "",
      "%91": "",
      "%92": "",
      "%93": "",
      "%94": "",
      "%95": "",
      "%96": "",
      "%97": "",
      "%98": "",
      "%99": "",
      "%9a": "",
      "%9A": "",
      "%9b": "",
      "%9B": "",
      "%9c": "",
      "%9C": "",
      "%9d": "",
      "%9D": "",
      "%9e": "",
      "%9E": "",
      "%9f": "",
      "%9F": "",
      "%a0": "",
      "%A0": "",
      "%a1": "",
      "%A1": "",
      "%a2": "",
      "%A2": "",
      "%a3": "",
      "%A3": "",
      "%a4": "",
      "%A4": "",
      "%a5": "",
      "%A5": "",
      "%a6": "",
      "%A6": "",
      "%a7": "",
      "%A7": "",
      "%a8": "",
      "%A8": "",
      "%a9": "",
      "%A9": "",
      "%aa": "",
      "%Aa": "",
      "%aA": "",
      "%AA": "",
      "%ab": "",
      "%Ab": "",
      "%aB": "",
      "%AB": "",
      "%ac": "",
      "%Ac": "",
      "%aC": "",
      "%AC": "",
      "%ad": "",
      "%Ad": "",
      "%aD": "",
      "%AD": "",
      "%ae": "",
      "%Ae": "",
      "%aE": "",
      "%AE": "",
      "%af": "",
      "%Af": "",
      "%aF": "",
      "%AF": "",
      "%b0": "",
      "%B0": "",
      "%b1": "",
      "%B1": "",
      "%b2": "",
      "%B2": "",
      "%b3": "",
      "%B3": "",
      "%b4": "",
      "%B4": "",
      "%b5": "",
      "%B5": "",
      "%b6": "",
      "%B6": "",
      "%b7": "",
      "%B7": "",
      "%b8": "",
      "%B8": "",
      "%b9": "",
      "%B9": "",
      "%ba": "",
      "%Ba": "",
      "%bA": "",
      "%BA": "",
      "%bb": "",
      "%Bb": "",
      "%bB": "",
      "%BB": "",
      "%bc": "",
      "%Bc": "",
      "%bC": "",
      "%BC": "",
      "%bd": "",
      "%Bd": "",
      "%bD": "",
      "%BD": "",
      "%be": "",
      "%Be": "",
      "%bE": "",
      "%BE": "",
      "%bf": "",
      "%Bf": "",
      "%bF": "",
      "%BF": "",
      "%c0": "",
      "%C0": "",
      "%c1": "",
      "%C1": "",
      "%c2": "",
      "%C2": "",
      "%c3": "",
      "%C3": "",
      "%c4": "",
      "%C4": "",
      "%c5": "",
      "%C5": "",
      "%c6": "",
      "%C6": "",
      "%c7": "",
      "%C7": "",
      "%c8": "",
      "%C8": "",
      "%c9": "",
      "%C9": "",
      "%ca": "",
      "%Ca": "",
      "%cA": "",
      "%CA": "",
      "%cb": "",
      "%Cb": "",
      "%cB": "",
      "%CB": "",
      "%cc": "",
      "%Cc": "",
      "%cC": "",
      "%CC": "",
      "%cd": "",
      "%Cd": "",
      "%cD": "",
      "%CD": "",
      "%ce": "",
      "%Ce": "",
      "%cE": "",
      "%CE": "",
      "%cf": "",
      "%Cf": "",
      "%cF": "",
      "%CF": "",
      "%d0": "",
      "%D0": "",
      "%d1": "",
      "%D1": "",
      "%d2": "",
      "%D2": "",
      "%d3": "",
      "%D3": "",
      "%d4": "",
      "%D4": "",
      "%d5": "",
      "%D5": "",
      "%d6": "",
      "%D6": "",
      "%d7": "",
      "%D7": "",
      "%d8": "",
      "%D8": "",
      "%d9": "",
      "%D9": "",
      "%da": "",
      "%Da": "",
      "%dA": "",
      "%DA": "",
      "%db": "",
      "%Db": "",
      "%dB": "",
      "%DB": "",
      "%dc": "",
      "%Dc": "",
      "%dC": "",
      "%DC": "",
      "%dd": "",
      "%Dd": "",
      "%dD": "",
      "%DD": "",
      "%de": "",
      "%De": "",
      "%dE": "",
      "%DE": "",
      "%df": "",
      "%Df": "",
      "%dF": "",
      "%DF": "",
      "%e0": "",
      "%E0": "",
      "%e1": "",
      "%E1": "",
      "%e2": "",
      "%E2": "",
      "%e3": "",
      "%E3": "",
      "%e4": "",
      "%E4": "",
      "%e5": "",
      "%E5": "",
      "%e6": "",
      "%E6": "",
      "%e7": "",
      "%E7": "",
      "%e8": "",
      "%E8": "",
      "%e9": "",
      "%E9": "",
      "%ea": "",
      "%Ea": "",
      "%eA": "",
      "%EA": "",
      "%eb": "",
      "%Eb": "",
      "%eB": "",
      "%EB": "",
      "%ec": "",
      "%Ec": "",
      "%eC": "",
      "%EC": "",
      "%ed": "",
      "%Ed": "",
      "%eD": "",
      "%ED": "",
      "%ee": "",
      "%Ee": "",
      "%eE": "",
      "%EE": "",
      "%ef": "",
      "%Ef": "",
      "%eF": "",
      "%EF": "",
      "%f0": "",
      "%F0": "",
      "%f1": "",
      "%F1": "",
      "%f2": "",
      "%F2": "",
      "%f3": "",
      "%F3": "",
      "%f4": "",
      "%F4": "",
      "%f5": "",
      "%F5": "",
      "%f6": "",
      "%F6": "",
      "%f7": "",
      "%F7": "",
      "%f8": "",
      "%F8": "",
      "%f9": "",
      "%F9": "",
      "%fa": "",
      "%Fa": "",
      "%fA": "",
      "%FA": "",
      "%fb": "",
      "%Fb": "",
      "%fB": "",
      "%FB": "",
      "%fc": "",
      "%Fc": "",
      "%fC": "",
      "%FC": "",
      "%fd": "",
      "%Fd": "",
      "%fD": "",
      "%FD": "",
      "%fe": "",
      "%Fe": "",
      "%fE": "",
      "%FE": "",
      "%ff": "",
      "%Ff": "",
      "%fF": "",
      "%FF": ""
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable } = require_node_stream();
    var { inherits } = require_node_util();
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self2.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb = self2._cb;
          self2._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (!boy._events.file) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n) {
    };
    module2.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module2.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require_node_stream().Writable;
    var { inherits } = require_node_util();
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      var _a;
      if (ev === "finish") {
        if (!this._done) {
          (_a = this._parser) == null ? void 0 : _a.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require_worker_threads();
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options == null ? void 0 : options.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// browser-external:perf_hooks
var require_perf_hooks = __commonJS({
  "browser-external:perf_hooks"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "perf_hooks" has been externalized for browser compatibility. Cannot access "perf_hooks.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util/types
var require_types = __commonJS({
  "browser-external:util/types"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util/types" has been externalized for browser compatibility. Cannot access "util/types.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require_perf_hooks();
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();
    var assert = require_assert();
    var { isUint8Array } = require_types();
    var crypto;
    try {
      crypto = require_crypto();
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      var _a, _b;
      return object instanceof Error || (((_a = object == null ? void 0 : object.constructor) == null ? void 0 : _a.name) === "Error" || ((_b = object == null ? void 0 : object.constructor) == null ? void 0 : _b.name) === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenChar(c) {
      return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
    }
    function isValidHTTPToken(characters) {
      if (!characters || typeof characters !== "string") {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        const c = characters.charCodeAt(i);
        if (c > 127 || !isTokenChar(c)) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      if (potentialValue.length === 0) {
        return false;
      }
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:")
        return true;
      if (url.protocol === "file:")
        return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null")
          return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
      const strongest = list[0].algo;
      const metadata = list.filter((item) => item.algo === strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        let expectedValue = item.hash;
        if (expectedValue.endsWith("==")) {
          expectedValue = expectedValue.slice(0, -2);
        }
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue.endsWith("==")) {
          actualValue = actualValue.slice(0, -2);
        }
        if (actualValue === expectedValue) {
          return true;
        }
        let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest("base64url");
        if (actualBase64URL.endsWith("==")) {
          actualBase64URL = actualBase64URL.slice(0, -2);
        }
        if (actualBase64URL === expectedValue) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      const supportedHashes = crypto.getHashes();
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo;
        if (supportedHashes.includes(algorithm.toLowerCase())) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require_web2().ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require_util();
    var { hasOwn, toUSVString } = require_util3();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if ((opts == null ? void 0 : opts.strict) !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return (V == null ? void 0 : V[Symbol.toStringTag]) === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        var _a;
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = (_a = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a.call(V);
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc == null ? void 0 : desc.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        const charCode = x.charCodeAt(index);
        if (charCode > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${charCode} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert = require_assert();
    var { atob: atob2 } = require_buffer();
    var { isomorphicDecode } = require_util3();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      const href = url.href;
      if (!excludeFragment) {
        return href;
      }
      const hash = href.lastIndexOf("#");
      if (hash === -1) {
        return href;
      }
      return href.slice(0, hash);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
          ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
          ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++)
          ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--)
          ;
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require_buffer();
    var { types } = require_util();
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util3();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util2();
    var encoder = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util3();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require_buffer();
    var File = NativeFile ?? UndiciFile;
    var FormData2 = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
    Object.defineProperties(FormData2.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData: FormData2 };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main();
    var util = require_util2();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util3();
    var { FormData: FormData2 } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants();
    var { Blob: Blob2, File: NativeFile } = require_buffer();
    var { kBodyUsed } = require_symbols();
    var assert = require_assert();
    var { isErrored } = require_util2();
    var { isUint8Array, isArrayBuffer } = require_types();
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require_web2().ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require_web2().ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers)
              headers[key.toLowerCase()] = value;
            const responseFormData = new FormData2();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null)
              for await (const chunk of consumeBody(this[kState].body))
                busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData2();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors2();
    var assert = require_assert();
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util2();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require_diagnostics_channel();
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class _Request {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.onError(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            this[kHandler].onRequestSent();
          } catch (err) {
            this.onError(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onData(chunk);
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        return this[kHandler].onComplete(trailers);
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0)
            continue;
          if (headers[key])
            headers[key] += `,${value}`;
          else
            headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val, skipAppend);
        else
          request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key])
                request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else
                request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend)
            request.headers[key] = processHeaderValue(key, val, skipAppend);
          else
            request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_events();
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors2();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require_net();
    var assert = require_assert();
    var util = require_util2();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors2();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require_tls();
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// browser-external:http2
var require_http2 = __commonJS({
  "browser-external:http2"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http2" has been externalized for browser compatibility. Cannot access "http2.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util2();
    var { kBodyUsed } = require_symbols();
    var assert = require_assert();
    var { InvalidArgumentError } = require_errors2();
    var EE = require_events();
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require_assert();
    var net = require_net();
    var http = require_http();
    var { pipeline } = require_stream();
    var util = require_util2();
    var timers = require_timers2();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors2();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http2;
    try {
      http2 = require_http2();
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require_diagnostics_channel();
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client2 = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants = require_constants2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        let pause;
        try {
          pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        } catch (err) {
          util.destroy(socket, err);
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        try {
          if (request.onData(buf) === false) {
            return constants.ERROR.PAUSED;
          }
        } catch (err) {
          util.destroy(socket, err);
          return -1;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          errorRequest(client, request, err);
        }
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substr(1, idx - 1);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string")
        headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else
        headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0)
            session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        if (request.onHeaders(Number(headers2[HTTP2_HEADER_STATUS]), headers2, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false)
          stream.pause();
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0)
          session.unref();
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client2;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client2 = require_client();
    var {
      InvalidArgumentError
    } = require_errors2();
    var util = require_util2();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client2(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors2();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util2();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0)
        return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors2();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client2 = require_client();
    var util = require_util2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require_assert();
    var { Readable } = require_stream();
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors2();
    var util = require_util2();
    var { ReadableStreamFrom, toUSVString } = require_util2();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    module2.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      async dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        const abortFn = () => {
          this.destroy();
        };
        let signalListenerCleanup;
        if (signal) {
          if (typeof signal !== "object" || !("aborted" in signal)) {
            throw new InvalidArgumentError("signal must be an AbortSignal");
          }
          util.throwIfAborted(signal);
          signalListenerCleanup = util.addAbortListener(signal, abortFn);
        }
        try {
          for await (const chunk of this) {
            util.throwIfAborted(signal);
            limit -= Buffer.byteLength(chunk);
            if (limit < 0) {
              return;
            }
          }
        } catch {
          util.throwIfAborted(signal);
        } finally {
          if (typeof signalListenerCleanup === "function") {
            signalListenerCleanup();
          } else if (signalListenerCleanup) {
            signalListenerCleanup[Symbol.dispose]();
          }
        }
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require_buffer().Blob;
          }
          resolve(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert = require_assert();
    var {
      ResponseStatusCodeError
    } = require_errors2();
    var { toUSVString } = require_util2();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// browser-external:async_hooks
var require_async_hooks = __commonJS({
  "browser-external:async_hooks"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "async_hooks" has been externalized for browser compatibility. Cannot access "async_hooks.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util2();
    var { RequestAbortedError } = require_errors2();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors2();
    var util = require_util2();
    var { getResolveErrorBodyCallback } = require_util4();
    var { AsyncResource } = require_async_hooks();
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require_stream();
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors2();
    var util = require_util2();
    var { getResolveErrorBodyCallback } = require_util4();
    var { AsyncResource } = require_async_hooks();
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require_stream();
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors2();
    var util = require_util2();
    var { AsyncResource } = require_async_hooks();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require_assert();
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors2();
    var { AsyncResource } = require_async_hooks();
    var util = require_util2();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require_assert();
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require_async_hooks();
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors2();
    var util = require_util2();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors2();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util2();
    var { STATUS_CODES } = require_http();
    var {
      types: {
        isPromise
      }
    } = require_util();
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors2();
    var { buildURL } = require_util2();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require_util();
    var Client2 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors2();
    var MockClient = class extends Client2 {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require_util();
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors2();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// browser-external:console
var require_console = __commonJS({
  "browser-external:console"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "console" has been externalized for browser compatibility. Cannot access "console.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require_stream();
    var { Console } = require_console();
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "" : "",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors2();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = require_url();
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors2();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        }
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host } = resolvedUrl;
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors2();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util2();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util3();
    var { webidl } = require_webidl();
    var assert = require_assert();
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function headerValueNormalize(potentialValue) {
      let i = potentialValue.length;
      while (/[\r\n\t ]/.test(potentialValue.charAt(--i)))
        ;
      return potentialValue.slice(0, i + 1).replace(/^[\r\n\t ]+/, "");
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (const header of object) {
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          headers.append(header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        for (const [key, value] of Object.entries(object)) {
          headers.append(key, value);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    var HeadersList = class _HeadersList {
      constructor(init) {
        /** @type {[string, string][]|null} */
        __publicField(this, "cookies", null);
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies;
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ?? (this.cookies = []);
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        return this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        return this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        var _a;
        if (!this.contains(name)) {
          return null;
        }
        return ((_a = this[kHeadersMap].get(name.toLowerCase())) == null ? void 0 : _a.value) ?? null;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init = void 0) {
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        return this[kHeadersList].append(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        return this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        return this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (const [name, value] of names) {
          if (name === "set-cookie") {
            for (const value2 of cookies) {
              headers.push([name, value2]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util2();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util3();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData: FormData2 } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList } = require_symbols();
    var assert = require_assert();
    var { types } = require_util();
    var ReadableStream = globalThis.ReadableStream || require_web2().ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response2 = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers();
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response2);
    Object.defineProperties(Response2.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response2, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData2
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V == null ? void 0 : V[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response: Response2,
      cloneResponse
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util2();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer
    } = require_util3();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList } = require_symbols();
    var assert = require_assert();
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require_events();
    var TransformStream = globalThis.TransformStream;
    var kInit = Symbol("init");
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        var _a, _b;
        if (input === kInit) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              var _a2;
              return (_a2 = this.baseUrl) == null ? void 0 : _a2.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window = "client";
        if (((_b = (_a = request.window) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }
        if ("window" in init) {
          window = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        if (Object.keys(init).length > 0) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity !== void 0 && init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(init.method)) {
            throw TypeError(`'${init.method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw TypeError(`'${init.method}' HTTP method is unsupported.`);
          }
          method = normalizeMethod(init.method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers();
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (Object.keys(init).length !== 0) {
          let headers = new Headers(this[kHeaders]);
          if (init.headers !== void 0) {
            headers = init.headers;
          }
          this[kHeaders][kHeadersList].clear();
          if (headers.constructor.name === "Headers") {
            for (const [key, val] of headers) {
              this[kHeaders].append(key, val);
            }
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require_web2().TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        var _a;
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || ((_a = this.body) == null ? void 0 : _a.locked)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kInit);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers();
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response: Response2,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = require_zlib();
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util3();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = require_assert();
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants();
    var { kHeadersList } = require_symbols();
    var EE = require_events();
    var { Readable, pipeline } = require_stream();
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util2();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require_web2();
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require_http();
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        (_a = this.connection) == null ? void 0 : _a.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        (_a = this.connection) == null ? void 0 : _a.destroy(error);
        this.emit("terminated", error);
      }
    };
    function fetch2(input, init = {}) {
      var _a;
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (((_a = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a.name) === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response2();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      var _a;
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!((_a = response.urlList) == null ? void 0 : _a.length)) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!timingInfo.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      var _a, _b;
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable((_a = request.body) == null ? void 0 : _a.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable((_b = response.body) == null ? void 0 : _b.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      var _a, _b, _c, _d;
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = ((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) == null ? void 0 : _c.name) === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = (_d = request.client) == null ? void 0 : _d.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require_buffer().resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          var _a;
          if (!this.destroyed) {
            this.destroyed = true;
            (_a = this.abort) == null ? void 0 : _a.call(this, err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          var _a;
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          (_a = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a.call(fetchParams, bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require_web2().ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += (bytes == null ? void 0 : bytes.byteLength) ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers.append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers.append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              var _a;
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              (_a = this.body) == null ? void 0 : _a.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers.append(key, val);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch: fetch2,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// browser-external:string_decoder
var require_string_decoder = __commonJS({
  "browser-external:string_decoder"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "string_decoder" has been externalized for browser compatibility. Cannot access "string_decoder.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require_util();
    var { StringDecoder } = require_string_decoder();
    var { btoa } = require_buffer();
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util5();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require_assert();
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util3();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util6();
    var { kEnumerableProperty, isDisturbed } = require_util2();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response: Response2, cloneResponse } = require_response();
    var { Request } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util3();
    var assert = require_assert();
    var { getGlobalDispatcher } = require_global2();
    var _relevantRequestResponseList, _batchCacheOperations, batchCacheOperations_fn, _queryCache, queryCache_fn, _requestMatchesCachedItem, requestMatchesCachedItem_fn;
    var _Cache = class _Cache {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
         * @param {CacheBatchOperation[]} operations
         * @returns {requestResponseList}
         */
        __privateAdd(this, _batchCacheOperations);
        /**
         * @see https://w3c.github.io/ServiceWorker/#query-cache
         * @param {any} requestQuery
         * @param {import('../../types/cache').CacheQueryOptions} options
         * @param {requestResponseList} targetStorage
         * @returns {requestResponseList}
         */
        __privateAdd(this, _queryCache);
        /**
         * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
         * @param {any} requestQuery
         * @param {any} request
         * @param {any | null} response
         * @param {import('../../types/cache').CacheQueryOptions | undefined} options
         * @returns {boolean}
         */
        __privateAdd(this, _requestMatchesCachedItem);
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
         * @type {requestResponseList}
         */
        __privateAdd(this, _relevantRequestResponseList, void 0);
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        var _a;
        webidl.brandCheck(this, _Cache);
        if (request !== void 0)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response2(((_a = response.body) == null ? void 0 : _a.source) ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = __privateMethod(this, _batchCacheOperations, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!(requestResponses == null ? void 0 : requestResponses.length));
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
    };
    _relevantRequestResponseList = new WeakMap();
    _batchCacheOperations = new WeakSet();
    batchCacheOperations_fn = function(operations) {
      const cache = __privateGet(this, _relevantRequestResponseList);
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (__privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = __privateMethod(this, _queryCache, queryCache_fn).call(this, operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        __privateGet(this, _relevantRequestResponseList).length = 0;
        __privateSet(this, _relevantRequestResponseList, backupCache);
        throw e;
      }
    };
    _queryCache = new WeakSet();
    queryCache_fn = function(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? __privateGet(this, _relevantRequestResponseList);
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (__privateMethod(this, _requestMatchesCachedItem, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    };
    _requestMatchesCachedItem = new WeakSet();
    requestMatchesCachedItem_fn = function(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options == null ? void 0 : options.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || (options == null ? void 0 : options.ignoreVary) || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    };
    var Cache = _Cache;
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response2);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var _caches;
    var _CacheStorage = class _CacheStorage {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
         * @type {Map<string, import('./cache').requestResponseList}
         */
        __privateAdd(this, _caches, /* @__PURE__ */ new Map());
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            const cacheList = __privateGet(this, _caches).get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of __privateGet(this, _caches).values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (__privateGet(this, _caches).has(cacheName)) {
          const cache2 = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        __privateGet(this, _caches).set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = __privateGet(this, _caches).keys();
        return [...keys];
      }
    };
    _caches = new WeakMap();
    var CacheStorage = _CacheStorage;
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    var assert = require_assert();
    var { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }
      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === "headers list"
        );
        assert(kHeadersListNode, "Headers cannot be parsed");
      }
      const headersList = headers[kHeadersListNode];
      assert(headersList);
      return headersList;
    }
    module2.exports = {
      isCTLExcludingHtab,
      stringify,
      getHeadersList
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
    var { isCTLExcludingHtab } = require_util7();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require_assert();
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ?? (cookieAttributeList.unparsed = []);
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify, getHeadersList } = require_util7();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = getHeadersList(headers).cookies;
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events2 = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util2();
    var { MessagePort } = require_worker_threads();
    var _eventInit;
    var _MessageEvent = class _MessageEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit, void 0);
        __privateSet(this, _eventInit, eventInitDict);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
          Object.freeze(__privateGet(this, _eventInit).ports);
        }
        return __privateGet(this, _eventInit).ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    _eventInit = new WeakMap();
    var MessageEvent = _MessageEvent;
    var _eventInit2;
    var _CloseEvent = class _CloseEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit2, void 0);
        __privateSet(this, _eventInit2, eventInitDict);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).reason;
      }
    };
    _eventInit2 = new WeakMap();
    var CloseEvent = _CloseEvent;
    var _eventInit3;
    var _ErrorEvent = class _ErrorEvent extends Event {
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        __privateAdd(this, _eventInit3, void 0);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        __privateSet(this, _eventInit3, eventInitDict);
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).error;
      }
    };
    _eventInit3 = new WeakMap();
    var ErrorEvent = _ErrorEvent;
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util8 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants4();
    var { MessageEvent, ErrorEvent } = require_events2();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if ((response == null ? void 0 : response.socket) && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require_diagnostics_channel();
    var { uid, states } = require_constants4();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util8();
    var { CloseEvent } = require_events2();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto;
    try {
      crypto = require_crypto();
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          var _a, _b;
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (((_a = response.headersList.get("Upgrade")) == null ? void 0 : _a.toLowerCase()) !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (((_b = response.headersList.get("Connection")) == null ? void 0 : _b.toLowerCase()) !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants4();
    var crypto;
    try {
      crypto = require_crypto();
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto.randomBytes(4);
      }
      createFrame(opcode) {
        var _a;
        const bodyLength = ((_a = this.frameData) == null ? void 0 : _a.byteLength) ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_stream();
    var diagnosticsChannel = require_diagnostics_channel();
    var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util8();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var _buffers, _byteOffset, _state, _info, _fragments;
    var ByteParser = class extends Writable {
      constructor(ws) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        __privateGet(this, _buffers).push(chunk);
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        var _a;
        while (true) {
          if (__privateGet(this, _state) === parserStates.INFO) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).fin = (buffer[0] & 128) !== 0;
            __privateGet(this, _info).opcode = buffer[0] & 15;
            (_a = __privateGet(this, _info)).originalOpcode ?? (_a.originalOpcode = __privateGet(this, _info).opcode);
            __privateGet(this, _info).fragmented = !__privateGet(this, _info).fin && __privateGet(this, _info).opcode !== opcodes.CONTINUATION;
            if (__privateGet(this, _info).fragmented && __privateGet(this, _info).opcode !== opcodes.BINARY && __privateGet(this, _info).opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              __privateGet(this, _info).payloadLength = payloadLength;
              __privateSet(this, _state, parserStates.READ_DATA);
            } else if (payloadLength === 126) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_16);
            } else if (payloadLength === 127) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_64);
            }
            if (__privateGet(this, _info).fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((__privateGet(this, _info).opcode === opcodes.PING || __privateGet(this, _info).opcode === opcodes.PONG || __privateGet(this, _info).opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              __privateGet(this, _info).closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              __privateSet(this, _state, parserStates.INFO);
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (__privateGet(this, _info).opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
            if (__privateGet(this, _byteOffset) < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            __privateGet(this, _info).payloadLength = (upper << 8) + lower;
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
            if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
              return callback();
            } else if (__privateGet(this, _byteOffset) >= __privateGet(this, _info).payloadLength) {
              const body = this.consume(__privateGet(this, _info).payloadLength);
              __privateGet(this, _fragments).push(body);
              if (!__privateGet(this, _info).fragmented || __privateGet(this, _info).fin && __privateGet(this, _info).opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                websocketMessageReceived(this.ws, __privateGet(this, _info).originalOpcode, fullMessage);
                __privateSet(this, _info, {});
                __privateGet(this, _fragments).length = 0;
              }
              __privateSet(this, _state, parserStates.INFO);
            }
          }
          if (__privateGet(this, _byteOffset) > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (__privateGet(this, _buffers)[0].length === n) {
          __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
          return __privateGet(this, _buffers).shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += next.length;
          }
        }
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
    _buffers = new WeakMap();
    _byteOffset = new WeakMap();
    _state = new WeakMap();
    _info = new WeakMap();
    _fragments = new WeakMap();
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util8();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util2();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require_util();
    var experimentalWarned = false;
    var _events, _bufferedAmount, _protocol, _extensions, _onConnectionEstablished, onConnectionEstablished_fn;
    var _WebSocket = class _WebSocket extends EventTarget {
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        /**
         * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
         */
        __privateAdd(this, _onConnectionEstablished);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, "");
        __privateAdd(this, _extensions, "");
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => __privateMethod(this, _onConnectionEstablished, onConnectionEstablished_fn).call(this, response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + ab.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - ab.byteLength);
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
            socket.write(buffer, () => {
              __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _bufferedAmount);
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _extensions);
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _protocol);
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).open) {
          this.removeEventListener("open", __privateGet(this, _events).open);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).open = fn;
          this.addEventListener("open", fn);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).error) {
          this.removeEventListener("error", __privateGet(this, _events).error);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).error = fn;
          this.addEventListener("error", fn);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).close) {
          this.removeEventListener("close", __privateGet(this, _events).close);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).close = fn;
          this.addEventListener("close", fn);
        } else {
          __privateGet(this, _events).close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).message) {
          this.removeEventListener("message", __privateGet(this, _events).message);
        }
        if (typeof fn === "function") {
          __privateGet(this, _events).message = fn;
          this.addEventListener("message", fn);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
    };
    _events = new WeakMap();
    _bufferedAmount = new WeakMap();
    _protocol = new WeakMap();
    _extensions = new WeakMap();
    _onConnectionEstablished = new WeakSet();
    onConnectionEstablished_fn = function(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        __privateSet(this, _extensions, extensions);
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        __privateSet(this, _protocol, protocol);
      }
      fireEvent("open", this);
    };
    var WebSocket = _WebSocket;
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client2 = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors2();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util2();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require_crypto();
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client2;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch2(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS({
  "node_modules/discord.js/src/util/Colors.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Default: 0,
      White: 16777215,
      Aqua: 1752220,
      Green: 5763719,
      Blue: 3447003,
      Yellow: 16705372,
      Purple: 10181046,
      LuminousVividPink: 15277667,
      Fuchsia: 15418782,
      Gold: 15844367,
      Orange: 15105570,
      Red: 15548997,
      Grey: 9807270,
      Navy: 3426654,
      DarkAqua: 1146986,
      DarkGreen: 2067276,
      DarkBlue: 2123412,
      DarkPurple: 7419530,
      DarkVividPink: 11342935,
      DarkGold: 12745742,
      DarkOrange: 11027200,
      DarkRed: 10038562,
      DarkGrey: 9936031,
      DarkerGrey: 8359053,
      LightGrey: 12370112,
      DarkNavy: 2899536,
      Blurple: 5793266,
      Greyple: 10070709,
      DarkButNotBlack: 2895667,
      NotQuiteBlack: 2303786
    };
  }
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS({
  "node_modules/discord.js/src/util/BitField.js"(exports2, module2) {
    "use strict";
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var _BitField = class _BitField {
      /**
       * @param {BitFieldResolvable} [bits=this.constructor.DefaultBit] Bit(s) to read from
       */
      constructor(bits = this.constructor.DefaultBit) {
        this.bitfield = this.constructor.resolve(bits);
      }
      /**
       * Checks whether the bitfield has a bit, or any of multiple bits.
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      any(bit) {
        return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
      }
      /**
       * Checks if this bitfield equals another
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      equals(bit) {
        return this.bitfield === this.constructor.resolve(bit);
      }
      /**
       * Checks whether the bitfield has a bit, or multiple bits.
       * @param {BitFieldResolvable} bit Bit(s) to check for
       * @returns {boolean}
       */
      has(bit) {
        bit = this.constructor.resolve(bit);
        return (this.bitfield & bit) === bit;
      }
      /**
       * Gets all given bits that are missing from the bitfield.
       * @param {BitFieldResolvable} bits Bit(s) to check for
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {string[]}
       */
      missing(bits, ...hasParams) {
        return new this.constructor(bits).remove(this).toArray(...hasParams);
      }
      /**
       * Freezes these bits, making them immutable.
       * @returns {Readonly<BitField>}
       */
      freeze() {
        return Object.freeze(this);
      }
      /**
       * Adds bits to these ones.
       * @param {...BitFieldResolvable} [bits] Bits to add
       * @returns {BitField} These bits or new BitField if the instance is frozen.
       */
      add(...bits) {
        let total = this.constructor.DefaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this))
          return new this.constructor(this.bitfield | total);
        this.bitfield |= total;
        return this;
      }
      /**
       * Removes bits from these.
       * @param {...BitFieldResolvable} [bits] Bits to remove
       * @returns {BitField} These bits or new BitField if the instance is frozen.
       */
      remove(...bits) {
        let total = this.constructor.DefaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this))
          return new this.constructor(this.bitfield & ~total);
        this.bitfield &= ~total;
        return this;
      }
      /**
       * Gets an object mapping field names to a {@link boolean} indicating whether the
       * bit is available.
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {Object}
       */
      serialize(...hasParams) {
        const serialized = {};
        for (const [flag, bit] of Object.entries(this.constructor.Flags)) {
          if (isNaN(flag))
            serialized[flag] = this.has(bit, ...hasParams);
        }
        return serialized;
      }
      /**
       * Gets an {@link Array} of bitfield names based on the bits available.
       * @param {...*} hasParams Additional parameters for the has method, if any
       * @returns {string[]}
       */
      toArray(...hasParams) {
        return [...this[Symbol.iterator](...hasParams)];
      }
      toJSON() {
        return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
      }
      valueOf() {
        return this.bitfield;
      }
      *[Symbol.iterator](...hasParams) {
        for (const bitName of Object.keys(this.constructor.Flags)) {
          if (isNaN(bitName) && this.has(bitName, ...hasParams))
            yield bitName;
        }
      }
      /**
       * Data that can be resolved to give a bitfield. This can be:
       * * A bit number (this can be a number literal or a value taken from {@link BitField.Flags})
       * * A string bit number
       * * An instance of BitField
       * * An Array of BitFieldResolvable
       * @typedef {number|string|bigint|BitField|BitFieldResolvable[]} BitFieldResolvable
       */
      /**
       * Resolves bitfields to their numeric form.
       * @param {BitFieldResolvable} [bit] bit(s) to resolve
       * @returns {number|bigint}
       */
      static resolve(bit) {
        const { DefaultBit } = this;
        if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
          return bit;
        if (bit instanceof _BitField)
          return bit.bitfield;
        if (Array.isArray(bit)) {
          return bit.map((bit_) => this.resolve(bit_)).reduce((prev, bit_) => prev | bit_, DefaultBit);
        }
        if (typeof bit === "string") {
          if (!isNaN(bit))
            return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
          if (this.Flags[bit] !== void 0)
            return this.Flags[bit];
        }
        throw new DiscordjsRangeError2(ErrorCodes2.BitFieldInvalid, bit);
      }
    };
    /**
     * Numeric bitfield flags.
     * <info>Defined in extension classes</info>
     * @type {Object}
     * @memberof BitField
     * @abstract
     */
    __publicField(_BitField, "Flags", {});
    /**
     * @type {number|bigint}
     * @memberof BitField
     * @private
     */
    __publicField(_BitField, "DefaultBit", 0);
    var BitField = _BitField;
    module2.exports = BitField;
  }
});

// node_modules/discord.js/src/util/AttachmentFlagsBitField.js
var require_AttachmentFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/AttachmentFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { AttachmentFlags } = require_v106();
    var BitField = require_BitField();
    var AttachmentFlagsBitField = class extends BitField {
    };
    /**
     * Numeric attachment flags.
     * @type {AttachmentFlags}
     * @memberof AttachmentFlagsBitField
     */
    __publicField(AttachmentFlagsBitField, "Flags", AttachmentFlags);
    module2.exports = AttachmentFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS({
  "node_modules/discord.js/src/structures/Attachment.js"(exports2, module2) {
    "use strict";
    var AttachmentFlagsBitField = require_AttachmentFlagsBitField();
    var { basename, flatten } = require_Util();
    var Attachment = class {
      constructor(data) {
        this.attachment = data.url;
        this.name = data.filename;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("size" in data) {
          this.size = data.size;
        }
        if ("url" in data) {
          this.url = data.url;
        }
        if ("proxy_url" in data) {
          this.proxyURL = data.proxy_url;
        }
        if ("height" in data) {
          this.height = data.height;
        } else {
          this.height ?? (this.height = null);
        }
        if ("width" in data) {
          this.width = data.width;
        } else {
          this.width ?? (this.width = null);
        }
        if ("content_type" in data) {
          this.contentType = data.content_type;
        } else {
          this.contentType ?? (this.contentType = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        this.ephemeral = data.ephemeral ?? false;
        if ("duration_secs" in data) {
          this.duration = data.duration_secs;
        } else {
          this.duration ?? (this.duration = null);
        }
        if ("waveform" in data) {
          this.waveform = data.waveform;
        } else {
          this.waveform ?? (this.waveform = null);
        }
        if ("flags" in data) {
          this.flags = new AttachmentFlagsBitField(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new AttachmentFlagsBitField().freeze());
        }
      }
      /**
       * Whether or not this attachment has been marked as a spoiler
       * @type {boolean}
       * @readonly
       */
      get spoiler() {
        return basename(this.url ?? this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = Attachment;
  }
});

// node_modules/@discordjs/formatters/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@discordjs/formatters/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Faces: () => Faces,
      GuildNavigationMentions: () => GuildNavigationMentions,
      HeadingLevel: () => HeadingLevel,
      TimestampStyles: () => TimestampStyles,
      blockQuote: () => blockQuote,
      bold: () => bold,
      channelLink: () => channelLink,
      channelMention: () => channelMention,
      chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
      codeBlock: () => codeBlock,
      escapeBold: () => escapeBold,
      escapeBulletedList: () => escapeBulletedList,
      escapeCodeBlock: () => escapeCodeBlock,
      escapeEscape: () => escapeEscape,
      escapeHeading: () => escapeHeading,
      escapeInlineCode: () => escapeInlineCode,
      escapeItalic: () => escapeItalic,
      escapeMarkdown: () => escapeMarkdown,
      escapeMaskedLink: () => escapeMaskedLink,
      escapeNumberedList: () => escapeNumberedList,
      escapeSpoiler: () => escapeSpoiler,
      escapeStrikethrough: () => escapeStrikethrough,
      escapeUnderline: () => escapeUnderline,
      formatEmoji: () => formatEmoji,
      heading: () => heading,
      hideLinkEmbed: () => hideLinkEmbed,
      hyperlink: () => hyperlink,
      inlineCode: () => inlineCode,
      italic: () => italic,
      messageLink: () => messageLink,
      orderedList: () => orderedList,
      quote: () => quote,
      roleMention: () => roleMention,
      spoiler: () => spoiler,
      strikethrough: () => strikethrough,
      time: () => time,
      underscore: () => underscore,
      unorderedList: () => unorderedList,
      userMention: () => userMention
    });
    module2.exports = __toCommonJS2(src_exports);
    function escapeMarkdown(text, options = {}) {
      const {
        codeBlock: codeBlock2 = true,
        inlineCode: inlineCode2 = true,
        bold: bold2 = true,
        italic: italic2 = true,
        underline = true,
        strikethrough: strikethrough2 = true,
        spoiler: spoiler2 = true,
        codeBlockContent = true,
        inlineCodeContent = true,
        escape = true,
        heading: heading2 = false,
        bulletedList = false,
        numberedList = false,
        maskedLink = false
      } = options;
      if (!codeBlockContent) {
        return text.split("```").map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return escapeMarkdown(subString, {
            inlineCode: inlineCode2,
            bold: bold2,
            italic: italic2,
            underline,
            strikethrough: strikethrough2,
            spoiler: spoiler2,
            inlineCodeContent,
            escape,
            heading: heading2,
            bulletedList,
            numberedList,
            maskedLink
          });
        }).join(codeBlock2 ? "\\`\\`\\`" : "```");
      }
      if (!inlineCodeContent) {
        return text.split(new RegExp("(?<=^|[^`])`(?=[^`]|$)", "g")).map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return escapeMarkdown(subString, {
            codeBlock: codeBlock2,
            bold: bold2,
            italic: italic2,
            underline,
            strikethrough: strikethrough2,
            spoiler: spoiler2,
            escape,
            heading: heading2,
            bulletedList,
            numberedList,
            maskedLink
          });
        }).join(inlineCode2 ? "\\`" : "`");
      }
      let res = text;
      if (escape)
        res = escapeEscape(res);
      if (inlineCode2)
        res = escapeInlineCode(res);
      if (codeBlock2)
        res = escapeCodeBlock(res);
      if (italic2)
        res = escapeItalic(res);
      if (bold2)
        res = escapeBold(res);
      if (underline)
        res = escapeUnderline(res);
      if (strikethrough2)
        res = escapeStrikethrough(res);
      if (spoiler2)
        res = escapeSpoiler(res);
      if (heading2)
        res = escapeHeading(res);
      if (bulletedList)
        res = escapeBulletedList(res);
      if (numberedList)
        res = escapeNumberedList(res);
      if (maskedLink)
        res = escapeMaskedLink(res);
      return res;
    }
    __name(escapeMarkdown, "escapeMarkdown");
    function escapeCodeBlock(text) {
      return text.replaceAll("```", "\\`\\`\\`");
    }
    __name(escapeCodeBlock, "escapeCodeBlock");
    function escapeInlineCode(text) {
      return text.replaceAll(new RegExp("(?<=^|[^`])``?(?=[^`]|$)", "g"), (match) => match.length === 2 ? "\\`\\`" : "\\`");
    }
    __name(escapeInlineCode, "escapeInlineCode");
    function escapeItalic(text) {
      let idx = 0;
      const newText = text.replaceAll(new RegExp("(?<=^|[^*])\\*([^*]|\\*\\*|$)", "g"), (_, match) => {
        if (match === "**")
          return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
        return `\\*${match}`;
      });
      idx = 0;
      return newText.replaceAll(new RegExp("(?<=^|[^_])(?<!<a?:.+)_(?!:\\d+>)([^_]|__|$)", "g"), (_, match) => {
        if (match === "__")
          return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
        return `\\_${match}`;
      });
    }
    __name(escapeItalic, "escapeItalic");
    function escapeBold(text) {
      let idx = 0;
      return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
        if (match)
          return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
        return "\\*\\*";
      });
    }
    __name(escapeBold, "escapeBold");
    function escapeUnderline(text) {
      let idx = 0;
      return text.replaceAll(new RegExp("(?<!<a?:.+)__(_)?(?!:\\d+>)", "g"), (_, match) => {
        if (match)
          return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
        return "\\_\\_";
      });
    }
    __name(escapeUnderline, "escapeUnderline");
    function escapeStrikethrough(text) {
      return text.replaceAll("~~", "\\~\\~");
    }
    __name(escapeStrikethrough, "escapeStrikethrough");
    function escapeSpoiler(text) {
      return text.replaceAll("||", "\\|\\|");
    }
    __name(escapeSpoiler, "escapeSpoiler");
    function escapeEscape(text) {
      return text.replaceAll("\\", "\\\\");
    }
    __name(escapeEscape, "escapeEscape");
    function escapeHeading(text) {
      return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
    }
    __name(escapeHeading, "escapeHeading");
    function escapeBulletedList(text) {
      return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
    }
    __name(escapeBulletedList, "escapeBulletedList");
    function escapeNumberedList(text) {
      return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
    }
    __name(escapeNumberedList, "escapeNumberedList");
    function escapeMaskedLink(text) {
      return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
    }
    __name(escapeMaskedLink, "escapeMaskedLink");
    function codeBlock(language, content) {
      return content === void 0 ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
    }
    __name(codeBlock, "codeBlock");
    function inlineCode(content) {
      return `\`${content}\``;
    }
    __name(inlineCode, "inlineCode");
    function italic(content) {
      return `_${content}_`;
    }
    __name(italic, "italic");
    function bold(content) {
      return `**${content}**`;
    }
    __name(bold, "bold");
    function underscore(content) {
      return `__${content}__`;
    }
    __name(underscore, "underscore");
    function strikethrough(content) {
      return `~~${content}~~`;
    }
    __name(strikethrough, "strikethrough");
    function quote(content) {
      return `> ${content}`;
    }
    __name(quote, "quote");
    function blockQuote(content) {
      return `>>> ${content}`;
    }
    __name(blockQuote, "blockQuote");
    function hideLinkEmbed(url) {
      return `<${url}>`;
    }
    __name(hideLinkEmbed, "hideLinkEmbed");
    function hyperlink(content, url, title) {
      return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
    }
    __name(hyperlink, "hyperlink");
    function spoiler(content) {
      return `||${content}||`;
    }
    __name(spoiler, "spoiler");
    function userMention(userId) {
      return `<@${userId}>`;
    }
    __name(userMention, "userMention");
    function channelMention(channelId) {
      return `<#${channelId}>`;
    }
    __name(channelMention, "channelMention");
    function roleMention(roleId) {
      return `<@&${roleId}>`;
    }
    __name(roleMention, "roleMention");
    function chatInputApplicationCommandMention(commandName, subcommandGroupName, subcommandName, commandId) {
      if (commandId !== void 0) {
        return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
      }
      if (subcommandName !== void 0) {
        return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
      }
      return `</${commandName}:${subcommandGroupName}>`;
    }
    __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
    function formatEmoji(emojiId, animated = false) {
      return `<${animated ? "a" : ""}:_:${emojiId}>`;
    }
    __name(formatEmoji, "formatEmoji");
    function channelLink(channelId, guildId) {
      return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
    }
    __name(channelLink, "channelLink");
    function messageLink(channelId, messageId, guildId) {
      return `${guildId === void 0 ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
    }
    __name(messageLink, "messageLink");
    var HeadingLevel = ((HeadingLevel2) => {
      HeadingLevel2[HeadingLevel2["One"] = 1] = "One";
      HeadingLevel2[HeadingLevel2["Two"] = 2] = "Two";
      HeadingLevel2[HeadingLevel2["Three"] = 3] = "Three";
      return HeadingLevel2;
    })(HeadingLevel || {});
    function heading(content, level) {
      switch (level) {
        case 3:
          return `### ${content}`;
        case 2:
          return `## ${content}`;
        default:
          return `# ${content}`;
      }
    }
    __name(heading, "heading");
    function listCallback(element, startNumber, depth = 0) {
      if (Array.isArray(element)) {
        return element.map((element2) => listCallback(element2, startNumber, depth + 1)).join("\n");
      }
      return `${"  ".repeat(depth - 1)}${startNumber ? `${startNumber}.` : "-"} ${element}`;
    }
    __name(listCallback, "listCallback");
    function orderedList(list, startNumber = 1) {
      return listCallback(list, Math.max(startNumber, 1));
    }
    __name(orderedList, "orderedList");
    function unorderedList(list) {
      return listCallback(list);
    }
    __name(unorderedList, "unorderedList");
    function time(timeOrSeconds, style) {
      if (typeof timeOrSeconds !== "number") {
        timeOrSeconds = Math.floor(((timeOrSeconds == null ? void 0 : timeOrSeconds.getTime()) ?? Date.now()) / 1e3);
      }
      return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
    }
    __name(time, "time");
    var TimestampStyles = {
      /**
       * Short time format, consisting of hours and minutes.
       *
       * @example `16:20`
       */
      ShortTime: "t",
      /**
       * Long time format, consisting of hours, minutes, and seconds.
       *
       * @example `16:20:30`
       */
      LongTime: "T",
      /**
       * Short date format, consisting of day, month, and year.
       *
       * @example `20/04/2021`
       */
      ShortDate: "d",
      /**
       * Long date format, consisting of day, month, and year.
       *
       * @example `20 April 2021`
       */
      LongDate: "D",
      /**
       * Short date-time format, consisting of short date and short time formats.
       *
       * @example `20 April 2021 16:20`
       */
      ShortDateTime: "f",
      /**
       * Long date-time format, consisting of long date and short time formats.
       *
       * @example `Tuesday, 20 April 2021 16:20`
       */
      LongDateTime: "F",
      /**
       * Relative time format, consisting of a relative duration format.
       *
       * @example `2 months ago`
       */
      RelativeTime: "R"
    };
    var Faces = ((Faces2) => {
      Faces2["Shrug"] = "_()_/";
      Faces2["Tableflip"] = "() ";
      Faces2["Unflip"] = "(  _ )";
      return Faces2;
    })(Faces || {});
    var GuildNavigationMentions = ((GuildNavigationMentions2) => {
      GuildNavigationMentions2["Browse"] = "<id:browse>";
      GuildNavigationMentions2["Customize"] = "<id:customize>";
      GuildNavigationMentions2["Guide"] = "<id:guide>";
      return GuildNavigationMentions2;
    })(GuildNavigationMentions || {});
  }
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS({
  "node_modules/discord.js/src/structures/Base.js"(exports2, module2) {
    "use strict";
    var { flatten } = require_Util();
    var Base = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
      _patch(data) {
        return data;
      }
      _update(data) {
        const clone = this._clone();
        this._patch(data);
        return clone;
      }
      toJSON(...props) {
        return flatten(this, ...props);
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = Base;
  }
});

// node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ChannelFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ChannelFlags } = require_v106();
    var BitField = require_BitField();
    var ChannelFlagsBitField = class extends BitField {
    };
    /**
     * Numeric guild channel flags.
     * @type {ChannelFlags}
     * @memberof ChannelFlagsBitField
     */
    __publicField(ChannelFlagsBitField, "Flags", ChannelFlags);
    module2.exports = ChannelFlagsBitField;
  }
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS({
  "node_modules/discord.js/src/util/Constants.js"(exports2) {
    "use strict";
    var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
    exports2.MaxBulkDeletableMessageAge = 12096e5;
    exports2.SweeperKeys = [
      "autoModerationRules",
      "applicationCommands",
      "bans",
      "emojis",
      "invites",
      "guildMembers",
      "messages",
      "presences",
      "reactions",
      "stageInstances",
      "stickers",
      "threadMembers",
      "threads",
      "users",
      "voiceStates"
    ];
    exports2.NonSystemMessageTypes = [
      MessageType.Default,
      MessageType.Reply,
      MessageType.ChatInputCommand,
      MessageType.ContextMenuCommand
    ];
    exports2.GuildTextBasedChannelTypes = [
      ChannelType.GuildText,
      ChannelType.GuildAnnouncement,
      ChannelType.AnnouncementThread,
      ChannelType.PublicThread,
      ChannelType.PrivateThread,
      ChannelType.GuildVoice,
      ChannelType.GuildStageVoice
    ];
    exports2.TextBasedChannelTypes = [...exports2.GuildTextBasedChannelTypes, ChannelType.DM];
    exports2.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
    exports2.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
    exports2.SelectMenuTypes = [
      ComponentType.StringSelect,
      ComponentType.UserSelect,
      ComponentType.RoleSelect,
      ComponentType.MentionableSelect,
      ComponentType.ChannelSelect
    ];
    exports2.DeletableMessageTypes = [
      MessageType.AutoModerationAction,
      MessageType.ChannelFollowAdd,
      MessageType.ChannelPinnedMessage,
      MessageType.ChatInputCommand,
      MessageType.ContextMenuCommand,
      MessageType.Default,
      MessageType.GuildBoost,
      MessageType.GuildBoostTier1,
      MessageType.GuildBoostTier2,
      MessageType.GuildBoostTier3,
      MessageType.GuildInviteReminder,
      MessageType.InteractionPremiumUpsell,
      MessageType.Reply,
      MessageType.RoleSubscriptionPurchase,
      MessageType.StageEnd,
      MessageType.StageRaiseHand,
      MessageType.StageSpeaker,
      MessageType.StageStart,
      MessageType.StageTopic,
      MessageType.ThreadCreated,
      MessageType.UserJoin
    ];
    exports2.StickerFormatExtensionMap = {
      [StickerFormatType.PNG]: ImageFormat.PNG,
      [StickerFormatType.APNG]: ImageFormat.PNG,
      [StickerFormatType.Lottie]: ImageFormat.Lottie,
      [StickerFormatType.GIF]: ImageFormat.GIF
    };
  }
});

// node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS({
  "node_modules/discord.js/src/structures/BaseChannel.js"(exports2) {
    "use strict";
    var { channelLink, channelMention } = require_dist7();
    var { DiscordSnowflake } = require_dist3();
    var { ChannelType, Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var { ThreadChannelTypes } = require_Constants();
    var BaseChannel = class extends Base {
      constructor(client, data, immediatePatch = true) {
        super(client);
        this.type = data.type;
        if (data && immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        if ("flags" in data) {
          this.flags = new ChannelFlagsBitField(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new ChannelFlagsBitField().freeze());
        }
        this.id = data.id;
      }
      /**
       * The timestamp the channel was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the channel was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL to the channel
       * @type {string}
       * @readonly
       */
      get url() {
        return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
      }
      /**
       * Whether this Channel is a partial
       * <info>This is always false outside of DM channels.</info>
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return false;
      }
      /**
       * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.
       * @returns {string}
       * @example
       * // Logs: Hello from <#123456789012345678>!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return channelMention(this.id);
      }
      /**
       * Deletes this channel.
       * @returns {Promise<BaseChannel>}
       * @example
       * // Delete the channel
       * channel.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete() {
        await this.client.rest.delete(Routes2.channel(this.id));
        return this;
      }
      /**
       * Fetches this channel.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<BaseChannel>}
       */
      fetch(force = true) {
        return this.client.channels.fetch(this.id, { force });
      }
      /**
       * Indicates whether this channel is a {@link ThreadChannel}.
       * @returns {boolean}
       */
      isThread() {
        return ThreadChannelTypes.includes(this.type);
      }
      /**
       * Indicates whether this channel is {@link TextBasedChannels text-based}.
       * @returns {boolean}
       */
      isTextBased() {
        return "messages" in this;
      }
      /**
       * Indicates whether this channel is DM-based (either a {@link DMChannel} or a {@link PartialGroupDMChannel}).
       * @returns {boolean}
       */
      isDMBased() {
        return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
      }
      /**
       * Indicates whether this channel is {@link BaseGuildVoiceChannel voice-based}.
       * @returns {boolean}
       */
      isVoiceBased() {
        return "bitrate" in this;
      }
      /**
       * Indicates whether this channel is {@link ThreadOnlyChannel thread-only}.
       * @returns {boolean}
       */
      isThreadOnly() {
        return "availableTags" in this;
      }
      toJSON(...props) {
        return super.toJSON({ createdTimestamp: true }, ...props);
      }
    };
    exports2.BaseChannel = BaseChannel;
  }
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS({
  "node_modules/discord.js/src/managers/BaseManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
    };
    module2.exports = BaseManager;
  }
});

// node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS({
  "node_modules/discord.js/src/managers/DataManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = require_BaseManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var DataManager = class extends BaseManager {
      constructor(client, holds) {
        super(client);
        Object.defineProperty(this, "holds", { value: holds });
      }
      /**
       * The cache of items for this manager.
       * @type {Collection}
       * @abstract
       */
      get cache() {
        throw new DiscordjsError2(ErrorCodes2.NotImplemented, "get cache", this.constructor.name);
      }
      /**
       * Resolves a data entry to a data Object.
       * @param {string|Object} idOrInstance The id or instance of something in this Manager
       * @returns {?Object} An instance from this Manager
       */
      resolve(idOrInstance) {
        if (idOrInstance instanceof this.holds)
          return idOrInstance;
        if (typeof idOrInstance === "string")
          return this.cache.get(idOrInstance) ?? null;
        return null;
      }
      /**
       * Resolves a data entry to an instance id.
       * @param {string|Object} idOrInstance The id or instance of something in this Manager
       * @returns {?Snowflake}
       */
      resolveId(idOrInstance) {
        if (idOrInstance instanceof this.holds)
          return idOrInstance.id;
        if (typeof idOrInstance === "string")
          return idOrInstance;
        return null;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = DataManager;
  }
});

// node_modules/discord.js/src/util/Symbols.js
var require_Symbols = __commonJS({
  "node_modules/discord.js/src/util/Symbols.js"(exports2) {
    "use strict";
    exports2.MakeCacheOverrideSymbol = Symbol("djs.managers.makeCacheOverride");
  }
});

// node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS({
  "node_modules/discord.js/src/managers/CachedManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var { MakeCacheOverrideSymbol } = require_Symbols();
    var CachedManager = class extends DataManager {
      constructor(client, holds, iterable) {
        super(client, holds);
        Object.defineProperty(this, "_cache", {
          value: this.client.options.makeCache(
            this.constructor[MakeCacheOverrideSymbol] ?? this.constructor,
            this.holds,
            this.constructor
          )
        });
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      /**
       * The cache of items for this manager.
       * @type {Collection}
       * @abstract
       */
      get cache() {
        return this._cache;
      }
      _add(data, cache = true, { id, extras = [] } = {}) {
        const existing = this.cache.get(id ?? data.id);
        if (existing) {
          if (cache) {
            existing._patch(data);
            return existing;
          }
          const clone = existing._clone();
          clone._patch(data);
          return clone;
        }
        const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
        if (cache)
          this.cache.set(id ?? entry.id, entry);
        return entry;
      }
    };
    module2.exports = CachedManager;
  }
});

// node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS({
  "node_modules/discord.js/src/util/PermissionsBitField.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var BitField = require_BitField();
    var PermissionsBitField2 = class extends BitField {
      /**
       * Bitfield of the packed bits
       * @type {bigint}
       * @name PermissionsBitField#bitfield
       */
      /**
       * Data that can be resolved to give a permission number. This can be:
       * * A string (see {@link PermissionsBitField.Flags})
       * * A permission number
       * * An instance of {@link PermissionsBitField}
       * * An Array of PermissionResolvable
       * @typedef {string|bigint|PermissionsBitField|PermissionResolvable[]} PermissionResolvable
       */
      /**
       * Gets all given bits that are missing from the bitfield.
       * @param {BitFieldResolvable} bits Bit(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {string[]}
       */
      missing(bits, checkAdmin = true) {
        return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
      }
      /**
       * Checks whether the bitfield has a permission, or any of multiple permissions.
       * @param {PermissionResolvable} permission Permission(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {boolean}
       */
      any(permission, checkAdmin = true) {
        return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
      }
      /**
       * Checks whether the bitfield has a permission, or multiple permissions.
       * @param {PermissionResolvable} permission Permission(s) to check for
       * @param {boolean} [checkAdmin=true] Whether to allow the administrator permission to override
       * @returns {boolean}
       */
      has(permission, checkAdmin = true) {
        return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
      }
      /**
       * Gets an {@link Array} of bitfield names based on the permissions available.
       * @returns {string[]}
       */
      toArray() {
        return super.toArray(false);
      }
    };
    /**
     * Numeric permission flags.
     * @type {PermissionFlagsBits}
     * @memberof PermissionsBitField
     * @see {@link https://discord.com/developers/docs/topics/permissions#permissions-bitwise-permission-flags}
     */
    __publicField(PermissionsBitField2, "Flags", PermissionFlagsBits);
    /**
     * Bitfield representing every permission combined
     * @type {bigint}
     * @memberof PermissionsBitField
     */
    __publicField(PermissionsBitField2, "All", Object.values(PermissionFlagsBits).reduce((all, p) => all | p, 0n));
    /**
     * Bitfield representing the default permissions for users
     * @type {bigint}
     * @memberof PermissionsBitField
     */
    __publicField(PermissionsBitField2, "Default", BigInt(104324673));
    /**
     * Bitfield representing the permissions required for moderators of stage channels
     * @type {bigint}
     * @memberof PermissionsBitField
     */
    __publicField(PermissionsBitField2, "StageModerator", PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers);
    /**
     * @type {bigint}
     * @memberof PermissionsBitField
     * @private
     */
    __publicField(PermissionsBitField2, "DefaultBit", BigInt(0));
    module2.exports = PermissionsBitField2;
  }
});

// node_modules/discord.js/src/util/RoleFlagsBitField.js
var require_RoleFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/RoleFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { RoleFlags } = require_v106();
    var BitField = require_BitField();
    var RoleFlagsBitField = class extends BitField {
    };
    /**
     * Numeric role flags.
     * @type {RoleFlags}
     * @memberof RoleFlagsBitField
     */
    __publicField(RoleFlagsBitField, "Flags", RoleFlags);
    module2.exports = RoleFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS({
  "node_modules/discord.js/src/structures/Role.js"(exports2) {
    "use strict";
    var { roleMention } = require_dist7();
    var { DiscordSnowflake } = require_dist3();
    var { PermissionFlagsBits } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var PermissionsBitField2 = require_PermissionsBitField();
    var RoleFlagsBitField = require_RoleFlagsBitField();
    var Role = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.icon = null;
        this.unicodeEmoji = null;
        if (data)
          this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("color" in data) {
          this.color = data.color;
        }
        if ("hoist" in data) {
          this.hoist = data.hoist;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("permissions" in data) {
          this.permissions = new PermissionsBitField2(BigInt(data.permissions)).freeze();
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("mentionable" in data) {
          this.mentionable = data.mentionable;
        }
        if ("icon" in data)
          this.icon = data.icon;
        if ("unicode_emoji" in data)
          this.unicodeEmoji = data.unicode_emoji;
        if ("flags" in data) {
          this.flags = new RoleFlagsBitField(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new RoleFlagsBitField().freeze());
        }
        this.tags = data.tags ? {} : null;
        if (data.tags) {
          if ("bot_id" in data.tags) {
            this.tags.botId = data.tags.bot_id;
          }
          if ("integration_id" in data.tags) {
            this.tags.integrationId = data.tags.integration_id;
          }
          if ("premium_subscriber" in data.tags) {
            this.tags.premiumSubscriberRole = true;
          }
          if ("subscription_listing_id" in data.tags) {
            this.tags.subscriptionListingId = data.tags.subscription_listing_id;
          }
          if ("available_for_purchase" in data.tags) {
            this.tags.availableForPurchase = true;
          }
          if ("guild_connections" in data.tags) {
            this.tags.guildConnections = true;
          }
        }
      }
      /**
       * The timestamp the role was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the role was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The hexadecimal version of the role color, with a leading hashtag
       * @type {string}
       * @readonly
       */
      get hexColor() {
        return `#${this.color.toString(16).padStart(6, "0")}`;
      }
      /**
       * The cached guild members that have this role
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        return this.id === this.guild.id ? this.guild.members.cache.clone() : this.guild.members.cache.filter((member) => member._roles.includes(this.id));
      }
      /**
       * Whether the role is editable by the client user
       * @type {boolean}
       * @readonly
       */
      get editable() {
        if (this.managed)
          return false;
        const clientMember = this.guild.members.resolve(this.client.user);
        if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
          return false;
        return clientMember.roles.highest.comparePositionTo(this) > 0;
      }
      /**
       * The position of the role in the role manager
       * @type {number}
       * @readonly
       */
      get position() {
        return this.guild.roles.cache.reduce(
          (acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) < BigInt(role.id) : this.rawPosition > role.rawPosition),
          0
        );
      }
      /**
       * Compares this role's position to another role's.
       * @param {RoleResolvable} role Role to compare to this one
       * @returns {number} Negative number if this role's position is lower (other role's is higher),
       * positive number if this one is higher (other's is lower), 0 if equal
       * @example
       * // Compare the position of a role to another
       * const roleCompare = role.comparePositionTo(otherRole);
       * if (roleCompare >= 1) console.log(`${role.name} is higher than ${otherRole.name}`);
       */
      comparePositionTo(role) {
        return this.guild.roles.comparePositions(this, role);
      }
      /**
       * The data for a role.
       * @typedef {Object} RoleData
       * @property {string} [name] The name of the role
       * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
       * @property {boolean} [hoist] Whether or not the role should be hoisted
       * @property {number} [position] The position of the role
       * @property {PermissionResolvable} [permissions] The permissions of the role
       * @property {boolean} [mentionable] Whether or not the role should be mentionable
       * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @property {?string} [unicodeEmoji] The unicode emoji for the role
       */
      /**
       * Edits the role.
       * @param {RoleEditOptions} options The options to provide
       * @returns {Promise<Role>}
       * @example
       * // Edit a role
       * role.edit({ name: 'new role' })
       *   .then(updated => console.log(`Edited role name to ${updated.name}`))
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.roles.edit(this, options);
      }
      /**
       * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,
       * taking into account permission overwrites.
       * @param {GuildChannel|Snowflake} channel The guild channel to use as context
       * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {Readonly<PermissionsBitField>}
       */
      permissionsIn(channel, checkAdmin = true) {
        channel = this.guild.channels.resolve(channel);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        return channel.rolePermissions(this, checkAdmin);
      }
      /**
       * Sets a new name for the role.
       * @param {string} name The new name of the role
       * @param {string} [reason] Reason for changing the role's name
       * @returns {Promise<Role>}
       * @example
       * // Set the name of the role
       * role.setName('new role')
       *   .then(updated => console.log(`Updated role name to ${updated.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets a new color for the role.
       * @param {ColorResolvable} color The color of the role
       * @param {string} [reason] Reason for changing the role's color
       * @returns {Promise<Role>}
       * @example
       * // Set the color of a role
       * role.setColor('#FF0000')
       *   .then(updated => console.log(`Set color of role to ${updated.color}`))
       *   .catch(console.error);
       */
      setColor(color, reason) {
        return this.edit({ color, reason });
      }
      /**
       * Sets whether or not the role should be hoisted.
       * @param {boolean} [hoist=true] Whether or not to hoist the role
       * @param {string} [reason] Reason for setting whether or not the role should be hoisted
       * @returns {Promise<Role>}
       * @example
       * // Set the hoist of the role
       * role.setHoist(true)
       *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))
       *   .catch(console.error);
       */
      setHoist(hoist = true, reason) {
        return this.edit({ hoist, reason });
      }
      /**
       * Sets the permissions of the role.
       * @param {PermissionResolvable} permissions The permissions of the role
       * @param {string} [reason] Reason for changing the role's permissions
       * @returns {Promise<Role>}
       * @example
       * // Set the permissions of the role
       * role.setPermissions([PermissionFlagsBits.KickMembers, PermissionFlagsBits.BanMembers])
       *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
       *   .catch(console.error);
       * @example
       * // Remove all permissions from a role
       * role.setPermissions(0n)
       *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))
       *   .catch(console.error);
       */
      setPermissions(permissions, reason) {
        return this.edit({ permissions, reason });
      }
      /**
       * Sets whether this role is mentionable.
       * @param {boolean} [mentionable=true] Whether this role should be mentionable
       * @param {string} [reason] Reason for setting whether or not this role should be mentionable
       * @returns {Promise<Role>}
       * @example
       * // Make the role mentionable
       * role.setMentionable(true)
       *   .then(updated => console.log(`Role updated ${updated.name}`))
       *   .catch(console.error);
       */
      setMentionable(mentionable = true, reason) {
        return this.edit({ mentionable, reason });
      }
      /**
       * Sets a new icon for the role.
       * @param {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} icon The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @param {string} [reason] Reason for changing the role's icon
       * @returns {Promise<Role>}
       */
      setIcon(icon, reason) {
        return this.edit({ icon, reason });
      }
      /**
       * Sets a new unicode emoji for the role.
       * @param {?string} unicodeEmoji The new unicode emoji for the role
       * @param {string} [reason] Reason for changing the role's unicode emoji
       * @returns {Promise<Role>}
       * @example
       * // Set a new unicode emoji for the role
       * role.setUnicodeEmoji('')
       *   .then(updated => console.log(`Set unicode emoji for the role to ${updated.unicodeEmoji}`))
       *   .catch(console.error);
       */
      setUnicodeEmoji(unicodeEmoji, reason) {
        return this.edit({ unicodeEmoji, reason });
      }
      /**
       * Options used to set the position of a role.
       * @typedef {Object} SetRolePositionOptions
       * @property {boolean} [relative=false] Whether to change the position relative to its current value or not
       * @property {string} [reason] The reason for changing the position
       */
      /**
       * Sets the new position of the role.
       * @param {number} position The new position for the role
       * @param {SetRolePositionOptions} [options] Options for setting the position
       * @returns {Promise<Role>}
       * @example
       * // Set the position of the role
       * role.setPosition(1)
       *   .then(updated => console.log(`Role position: ${updated.position}`))
       *   .catch(console.error);
       */
      setPosition(position, options = {}) {
        return this.guild.roles.setPosition(this, position, options);
      }
      /**
       * Deletes the role.
       * @param {string} [reason] Reason for deleting this role
       * @returns {Promise<Role>}
       * @example
       * // Delete a role
       * role.delete('The role needed to go')
       *   .then(deleted => console.log(`Deleted role ${deleted.name}`))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.roles.delete(this.id, reason);
        return this;
      }
      /**
       * A link to the role's icon
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
      }
      /**
       * Whether this role equals another role. It compares all properties, so for most operations
       * it is advisable to just compare `role.id === role2.id` as it is much faster and is often
       * what most users need.
       * @param {Role} role Role to compare with
       * @returns {boolean}
       */
      equals(role) {
        return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
      }
      /**
       * When concatenated with a string, this automatically returns the role's mention instead of the Role object.
       * @returns {string}
       * @example
       * // Logs: Role: <@&123456789012345678>
       * console.log(`Role: ${role}`);
       */
      toString() {
        if (this.id === this.guild.id)
          return "@everyone";
        return roleMention(this.id);
      }
      toJSON() {
        return {
          ...super.toJSON({ createdTimestamp: true }),
          permissions: this.permissions.toJSON()
        };
      }
    };
    exports2.Role = Role;
  }
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS({
  "node_modules/discord.js/src/structures/PermissionOverwrites.js"(exports2, module2) {
    "use strict";
    var { OverwriteType } = require_v106();
    var Base = require_Base();
    var { Role } = require_Role();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var PermissionsBitField2 = require_PermissionsBitField();
    var PermissionOverwrites = class extends Base {
      constructor(client, data, channel) {
        super(client);
        Object.defineProperty(this, "channel", { value: channel });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("type" in data) {
          this.type = data.type;
        }
        if ("deny" in data) {
          this.deny = new PermissionsBitField2(BigInt(data.deny)).freeze();
        }
        if ("allow" in data) {
          this.allow = new PermissionsBitField2(BigInt(data.allow)).freeze();
        }
      }
      /**
       * Edits this Permission Overwrite.
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {string} [reason] Reason for creating/editing this overwrite
       * @returns {Promise<PermissionOverwrites>}
       * @example
       * // Update permission overwrites
       * permissionOverwrites.edit({
       *   SendMessages: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))
       *   .catch(console.error);
       */
      async edit(options, reason) {
        await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
        return this;
      }
      /**
       * Deletes this Permission Overwrite.
       * @param {string} [reason] Reason for deleting this overwrite
       * @returns {Promise<PermissionOverwrites>}
       */
      async delete(reason) {
        await this.channel.permissionOverwrites.delete(this.id, reason);
        return this;
      }
      toJSON() {
        return {
          id: this.id,
          type: this.type,
          allow: this.allow,
          deny: this.deny
        };
      }
      /**
       * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).
       * ```js
       * {
       *  'SendMessages': true,
       *  'EmbedLinks': null,
       *  'AttachFiles': false,
       * }
       * ```
       * @typedef {Object} PermissionOverwriteOptions
       */
      /**
       * @typedef {Object} ResolvedOverwriteOptions
       * @property {PermissionsBitField} allow The allowed permissions
       * @property {PermissionsBitField} deny The denied permissions
       */
      /**
       * Resolves bitfield permissions overwrites from an object.
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {ResolvedOverwriteOptions} initialPermissions The initial permissions
       * @returns {ResolvedOverwriteOptions}
       */
      static resolveOverwriteOptions(options, { allow, deny } = {}) {
        allow = new PermissionsBitField2(allow);
        deny = new PermissionsBitField2(deny);
        for (const [perm, value] of Object.entries(options)) {
          if (value === true) {
            allow.add(perm);
            deny.remove(perm);
          } else if (value === false) {
            allow.remove(perm);
            deny.add(perm);
          } else if (value === null) {
            allow.remove(perm);
            deny.remove(perm);
          }
        }
        return { allow, deny };
      }
      /**
       * The raw data for a permission overwrite
       * @typedef {Object} RawOverwriteData
       * @property {Snowflake} id The id of the {@link Role} or {@link User} this overwrite belongs to
       * @property {string} allow The permissions to allow
       * @property {string} deny The permissions to deny
       * @property {number} type The type of this OverwriteData
       */
      /**
       * Data that can be resolved into {@link RawOverwriteData}. This can be:
       * * PermissionOverwrites
       * * OverwriteData
       * @typedef {PermissionOverwrites|OverwriteData} OverwriteResolvable
       */
      /**
       * Data that can be used for a permission overwrite
       * @typedef {Object} OverwriteData
       * @property {GuildMemberResolvable|RoleResolvable} id Member or role this overwrite is for
       * @property {PermissionResolvable} [allow] The permissions to allow
       * @property {PermissionResolvable} [deny] The permissions to deny
       * @property {OverwriteType} [type] The type of this OverwriteData
       */
      /**
       * Resolves an overwrite into {@link RawOverwriteData}.
       * @param {OverwriteResolvable} overwrite The overwrite-like data to resolve
       * @param {Guild} [guild] The guild to resolve from
       * @returns {RawOverwriteData}
       */
      static resolve(overwrite, guild) {
        if (overwrite instanceof this)
          return overwrite.toJSON();
        if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
          return {
            id: overwrite.id,
            type: overwrite.type,
            allow: PermissionsBitField2.resolve(overwrite.allow ?? PermissionsBitField2.DefaultBit).toString(),
            deny: PermissionsBitField2.resolve(overwrite.deny ?? PermissionsBitField2.DefaultBit).toString()
          };
        }
        const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
        if (!userOrRole)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
        const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
        return {
          id: userOrRole.id,
          type,
          allow: PermissionsBitField2.resolve(overwrite.allow ?? PermissionsBitField2.DefaultBit).toString(),
          deny: PermissionsBitField2.resolve(overwrite.deny ?? PermissionsBitField2.DefaultBit).toString()
        };
      }
    };
    module2.exports = PermissionOverwrites;
  }
});

// node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS({
  "node_modules/discord.js/src/managers/PermissionOverwriteManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist6();
    var { OverwriteType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var PermissionOverwrites = require_PermissionOverwrites();
    var { Role } = require_Role();
    var cacheWarningEmitted = false;
    var PermissionOverwriteManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, PermissionOverwrites);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.channel = channel;
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, PermissionOverwrites>}
       * @name PermissionOverwriteManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.channel] });
      }
      /**
       * Replaces the permission overwrites in this channel.
       * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites
       * Permission overwrites the channel gets updated with
       * @param {string} [reason] Reason for updating the channel overwrites
       * @returns {Promise<GuildChannel>}
       * @example
       * message.channel.permissionOverwrites.set([
       *   {
       *      id: message.author.id,
       *      deny: [PermissionsFlagsBit.ViewChannel],
       *   },
       * ], 'Needed to change permissions');
       */
      set(overwrites, reason) {
        if (!Array.isArray(overwrites) && !(overwrites instanceof Collection2)) {
          return Promise.reject(
            new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "overwrites",
              "Array or Collection of Permission Overwrites",
              true
            )
          );
        }
        return this.channel.edit({ permissionOverwrites: overwrites, reason });
      }
      /**
       * Extra information about the overwrite.
       * @typedef {Object} GuildChannelOverwriteOptions
       * @property {string} [reason] The reason for creating/editing this overwrite
       * @property {OverwriteType} [type] The type of overwrite. Use this to bypass automatic resolution of `type`
       * that results in an error for an uncached structure
       */
      /**
       * Creates or edits permission overwrites for a user or role in this channel.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @param {PermissionOverwrites} [existing] The existing overwrites to merge with this update
       * @returns {Promise<GuildChannel>}
       * @private
       */
      async upsert(userOrRole, options, overwriteOptions = {}, existing) {
        let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        let { type, reason } = overwriteOptions;
        if (typeof type !== "number") {
          userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
          if (!userOrRole)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
          type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
        }
        const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
        await this.client.rest.put(Routes2.channelPermission(this.channel.id, userOrRoleId), {
          body: { id: userOrRoleId, type, allow, deny },
          reason
        });
        return this.channel;
      }
      /**
       * Creates permission overwrites for a user or role in this channel, or replaces them if already present.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @returns {Promise<GuildChannel>}
       * @example
       * // Create or Replace permission overwrites for a message author
       * message.channel.permissionOverwrites.create(message.author, {
       *   SendMessages: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))
       *   .catch(console.error);
       */
      create(userOrRole, options, overwriteOptions) {
        return this.upsert(userOrRole, options, overwriteOptions);
      }
      /**
       * Edits permission overwrites for a user or role in this channel, or creates an entry if not already present.
       * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update
       * @param {PermissionOverwriteOptions} options The options for the update
       * @param {GuildChannelOverwriteOptions} [overwriteOptions] The extra information for the update
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit or Create permission overwrites for a message author
       * message.channel.permissionOverwrites.edit(message.author, {
       *   SendMessages: false
       * })
       *   .then(channel => console.log(channel.permissionOverwrites.cache.get(message.author.id)))
       *   .catch(console.error);
       */
      edit(userOrRole, options, overwriteOptions) {
        const existing = this.cache.get(
          this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole)
        );
        return this.upsert(userOrRole, options, overwriteOptions, existing);
      }
      /**
       * Deletes permission overwrites for a user or role in this channel.
       * @param {UserResolvable|RoleResolvable} userOrRole The user or role to delete
       * @param {string} [reason] The reason for deleting the overwrite
       * @returns {Promise<GuildChannel>}
       */
      async delete(userOrRole, reason) {
        const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        if (!userOrRoleId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
        await this.client.rest.delete(Routes2.channelPermission(this.channel.id, userOrRoleId), { reason });
        return this.channel;
      }
    };
    module2.exports = PermissionOverwriteManager;
  }
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS({
  "node_modules/discord.js/src/structures/GuildChannel.js"(exports2, module2) {
    "use strict";
    var { Snowflake } = require_dist3();
    var { PermissionFlagsBits, ChannelType } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var PermissionOverwriteManager = require_PermissionOverwriteManager();
    var { VoiceBasedChannelTypes } = require_Constants();
    var PermissionsBitField2 = require_PermissionsBitField();
    var { getSortableGroupTypes } = require_Util();
    var GuildChannel = class extends BaseChannel {
      constructor(guild, data, client, immediatePatch = true) {
        super(client, data, false);
        this.guild = guild;
        this.guildId = (guild == null ? void 0 : guild.id) ?? data.guild_id;
        this.permissionOverwrites = new PermissionOverwriteManager(this);
        if (data && immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        } else {
          this.parentId ?? (this.parentId = null);
        }
        if ("permission_overwrites" in data) {
          this.permissionOverwrites.cache.clear();
          for (const overwrite of data.permission_overwrites) {
            this.permissionOverwrites._add(overwrite);
          }
        }
      }
      _clone() {
        const clone = super._clone();
        clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
        return clone;
      }
      /**
       * The category parent of this channel
       * @type {?CategoryChannel}
       * @readonly
       */
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      /**
       * If the permissionOverwrites match the parent channel, null if no parent
       * @type {?boolean}
       * @readonly
       */
      get permissionsLocked() {
        if (!this.parent)
          return null;
        const overwriteIds = /* @__PURE__ */ new Set([
          ...this.permissionOverwrites.cache.keys(),
          ...this.parent.permissionOverwrites.cache.keys()
        ]);
        return [...overwriteIds].every((key) => {
          const channelVal = this.permissionOverwrites.cache.get(key);
          const parentVal = this.parent.permissionOverwrites.cache.get(key);
          if (!channelVal && parentVal.deny.bitfield === PermissionsBitField2.DefaultBit && parentVal.allow.bitfield === PermissionsBitField2.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField2.DefaultBit && channelVal.allow.bitfield === PermissionsBitField2.DefaultBit) {
            return true;
          }
          return channelVal !== void 0 && parentVal !== void 0 && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
        });
      }
      /**
       * The position of the channel
       * @type {number}
       * @readonly
       */
      get position() {
        const selfIsCategory = this.type === ChannelType.GuildCategory;
        const types = getSortableGroupTypes(this.type);
        let count = 0;
        for (const channel of this.guild.channels.cache.values()) {
          if (!types.includes(channel.type))
            continue;
          if (!selfIsCategory && channel.parentId !== this.parentId)
            continue;
          if (this.rawPosition === channel.rawPosition) {
            if (Snowflake.compare(channel.id, this.id) === -1)
              count++;
          } else if (this.rawPosition > channel.rawPosition) {
            count++;
          }
        }
        return count;
      }
      /**
       * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.
       * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
       * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {?Readonly<PermissionsBitField>}
       */
      permissionsFor(memberOrRole, checkAdmin = true) {
        const member = this.guild.members.resolve(memberOrRole);
        if (member)
          return this.memberPermissions(member, checkAdmin);
        const role = this.guild.roles.resolve(memberOrRole);
        return role && this.rolePermissions(role, checkAdmin);
      }
      overwritesFor(member, verified = false, roles = null) {
        if (!verified)
          member = this.guild.members.resolve(member);
        if (!member)
          return [];
        roles ?? (roles = member.roles.cache);
        const roleOverwrites = [];
        let memberOverwrites;
        let everyoneOverwrites;
        for (const overwrite of this.permissionOverwrites.cache.values()) {
          if (overwrite.id === this.guild.id) {
            everyoneOverwrites = overwrite;
          } else if (roles.has(overwrite.id)) {
            roleOverwrites.push(overwrite);
          } else if (overwrite.id === member.id) {
            memberOverwrites = overwrite;
          }
        }
        return {
          everyone: everyoneOverwrites,
          roles: roleOverwrites,
          member: memberOverwrites
        };
      }
      /**
       * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.
       * @param {GuildMember} member The member to obtain the overall permissions for
       * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {Readonly<PermissionsBitField>}
       * @private
       */
      memberPermissions(member, checkAdmin) {
        var _a, _b, _c, _d;
        if (checkAdmin && member.id === this.guild.ownerId) {
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        }
        const roles = member.roles.cache;
        const permissions = new PermissionsBitField2(roles.map((role) => role.permissions));
        if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        }
        const overwrites = this.overwritesFor(member, true, roles);
        return permissions.remove(((_a = overwrites.everyone) == null ? void 0 : _a.deny) ?? PermissionsBitField2.DefaultBit).add(((_b = overwrites.everyone) == null ? void 0 : _b.allow) ?? PermissionsBitField2.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField2.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField2.DefaultBit).remove(((_c = overwrites.member) == null ? void 0 : _c.deny) ?? PermissionsBitField2.DefaultBit).add(((_d = overwrites.member) == null ? void 0 : _d.allow) ?? PermissionsBitField2.DefaultBit).freeze();
      }
      /**
       * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.
       * @param {Role} role The role to obtain the overall permissions for
       * @param {boolean} checkAdmin Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {Readonly<PermissionsBitField>}
       * @private
       */
      rolePermissions(role, checkAdmin) {
        if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        }
        const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
        const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
        return role.permissions.remove((everyoneOverwrites == null ? void 0 : everyoneOverwrites.deny) ?? PermissionsBitField2.DefaultBit).add((everyoneOverwrites == null ? void 0 : everyoneOverwrites.allow) ?? PermissionsBitField2.DefaultBit).remove((roleOverwrites == null ? void 0 : roleOverwrites.deny) ?? PermissionsBitField2.DefaultBit).add((roleOverwrites == null ? void 0 : roleOverwrites.allow) ?? PermissionsBitField2.DefaultBit).freeze();
      }
      /**
       * Locks in the permission overwrites from the parent channel.
       * @returns {Promise<GuildChannel>}
       */
      lockPermissions() {
        if (!this.parent)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.GuildChannelOrphan));
        const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
        return this.edit({ permissionOverwrites });
      }
      /**
       * A collection of cached members of this channel, mapped by their ids.
       * Members that can view this channel, if the channel is text-based.
       * Members in the channel, if the channel is voice-based.
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        return this.guild.members.cache.filter(
          (member) => this.permissionsFor(member).has(PermissionFlagsBits.ViewChannel, false)
        );
      }
      /**
       * Edits the channel.
       * @param {GuildChannelEditOptions} options The options to provide
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit a channel
       * channel.edit({ name: 'new-channel' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.channels.edit(this, options);
      }
      /**
       * Sets a new name for the guild channel.
       * @param {string} name The new name for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's name
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel name
       * channel.setName('not_general')
       *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Options used to set the parent of a channel.
       * @typedef {Object} SetParentOptions
       * @property {boolean} [lockPermissions=true] Whether to lock the permissions to what the parent's permissions are
       * @property {string} [reason] The reason for modifying the parent of the channel
       */
      /**
       * Sets the parent of this channel.
       * @param {?CategoryChannelResolvable} channel The category channel to set as the parent
       * @param {SetParentOptions} [options={}] The options for setting the parent
       * @returns {Promise<GuildChannel>}
       * @example
       * // Add a parent to a channel
       * message.channel.setParent('355908108431917066', { lockPermissions: false })
       *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))
       *   .catch(console.error);
       */
      setParent(channel, { lockPermissions = true, reason } = {}) {
        return this.edit({
          parent: channel ?? null,
          lockPermissions,
          reason
        });
      }
      /**
       * Options used to set the position of a channel.
       * @typedef {Object} SetChannelPositionOptions
       * @property {boolean} [relative=false] Whether or not to change the position relative to its current value
       * @property {string} [reason] The reason for changing the position
       */
      /**
       * Sets a new position for the guild channel.
       * @param {number} position The new position for the guild channel
       * @param {SetChannelPositionOptions} [options] Options for setting position
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel position
       * channel.setPosition(2)
       *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
       *   .catch(console.error);
       */
      setPosition(position, options = {}) {
        return this.guild.channels.setPosition(this, position, options);
      }
      /**
       * Options used to clone a guild channel.
       * @typedef {GuildChannelCreateOptions} GuildChannelCloneOptions
       * @property {string} [name=this.name] Name of the new channel
       */
      /**
       * Clones this channel.
       * @param {GuildChannelCloneOptions} [options] The options for cloning this channel
       * @returns {Promise<GuildChannel>}
       */
      clone(options = {}) {
        return this.guild.channels.create({
          name: options.name ?? this.name,
          permissionOverwrites: this.permissionOverwrites.cache,
          topic: this.topic,
          type: this.type,
          nsfw: this.nsfw,
          parent: this.parent,
          bitrate: this.bitrate,
          userLimit: this.userLimit,
          rateLimitPerUser: this.rateLimitPerUser,
          position: this.rawPosition,
          reason: null,
          ...options
        });
      }
      /**
       * Checks if this channel has the same type, topic, position, name, overwrites, and id as another channel.
       * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.
       * @param {GuildChannel} channel Channel to compare with
       * @returns {boolean}
       */
      equals(channel) {
        let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
        if (equal) {
          if (this.permissionOverwrites && channel.permissionOverwrites) {
            equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
          } else {
            equal = !this.permissionOverwrites && !channel.permissionOverwrites;
          }
        }
        return equal;
      }
      /**
       * Whether the channel is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
      }
      /**
       * Whether the channel is manageable by the client user
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
          return false;
        const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
        return permissions.has(bitfield, false);
      }
      /**
       * Whether the channel is viewable by the client user
       * @type {boolean}
       * @readonly
       */
      get viewable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        return permissions.has(PermissionFlagsBits.ViewChannel, false);
      }
      /**
       * Deletes this channel.
       * @param {string} [reason] Reason for deleting this channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Delete the channel
       * channel.delete('making room for new channels')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
    };
    module2.exports = GuildChannel;
  }
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS({
  "node_modules/discord.js/src/util/Util.js"(exports2, module2) {
    "use strict";
    var { parse } = require_node_path();
    var { Collection: Collection2 } = require_dist6();
    var { ChannelType, RouteBases, Routes: Routes2 } = require_v106();
    var { fetch: fetch2 } = require_undici();
    var Colors = require_Colors();
    var { DiscordjsError: DiscordjsError2, DiscordjsRangeError: DiscordjsRangeError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var isObject = (d) => typeof d === "object" && d !== null;
    function flatten(obj, ...props) {
      if (!isObject(obj))
        return obj;
      const objProps = Object.keys(obj).filter((key) => !key.startsWith("_")).map((key) => ({ [key]: true }));
      props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
      const out = {};
      for (let [prop, newProp] of Object.entries(props)) {
        if (!newProp)
          continue;
        newProp = newProp === true ? prop : newProp;
        const element = obj[prop];
        const elemIsObj = isObject(element);
        const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
        const hasToJSON = elemIsObj && typeof element.toJSON === "function";
        if (element instanceof Collection2)
          out[newProp] = Array.from(element.keys());
        else if (valueOf instanceof Collection2)
          out[newProp] = Array.from(valueOf.keys());
        else if (Array.isArray(element))
          out[newProp] = element.map((elm) => {
            var _a;
            return ((_a = elm.toJSON) == null ? void 0 : _a.call(elm)) ?? flatten(elm);
          });
        else if (typeof valueOf !== "object")
          out[newProp] = valueOf;
        else if (hasToJSON)
          out[newProp] = element.toJSON();
        else if (typeof element === "object")
          out[newProp] = flatten(element);
        else if (!elemIsObj)
          out[newProp] = element;
      }
      return out;
    }
    async function fetchRecommendedShardCount(token, { guildsPerShard = 1e3, multipleOf = 1 } = {}) {
      if (!token)
        throw new DiscordjsError2(ErrorCodes2.TokenMissing);
      const response = await fetch2(RouteBases.api + Routes2.gatewayBot(), {
        method: "GET",
        headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
      });
      if (!response.ok) {
        if (response.status === 401)
          throw new DiscordjsError2(ErrorCodes2.TokenInvalid);
        throw response;
      }
      const { shards } = await response.json();
      return Math.ceil(shards * (1e3 / guildsPerShard) / multipleOf) * multipleOf;
    }
    function parseEmoji(text) {
      if (text.includes("%"))
        text = decodeURIComponent(text);
      if (!text.includes(":"))
        return { animated: false, name: text, id: void 0 };
      const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
      return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
    }
    function resolvePartialEmoji(emoji) {
      if (!emoji)
        return null;
      if (typeof emoji === "string")
        return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
      const { id, name, animated } = emoji;
      if (!id && !name)
        return null;
      return { id, name, animated: Boolean(animated) };
    }
    function makeError(obj) {
      const err = new Error(obj.message);
      err.name = obj.name;
      err.stack = obj.stack;
      return err;
    }
    function makePlainError(err) {
      return {
        name: err.name,
        message: err.message,
        stack: err.stack
      };
    }
    var TextSortableGroupTypes = [
      ChannelType.GuildText,
      ChannelType.GuildAnnouncement,
      ChannelType.GuildForum,
      ChannelType.GuildMedia
    ];
    var VoiceSortableGroupTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
    var CategorySortableGroupTypes = [ChannelType.GuildCategory];
    function getSortableGroupTypes(type) {
      switch (type) {
        case ChannelType.GuildText:
        case ChannelType.GuildAnnouncement:
        case ChannelType.GuildForum:
        case ChannelType.GuildMedia:
          return TextSortableGroupTypes;
        case ChannelType.GuildVoice:
        case ChannelType.GuildStageVoice:
          return VoiceSortableGroupTypes;
        case ChannelType.GuildCategory:
          return CategorySortableGroupTypes;
        default:
          return [type];
      }
    }
    function moveElementInArray(array, element, newIndex, offset = false) {
      const index = array.indexOf(element);
      newIndex = (offset ? index : 0) + newIndex;
      if (newIndex > -1 && newIndex < array.length) {
        const removedElement = array.splice(index, 1)[0];
        array.splice(newIndex, 0, removedElement);
      }
      return array.indexOf(element);
    }
    function verifyString(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
      if (typeof data !== "string")
        throw new error(errorMessage);
      if (!allowEmpty && data.length === 0)
        throw new error(errorMessage);
      return data;
    }
    function resolveColor(color) {
      if (typeof color === "string") {
        if (color === "Random")
          return Math.floor(Math.random() * (16777215 + 1));
        if (color === "Default")
          return 0;
        if (/^#?[\da-f]{6}$/i.test(color))
          return parseInt(color.replace("#", ""), 16);
        color = Colors[color];
      } else if (Array.isArray(color)) {
        color = (color[0] << 16) + (color[1] << 8) + color[2];
      }
      if (color < 0 || color > 16777215)
        throw new DiscordjsRangeError2(ErrorCodes2.ColorRange);
      if (typeof color !== "number" || Number.isNaN(color))
        throw new DiscordjsTypeError2(ErrorCodes2.ColorConvert);
      return color;
    }
    function discordSort(collection) {
      const isGuildChannel = collection.first() instanceof GuildChannel;
      return collection.sorted(
        isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id))
      );
    }
    async function setPosition(item, position, relative, sorted, client, route, reason) {
      let updatedItems = [...sorted.values()];
      moveElementInArray(updatedItems, item, position, relative);
      updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
      await client.rest.patch(route, { body: updatedItems, reason });
      return updatedItems;
    }
    function basename(path, ext) {
      const res = parse(path);
      return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
    }
    function cleanContent(str, channel) {
      return str.replaceAll(
        /* eslint-disable max-len */
        /<(?:(?<type>@[!&]?|#)|(?:\/(?<commandName>[-_\p{L}\p{N}\p{sc=Deva}\p{sc=Thai} ]+):)|(?:a?:(?<emojiName>[\w]+):))(?<id>\d{17,19})>/gu,
        (match, type, commandName, emojiName, id) => {
          var _a;
          if (commandName)
            return `/${commandName}`;
          if (emojiName)
            return `:${emojiName}:`;
          switch (type) {
            case "@":
            case "@!": {
              const member = (_a = channel.guild) == null ? void 0 : _a.members.cache.get(id);
              if (member) {
                return `@${member.displayName}`;
              }
              const user = channel.client.users.cache.get(id);
              return user ? `@${user.displayName}` : match;
            }
            case "@&": {
              if (channel.type === ChannelType.DM)
                return match;
              const role = channel.guild.roles.cache.get(id);
              return role ? `@${role.name}` : match;
            }
            case "#": {
              const mentionedChannel = channel.client.channels.cache.get(id);
              return mentionedChannel ? `#${mentionedChannel.name}` : match;
            }
            default: {
              return match;
            }
          }
        }
      );
    }
    function cleanCodeBlockContent(text) {
      return text.replaceAll("```", "```");
    }
    function parseWebhookURL(url) {
      const matches = url.match(
        /https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i
      );
      if (!matches || matches.length <= 2)
        return null;
      const [, id, token] = matches;
      return {
        id,
        token
      };
    }
    function transformResolved({ client, guild, channel }, { members, users, channels, roles, messages, attachments } = {}) {
      var _a;
      const result = {};
      if (members) {
        result.members = new Collection2();
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          result.members.set(id, (guild == null ? void 0 : guild.members._add({ user, ...member })) ?? member);
        }
      }
      if (users) {
        result.users = new Collection2();
        for (const user of Object.values(users)) {
          result.users.set(user.id, client.users._add(user));
        }
      }
      if (roles) {
        result.roles = new Collection2();
        for (const role of Object.values(roles)) {
          result.roles.set(role.id, (guild == null ? void 0 : guild.roles._add(role)) ?? role);
        }
      }
      if (channels) {
        result.channels = new Collection2();
        for (const apiChannel of Object.values(channels)) {
          result.channels.set(apiChannel.id, client.channels._add(apiChannel, guild) ?? apiChannel);
        }
      }
      if (messages) {
        result.messages = new Collection2();
        for (const message of Object.values(messages)) {
          result.messages.set(message.id, ((_a = channel == null ? void 0 : channel.messages) == null ? void 0 : _a._add(message)) ?? message);
        }
      }
      if (attachments) {
        result.attachments = new Collection2();
        for (const attachment of Object.values(attachments)) {
          const patched = new Attachment(attachment);
          result.attachments.set(attachment.id, patched);
        }
      }
      return result;
    }
    module2.exports = {
      flatten,
      fetchRecommendedShardCount,
      parseEmoji,
      resolvePartialEmoji,
      makeError,
      makePlainError,
      getSortableGroupTypes,
      moveElementInArray,
      verifyString,
      resolveColor,
      discordSort,
      setPosition,
      basename,
      cleanContent,
      cleanCodeBlockContent,
      parseWebhookURL,
      transformResolved
    };
    var Attachment = require_Attachment();
    var GuildChannel = require_GuildChannel();
  }
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS({
  "node_modules/discord.js/src/client/BaseClient.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var { REST } = require_web();
    var { Routes: Routes2 } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Options2 = require_Options();
    var { flatten } = require_Util();
    var BaseClient2 = class extends EventEmitter {
      constructor(options = {}) {
        var _a;
        super({ captureRejections: true });
        if (typeof options !== "object" || options === null) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        }
        const defaultOptions = Options2.createDefault();
        this.options = {
          ...defaultOptions,
          ...options,
          presence: {
            ...defaultOptions.presence,
            ...options.presence
          },
          sweepers: {
            ...defaultOptions.sweepers,
            ...options.sweepers
          },
          ws: {
            ...defaultOptions.ws,
            ...options.ws
          },
          rest: {
            ...defaultOptions.rest,
            ...options.rest,
            userAgentAppendix: ((_a = options.rest) == null ? void 0 : _a.userAgentAppendix) ? `${Options2.userAgentAppendix} ${options.rest.userAgentAppendix}` : void 0
          }
        };
        this.rest = new REST(this.options.rest);
      }
      /**
       * Destroys all assets used by the base client.
       * @returns {void}
       */
      destroy() {
        this.rest.clearHashSweeper();
        this.rest.clearHandlerSweeper();
      }
      /**
       * Options used for deleting a webhook.
       * @typedef {Object} WebhookDeleteOptions
       * @property {string} [token] Token of the webhook
       * @property {string} [reason] The reason for deleting the webhook
       */
      /**
       * Deletes a webhook.
       * @param {Snowflake} id The webhook's id
       * @param {WebhookDeleteOptions} [options] Options for deleting the webhook
       * @returns {Promise<void>}
       */
      async deleteWebhook(id, { token, reason } = {}) {
        await this.rest.delete(Routes2.webhook(id, token), { auth: !token, reason });
      }
      /**
       * Increments max listeners by one, if they are not zero.
       * @private
       */
      incrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one, if they are not zero.
       * @private
       */
      decrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners - 1);
        }
      }
      toJSON(...props) {
        return flatten(this, ...props);
      }
    };
    module2.exports = BaseClient2;
  }
});

// node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS({
  "node_modules/discord.js/src/util/Enums.js"(exports2, module2) {
    "use strict";
    function createEnum(keys) {
      const obj = {};
      for (const [index, key] of keys.entries()) {
        if (key === null)
          continue;
        obj[key] = index;
        obj[index] = key;
      }
      return obj;
    }
    module2.exports = { createEnum };
  }
});

// node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS({
  "node_modules/discord.js/src/util/Partials.js"(exports2, module2) {
    "use strict";
    var { createEnum } = require_Enums();
    module2.exports = createEnum([
      "User",
      "Channel",
      "GuildMember",
      "Message",
      "Reaction",
      "GuildScheduledEvent",
      "ThreadMember"
    ]);
  }
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS({
  "node_modules/discord.js/src/client/actions/Action.js"(exports2, module2) {
    "use strict";
    var Partials = require_Partials();
    var GenericAction = class {
      constructor(client) {
        this.client = client;
      }
      handle(data) {
        return data;
      }
      getPayload(data, manager, id, partialType, cache) {
        return this.client.options.partials.includes(partialType) ? manager._add(data, cache) : manager.cache.get(id);
      }
      getChannel(data) {
        const payloadData = {};
        const id = data.channel_id ?? data.id;
        if ("recipients" in data) {
          payloadData.recipients = data.recipients;
        } else {
          const recipient = data.author ?? data.user ?? { id: data.user_id };
          if (recipient.id !== this.client.user.id)
            payloadData.recipients = [recipient];
        }
        if (id !== void 0)
          payloadData.id = id;
        if ("guild_id" in data)
          payloadData.guild_id = data.guild_id;
        if ("last_message_id" in data)
          payloadData.last_message_id = data.last_message_id;
        return data[this.client.actions.injectedChannel] ?? this.getPayload(payloadData, this.client.channels, id, Partials.Channel);
      }
      getMessage(data, channel, cache) {
        var _a;
        const id = data.message_id ?? data.id;
        return data[this.client.actions.injectedMessage] ?? this.getPayload(
          {
            id,
            channel_id: channel.id,
            guild_id: data.guild_id ?? ((_a = channel.guild) == null ? void 0 : _a.id)
          },
          channel.messages,
          id,
          Partials.Message,
          cache
        );
      }
      getReaction(data, message, user) {
        const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
        return this.getPayload(
          {
            emoji: data.emoji,
            count: message.partial ? null : 0,
            me: (user == null ? void 0 : user.id) === this.client.user.id
          },
          message.reactions,
          id,
          Partials.Reaction
        );
      }
      getMember(data, guild) {
        return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
      }
      getUser(data) {
        const id = data.user_id;
        return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
      }
      getUserFromMember(data) {
        var _a;
        if (data.guild_id && ((_a = data.member) == null ? void 0 : _a.user)) {
          const guild = this.client.guilds.cache.get(data.guild_id);
          if (guild) {
            return guild.members._add(data.member).user;
          } else {
            return this.client.users._add(data.member.user);
          }
        }
        return this.getUser(data);
      }
      getScheduledEvent(data, guild) {
        const id = data.guild_scheduled_event_id ?? data.id;
        return this.getPayload(
          { id, guild_id: data.guild_id ?? guild.id },
          guild.scheduledEvents,
          id,
          Partials.GuildScheduledEvent
        );
      }
      getThreadMember(id, manager) {
        return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
      }
    };
    module2.exports = GenericAction;
  }
});

// node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS({
  "node_modules/discord.js/src/util/Events.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
      AutoModerationActionExecution: "autoModerationActionExecution",
      AutoModerationRuleCreate: "autoModerationRuleCreate",
      AutoModerationRuleDelete: "autoModerationRuleDelete",
      AutoModerationRuleUpdate: "autoModerationRuleUpdate",
      CacheSweep: "cacheSweep",
      ChannelCreate: "channelCreate",
      ChannelDelete: "channelDelete",
      ChannelPinsUpdate: "channelPinsUpdate",
      ChannelUpdate: "channelUpdate",
      ClientReady: "ready",
      Debug: "debug",
      Error: "error",
      GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
      GuildAvailable: "guildAvailable",
      GuildBanAdd: "guildBanAdd",
      GuildBanRemove: "guildBanRemove",
      GuildCreate: "guildCreate",
      GuildDelete: "guildDelete",
      GuildEmojiCreate: "emojiCreate",
      GuildEmojiDelete: "emojiDelete",
      GuildEmojiUpdate: "emojiUpdate",
      GuildIntegrationsUpdate: "guildIntegrationsUpdate",
      GuildMemberAdd: "guildMemberAdd",
      GuildMemberAvailable: "guildMemberAvailable",
      GuildMemberRemove: "guildMemberRemove",
      GuildMembersChunk: "guildMembersChunk",
      GuildMemberUpdate: "guildMemberUpdate",
      GuildRoleCreate: "roleCreate",
      GuildRoleDelete: "roleDelete",
      GuildRoleUpdate: "roleUpdate",
      GuildScheduledEventCreate: "guildScheduledEventCreate",
      GuildScheduledEventDelete: "guildScheduledEventDelete",
      GuildScheduledEventUpdate: "guildScheduledEventUpdate",
      GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
      GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
      GuildStickerCreate: "stickerCreate",
      GuildStickerDelete: "stickerDelete",
      GuildStickerUpdate: "stickerUpdate",
      GuildUnavailable: "guildUnavailable",
      GuildUpdate: "guildUpdate",
      InteractionCreate: "interactionCreate",
      Invalidated: "invalidated",
      InviteCreate: "inviteCreate",
      InviteDelete: "inviteDelete",
      MessageBulkDelete: "messageDeleteBulk",
      MessageCreate: "messageCreate",
      MessageDelete: "messageDelete",
      MessageReactionAdd: "messageReactionAdd",
      MessageReactionRemove: "messageReactionRemove",
      MessageReactionRemoveAll: "messageReactionRemoveAll",
      MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
      MessageUpdate: "messageUpdate",
      PresenceUpdate: "presenceUpdate",
      Raw: "raw",
      ShardDisconnect: "shardDisconnect",
      ShardError: "shardError",
      ShardReady: "shardReady",
      ShardReconnecting: "shardReconnecting",
      ShardResume: "shardResume",
      StageInstanceCreate: "stageInstanceCreate",
      StageInstanceDelete: "stageInstanceDelete",
      StageInstanceUpdate: "stageInstanceUpdate",
      ThreadCreate: "threadCreate",
      ThreadDelete: "threadDelete",
      ThreadListSync: "threadListSync",
      ThreadMembersUpdate: "threadMembersUpdate",
      ThreadMemberUpdate: "threadMemberUpdate",
      ThreadUpdate: "threadUpdate",
      TypingStart: "typingStart",
      UserUpdate: "userUpdate",
      VoiceServerUpdate: "voiceServerUpdate",
      VoiceStateUpdate: "voiceStateUpdate",
      Warn: "warn",
      WebhooksUpdate: "webhookUpdate"
    };
  }
});

// node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var ApplicationCommandPermissionsUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        client.emit(Events2.ApplicationCommandPermissionsUpdate, {
          permissions: data.permissions,
          id: data.id,
          guildId: data.guild_id,
          applicationId: data.application_id
        });
      }
    };
    module2.exports = ApplicationCommandPermissionsUpdateAction;
  }
});

// node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS({
  "node_modules/discord.js/src/structures/AutoModerationActionExecution.js"(exports2, module2) {
    "use strict";
    var { _transformAPIAutoModerationAction } = require_Transformers();
    var AutoModerationActionExecution = class {
      constructor(data, guild) {
        this.guild = guild;
        this.action = _transformAPIAutoModerationAction(data.action);
        this.ruleId = data.rule_id;
        this.ruleTriggerType = data.rule_trigger_type;
        this.userId = data.user_id;
        this.channelId = data.channel_id ?? null;
        this.messageId = data.message_id ?? null;
        this.alertSystemMessageId = data.alert_system_message_id ?? null;
        this.content = data.content;
        this.matchedKeyword = data.matched_keyword ?? null;
        this.matchedContent = data.matched_content ?? null;
      }
      /**
       * The auto moderation rule this action belongs to.
       * @type {?AutoModerationRule}
       * @readonly
       */
      get autoModerationRule() {
        return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
      }
      /**
       * The channel where this action was triggered from.
       * @type {?(GuildTextBasedChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get channel() {
        return this.guild.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * The user that triggered this action.
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.guild.client.users.cache.get(this.userId) ?? null;
      }
      /**
       * The guild member that triggered this action.
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.cache.get(this.userId) ?? null;
      }
    };
    module2.exports = AutoModerationActionExecution;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var AutoModerationActionExecution = require_AutoModerationActionExecution();
    var Events2 = require_Events();
    var AutoModerationActionExecutionAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          client.emit(Events2.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
        }
        return {};
      }
    };
    module2.exports = AutoModerationActionExecutionAction;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var AutoModerationRuleCreateAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const autoModerationRule = guild.autoModerationRules._add(data);
          client.emit(Events2.AutoModerationRuleCreate, autoModerationRule);
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var AutoModerationRuleDeleteAction = class extends Action {
      handle(data) {
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
          if (autoModerationRule) {
            guild.autoModerationRules.cache.delete(autoModerationRule.id);
            client.emit(Events2.AutoModerationRuleDelete, autoModerationRule);
          }
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var AutoModerationRuleUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const { client } = this;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldAutoModerationRule = ((_a = guild.autoModerationRules.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newAutoModerationRule = guild.autoModerationRules._add(data);
          client.emit(Events2.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
        }
        return {};
      }
    };
    module2.exports = AutoModerationRuleUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/ChannelCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var ChannelCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const channel = client.channels._add(data);
        if (!existing && channel) {
          client.emit(Events2.ChannelCreate, channel);
        }
        return { channel };
      }
    };
    module2.exports = ChannelCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/ChannelDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var ChannelDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.id);
        if (channel) {
          client.channels._remove(channel.id);
          client.emit(Events2.ChannelDelete, channel);
        }
      }
    };
    module2.exports = ChannelDeleteAction;
  }
});

// node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS({
  "node_modules/discord.js/src/managers/CategoryChannelChildManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var GuildChannel = require_GuildChannel();
    var CategoryChannelChildManager = class extends DataManager {
      constructor(channel) {
        super(channel.client, GuildChannel);
        this.channel = channel;
      }
      /**
       * The channels that are a part of this category
       * @type {Collection<Snowflake, GuildChannel>}
       * @readonly
       */
      get cache() {
        return this.guild.channels.cache.filter((channel) => channel.parentId === this.channel.id);
      }
      /**
       * The guild this manager belongs to
       * @type {Guild}
       * @readonly
       */
      get guild() {
        return this.channel.guild;
      }
      /**
       * Options for creating a channel using {@link CategoryChannel#createChannel}.
       * @typedef {Object} CategoryCreateChannelOptions
       * @property {string} name The name for the new channel
       * @property {ChannelType} [type=ChannelType.GuildText] The type of the new channel.
       * @property {string} [topic] The topic for the new channel
       * @property {boolean} [nsfw] Whether the new channel is NSFW
       * @property {number} [bitrate] Bitrate of the new channel in bits (only voice)
       * @property {number} [userLimit] Maximum amount of users allowed in the new channel (only voice)
       * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
       * Permission overwrites of the new channel
       * @property {number} [position] Position of the new channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the new channel in seconds
       * @property {string} [rtcRegion] The specific region of the new channel.
       * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the voice channel
       * @property {number} [defaultThreadRateLimitPerUser] The initial rate limit per user (slowmode)
       * to set on newly created threads in a channel.
       * @property {GuildForumTagData[]} [availableTags] The tags that can be used in this channel (forum only).
       * @property {DefaultReactionEmoji} [defaultReactionEmoji]
       * The emoji to show in the add reaction button on a thread in a guild forum channel.
       * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]
       * The default auto archive duration for all new threads in this channel
       * @property {SortOrderType} [defaultSortOrder] The default sort order mode used to order posts (forum only).
       * @property {ForumLayoutType} [defaultForumLayout] The default layout used to display posts (forum only).
       * @property {string} [reason] Reason for creating the new channel
       */
      /**
       * Creates a new channel within this category.
       * <info>You cannot create a channel of type {@link ChannelType.GuildCategory} inside a CategoryChannel.</info>
       * @param {CategoryCreateChannelOptions} options Options for creating the new channel
       * @returns {Promise<GuildChannel>}
       */
      create(options) {
        return this.guild.channels.create({
          ...options,
          parent: this.channel.id
        });
      }
    };
    module2.exports = CategoryChannelChildManager;
  }
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS({
  "node_modules/discord.js/src/structures/CategoryChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var CategoryChannelChildManager = require_CategoryChannelChildManager();
    var CategoryChannel = class extends GuildChannel {
      /**
       * The id of the parent of this channel.
       * @name CategoryChannel#parentId
       * @type {null}
       */
      /**
       * The parent of this channel.
       * @name CategoryChannel#parent
       * @type {null}
       * @readonly
       */
      /**
       * Sets the category parent of this channel.
       * <warn>It is not possible to set the parent of a CategoryChannel.</warn>
       * @method setParent
       * @memberof CategoryChannel
       * @instance
       * @param {?CategoryChannelResolvable} channel The channel to set as parent
       * @param {SetParentOptions} [options={}] The options for setting the parent
       * @returns {Promise<GuildChannel>}
       */
      /**
       * A manager of the channels belonging to this category
       * @type {CategoryChannelChildManager}
       * @readonly
       */
      get children() {
        return new CategoryChannelChildManager(this);
      }
    };
    module2.exports = CategoryChannel;
  }
});

// browser-external:node:timers
var require_node_timers = __commonJS({
  "browser-external:node:timers"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:timers" has been externalized for browser compatibility. Cannot access "node:timers.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/Collector.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist6();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { flatten } = require_Util();
    var Collector = class extends EventEmitter {
      constructor(client, options = {}) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.filter = options.filter ?? (() => true);
        this.options = options;
        this.collected = new Collection2();
        this.ended = false;
        this._timeout = null;
        this._idletimeout = null;
        this._endReason = null;
        if (typeof this.filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options.filter", "function");
        }
        this.handleCollect = this.handleCollect.bind(this);
        this.handleDispose = this.handleDispose.bind(this);
        if (options.time)
          this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
        if (options.idle)
          this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
        this.lastCollectedTimestamp = null;
      }
      /**
       * The Date at which this collector last collected an item
       * @type {?Date}
       */
      get lastCollectedAt() {
        return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
      }
      /**
       * Call this to handle an event as a collectable element. Accepts any event data as parameters.
       * @param {...*} args The arguments emitted by the listener
       * @returns {Promise<void>}
       * @emits Collector#collect
       */
      async handleCollect(...args) {
        const collectedId = await this.collect(...args);
        if (collectedId) {
          const filterResult = await this.filter(...args, this.collected);
          if (filterResult) {
            this.collected.set(collectedId, args[0]);
            this.emit("collect", ...args);
            this.lastCollectedTimestamp = Date.now();
            if (this._idletimeout) {
              clearTimeout2(this._idletimeout);
              this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
            }
          } else {
            this.emit("ignore", ...args);
          }
        }
        this.checkEnd();
      }
      /**
       * Call this to remove an element from the collection. Accepts any event data as parameters.
       * @param {...*} args The arguments emitted by the listener
       * @returns {Promise<void>}
       * @emits Collector#dispose
       */
      async handleDispose(...args) {
        if (!this.options.dispose)
          return;
        const dispose = this.dispose(...args);
        if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
          return;
        this.collected.delete(dispose);
        this.emit("dispose", ...args);
        this.checkEnd();
      }
      /**
       * Returns a promise that resolves with the next collected element;
       * rejects with collected elements if the collector finishes without receiving a next element
       * @type {Promise}
       * @readonly
       */
      get next() {
        return new Promise((resolve, reject) => {
          if (this.ended) {
            reject(this.collected);
            return;
          }
          const cleanup = () => {
            this.removeListener("collect", onCollect);
            this.removeListener("end", onEnd);
          };
          const onCollect = (item) => {
            cleanup();
            resolve(item);
          };
          const onEnd = () => {
            cleanup();
            reject(this.collected);
          };
          this.on("collect", onCollect);
          this.on("end", onEnd);
        });
      }
      /**
       * Stops this collector and emits the `end` event.
       * @param {string} [reason='user'] The reason this collector is ending
       * @emits Collector#end
       */
      stop(reason = "user") {
        if (this.ended)
          return;
        if (this._timeout) {
          clearTimeout2(this._timeout);
          this._timeout = null;
        }
        if (this._idletimeout) {
          clearTimeout2(this._idletimeout);
          this._idletimeout = null;
        }
        this._endReason = reason;
        this.ended = true;
        this.emit("end", this.collected, reason);
      }
      /**
       * Options used to reset the timeout and idle timer of a {@link Collector}.
       * @typedef {Object} CollectorResetTimerOptions
       * @property {number} [time] How long to run the collector for (in milliseconds)
       * @property {number} [idle] How long to wait to stop the collector after inactivity (in milliseconds)
       */
      /**
       * Resets the collector's timeout and idle timer.
       * @param {CollectorResetTimerOptions} [options] Options for resetting
       */
      resetTimer({ time, idle } = {}) {
        if (this._timeout) {
          clearTimeout2(this._timeout);
          this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
        }
        if (this._idletimeout) {
          clearTimeout2(this._idletimeout);
          this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
        }
      }
      /**
       * Checks whether the collector should end, and if so, ends it.
       * @returns {boolean} Whether the collector ended or not
       */
      checkEnd() {
        const reason = this.endReason;
        if (reason)
          this.stop(reason);
        return Boolean(reason);
      }
      /**
       * Allows collectors to be consumed with for-await-of loops
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}
       */
      async *[Symbol.asyncIterator]() {
        const queue = [];
        const onCollect = (...item) => queue.push(item);
        this.on("collect", onCollect);
        try {
          while (queue.length || !this.ended) {
            if (queue.length) {
              yield queue.shift();
            } else {
              await new Promise((resolve) => {
                const tick = () => {
                  this.removeListener("collect", tick);
                  this.removeListener("end", tick);
                  return resolve();
                };
                this.on("collect", tick);
                this.on("end", tick);
              });
            }
          }
        } finally {
          this.removeListener("collect", onCollect);
        }
      }
      toJSON() {
        return flatten(this);
      }
      /* eslint-disable no-empty-function */
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        return this._endReason;
      }
      /**
       * Handles incoming events from the `handleCollect` function. Returns null if the event should not
       * be collected, or returns an object describing the data that should be stored.
       * @see Collector#handleCollect
       * @param {...*} args Any args the event listener emits
       * @returns {?(*|Promise<?*>)} Data to insert into collection, if any
       * @abstract
       */
      collect() {
      }
      /**
       * Handles incoming events from the `handleDispose`. Returns null if the event should not
       * be disposed, or returns the key that should be removed.
       * @see Collector#handleDispose
       * @param {...*} args Any args the event listener emits
       * @returns {?*} Key to remove from the collection, if any
       * @abstract
       */
      dispose() {
      }
      /* eslint-enable no-empty-function */
    };
    module2.exports = Collector;
  }
});

// node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS({
  "node_modules/discord.js/src/structures/InteractionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Collector = require_Collector();
    var Events2 = require_Events();
    var InteractionCollector = class extends Collector {
      /**
       * @param {Client} client The client on which to collect interactions
       * @param {InteractionCollectorOptions} [options={}] The options to apply to this collector
       */
      constructor(client, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        super(client, options);
        this.messageId = ((_a = options.message) == null ? void 0 : _a.id) ?? ((_c = (_b = options.interactionResponse) == null ? void 0 : _b.interaction.message) == null ? void 0 : _c.id) ?? null;
        this.messageInteractionId = ((_d = options.interactionResponse) == null ? void 0 : _d.id) ?? null;
        this.channelId = ((_e = options.interactionResponse) == null ? void 0 : _e.interaction.channelId) ?? ((_f = options.message) == null ? void 0 : _f.channelId) ?? ((_g = options.message) == null ? void 0 : _g.channel_id) ?? this.client.channels.resolveId(options.channel);
        this.guildId = ((_h = options.interactionResponse) == null ? void 0 : _h.interaction.guildId) ?? ((_i = options.message) == null ? void 0 : _i.guildId) ?? ((_j = options.message) == null ? void 0 : _j.guild_id) ?? this.client.guilds.resolveId((_k = options.channel) == null ? void 0 : _k.guild) ?? this.client.guilds.resolveId(options.guild);
        this.interactionType = options.interactionType ?? null;
        this.componentType = options.componentType ?? null;
        this.users = new Collection2();
        this.total = 0;
        this.client.incrementMaxListeners();
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.messageId))
            this.stop("messageDelete");
        };
        if (this.messageId || this.messageInteractionId) {
          this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
          this.client.on(Events2.MessageDelete, this._handleMessageDeletion);
          this.client.on(Events2.MessageBulkDelete, bulkDeleteListener);
        }
        if (this.channelId) {
          this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
          this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
          this.client.on(Events2.ChannelDelete, this._handleChannelDeletion);
          this.client.on(Events2.ThreadDelete, this._handleThreadDeletion);
        }
        if (this.guildId) {
          this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
          this.client.on(Events2.GuildDelete, this._handleGuildDeletion);
        }
        this.client.on(Events2.InteractionCreate, this.handleCollect);
        this.once("end", () => {
          this.client.removeListener(Events2.InteractionCreate, this.handleCollect);
          this.client.removeListener(Events2.MessageDelete, this._handleMessageDeletion);
          this.client.removeListener(Events2.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events2.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events2.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events2.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (interaction) => {
          this.total++;
          this.users.set(interaction.user.id, interaction.user);
        });
      }
      /**
       * Handles an incoming interaction for possible collection.
       * @param {BaseInteraction} interaction The interaction to possibly collect
       * @returns {?Snowflake}
       * @private
       */
      collect(interaction) {
        var _a, _b, _c;
        if (this.interactionType && interaction.type !== this.interactionType)
          return null;
        if (this.componentType && interaction.componentType !== this.componentType)
          return null;
        if (this.messageId && ((_a = interaction.message) == null ? void 0 : _a.id) !== this.messageId)
          return null;
        if (this.messageInteractionId && ((_c = (_b = interaction.message) == null ? void 0 : _b.interaction) == null ? void 0 : _c.id) && interaction.message.interaction.id !== this.messageInteractionId) {
          return null;
        }
        if (this.channelId && interaction.channelId !== this.channelId)
          return null;
        if (this.guildId && interaction.guildId !== this.guildId)
          return null;
        return interaction.id;
      }
      /**
       * Handles an interaction for possible disposal.
       * @param {BaseInteraction} interaction The interaction that could be disposed of
       * @returns {?Snowflake}
       */
      dispose(interaction) {
        var _a, _b, _c;
        if (this.type && interaction.type !== this.type)
          return null;
        if (this.componentType && interaction.componentType !== this.componentType)
          return null;
        if (this.messageId && ((_a = interaction.message) == null ? void 0 : _a.id) !== this.messageId)
          return null;
        if (this.messageInteractionId && ((_c = (_b = interaction.message) == null ? void 0 : _b.interaction) == null ? void 0 : _c.id) && interaction.message.interaction.id !== this.messageInteractionId) {
          return null;
        }
        if (this.channelId && interaction.channelId !== this.channelId)
          return null;
        if (this.guildId && interaction.guildId !== this.guildId)
          return null;
        return interaction.id;
      }
      /**
       * Empties this interaction collector.
       */
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.total >= this.options.max)
          return "limit";
        if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
          return "componentLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
          return "userLimit";
        return super.endReason;
      }
      /**
       * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.
       * @private
       * @param {Message} message The message that was deleted
       * @returns {void}
       */
      _handleMessageDeletion(message) {
        var _a;
        if (message.id === this.messageId) {
          this.stop("messageDelete");
        }
        if (((_a = message.interaction) == null ? void 0 : _a.id) === this.messageInteractionId) {
          this.stop("messageDelete");
        }
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        var _a;
        if (channel.id === this.channelId || ((_a = channel.threads) == null ? void 0 : _a.cache.has(this.channelId))) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.channelId) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        if (guild.id === this.guildId) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = InteractionCollector;
  }
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS({
  "node_modules/discord.js/src/structures/MessageCollector.js"(exports2, module2) {
    "use strict";
    var Collector = require_Collector();
    var Events2 = require_Events();
    var MessageCollector = class extends Collector {
      /**
       * @param {TextBasedChannels} channel The channel
       * @param {MessageCollectorOptions} options The options to be applied to this collector
       * @emits MessageCollector#message
       */
      constructor(channel, options = {}) {
        super(channel.client, options);
        this.channel = channel;
        this.received = 0;
        const bulkDeleteListener = (messages) => {
          for (const message of messages.values())
            this.handleDispose(message);
        };
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.incrementMaxListeners();
        this.client.on(Events2.MessageCreate, this.handleCollect);
        this.client.on(Events2.MessageDelete, this.handleDispose);
        this.client.on(Events2.MessageBulkDelete, bulkDeleteListener);
        this.client.on(Events2.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events2.ThreadDelete, this._handleThreadDeletion);
        this.client.on(Events2.GuildDelete, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events2.MessageCreate, this.handleCollect);
          this.client.removeListener(Events2.MessageDelete, this.handleDispose);
          this.client.removeListener(Events2.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events2.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events2.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events2.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
      }
      /**
       * Handles a message for possible collection.
       * @param {Message} message The message that could be collected
       * @returns {?Snowflake}
       * @private
       */
      collect(message) {
        if (message.channelId !== this.channel.id)
          return null;
        this.received++;
        return message.id;
      }
      /**
       * Handles a message for possible disposal.
       * @param {Message} message The message that could be disposed of
       * @returns {?Snowflake}
       */
      dispose(message) {
        return message.channelId === this.channel.id ? message.id : null;
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.collected.size >= this.options.max)
          return "limit";
        if (this.options.maxProcessed && this.received === this.options.maxProcessed)
          return "processedLimit";
        return super.endReason;
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.channel.id) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        var _a;
        if (guild.id === ((_a = this.channel.guild) == null ? void 0 : _a.id)) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = MessageCollector;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS({
  "node_modules/fast-deep-equal/es6/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          for (i of a.entries())
            if (!equal(i[1], b.get(i[0])))
              return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  "node_modules/lodash/uniqWith.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniqWith(array, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    module2.exports = uniqWith;
  }
});

// node_modules/@sapphire/shapeshift/dist/cjs/index.cjs
var require_cjs2 = __commonJS({
  "node_modules/@sapphire/shapeshift/dist/cjs/index.cjs"(exports2) {
    "use strict";
    var get = require_get();
    var util = require_util();
    var fastDeepEqual = require_es6();
    var uniqWith = require_uniqWith();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var get__default = _interopDefault(get);
    var fastDeepEqual__default = _interopDefault(fastDeepEqual);
    var uniqWith__default = _interopDefault(uniqWith);
    var __defProp = Object.defineProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var validationEnabled = true;
    function setGlobalValidationEnabled(enabled) {
      validationEnabled = enabled;
    }
    __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
    function getGlobalValidationEnabled() {
      return validationEnabled;
    }
    __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
    var _Result = class _Result2 {
      constructor(success, value, error) {
        this.success = success;
        if (success) {
          this.value = value;
        } else {
          this.error = error;
        }
      }
      isOk() {
        return this.success;
      }
      isErr() {
        return !this.success;
      }
      unwrap() {
        if (this.isOk())
          return this.value;
        throw this.error;
      }
      static ok(value) {
        return new _Result2(true, value);
      }
      static err(error) {
        return new _Result2(false, void 0, error);
      }
    };
    __name(_Result, "Result");
    var Result = _Result;
    function getValue(valueOrFn) {
      return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
    }
    __name(getValue, "getValue");
    var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
    var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
    var _BaseError = class _BaseError extends Error {
      [customInspectSymbol](depth, options) {
        return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
      }
    };
    __name(_BaseError, "BaseError");
    var BaseError = _BaseError;
    var _BaseConstraintError = class _BaseConstraintError extends BaseError {
      constructor(constraint, message, given) {
        super(message);
        this.constraint = constraint;
        this.given = given;
      }
    };
    __name(_BaseConstraintError, "BaseConstraintError");
    var BaseConstraintError = _BaseConstraintError;
    var _ExpectedConstraintError = class _ExpectedConstraintError extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(_ExpectedConstraintError, "ExpectedConstraintError");
    var ExpectedConstraintError = _ExpectedConstraintError;
    function whenConstraint(key, options, validator) {
      return {
        run(input, parent) {
          if (!parent) {
            return Result.err(new ExpectedConstraintError("s.object(T.when)", "Validator has no parent", parent, "Validator to have a parent"));
          }
          const isKeyArray = Array.isArray(key);
          const value = isKeyArray ? key.map((k) => get__default.default(parent, k)) : get__default.default(parent, key);
          const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
          if (predicate) {
            return predicate(validator).run(input);
          }
          return Result.ok(input);
        }
      };
    }
    __name(whenConstraint, "whenConstraint");
    function resolveBooleanIs(options, value, isKeyArray) {
      if (options.is === void 0) {
        return isKeyArray ? !value.some((val) => !val) : Boolean(value);
      }
      if (typeof options.is === "function") {
        return options.is(value);
      }
      return value === options.is;
    }
    __name(resolveBooleanIs, "resolveBooleanIs");
    var _BaseValidator = class _BaseValidator {
      constructor(constraints = []) {
        this.constraints = [];
        this.isValidationEnabled = null;
        this.constraints = constraints;
      }
      setParent(parent) {
        this.parent = parent;
        return this;
      }
      get optional() {
        return new UnionValidator([new LiteralValidator(void 0), this.clone()]);
      }
      get nullable() {
        return new UnionValidator([new LiteralValidator(null), this.clone()]);
      }
      get nullish() {
        return new UnionValidator([new NullishValidator(), this.clone()]);
      }
      get array() {
        return new ArrayValidator(this.clone());
      }
      get set() {
        return new SetValidator(this.clone());
      }
      or(...predicates) {
        return new UnionValidator([this.clone(), ...predicates]);
      }
      transform(cb) {
        return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
      }
      reshape(cb) {
        return this.addConstraint({ run: cb });
      }
      default(value) {
        return new DefaultValidator(this.clone(), value);
      }
      when(key, options) {
        return this.addConstraint(whenConstraint(key, options, this));
      }
      describe(description) {
        const clone = this.clone();
        clone.description = description;
        return clone;
      }
      run(value) {
        let result = this.handle(value);
        if (result.isErr())
          return result;
        for (const constraint of this.constraints) {
          result = constraint.run(result.value, this.parent);
          if (result.isErr())
            break;
        }
        return result;
      }
      parse(value) {
        if (!this.shouldRunConstraints) {
          return this.handle(value).unwrap();
        }
        return this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());
      }
      is(value) {
        return this.run(value).isOk();
      }
      /**
       * Sets if the validator should also run constraints or just do basic checks.
       * @param isValidationEnabled Whether this validator should be enabled or disabled. You can pass boolean or a function returning boolean which will be called just before parsing.
       * Set to `null` to go off of the global configuration.
       */
      setValidationEnabled(isValidationEnabled) {
        const clone = this.clone();
        clone.isValidationEnabled = isValidationEnabled;
        return clone;
      }
      getValidationEnabled() {
        return getValue(this.isValidationEnabled);
      }
      get shouldRunConstraints() {
        return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
      }
      clone() {
        const clone = Reflect.construct(this.constructor, [this.constraints]);
        clone.isValidationEnabled = this.isValidationEnabled;
        return clone;
      }
      addConstraint(constraint) {
        const clone = this.clone();
        clone.constraints = clone.constraints.concat(constraint);
        return clone;
      }
    };
    __name(_BaseValidator, "BaseValidator");
    var BaseValidator = _BaseValidator;
    function isUnique(input) {
      if (input.length < 2)
        return true;
      const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
      return uniqueArray2.length === input.length;
    }
    __name(isUnique, "isUnique");
    function lessThan(a, b) {
      return a < b;
    }
    __name(lessThan, "lessThan");
    function lessThanOrEqual(a, b) {
      return a <= b;
    }
    __name(lessThanOrEqual, "lessThanOrEqual");
    function greaterThan(a, b) {
      return a > b;
    }
    __name(greaterThan, "greaterThan");
    function greaterThanOrEqual(a, b) {
      return a >= b;
    }
    __name(greaterThanOrEqual, "greaterThanOrEqual");
    function equal(a, b) {
      return a === b;
    }
    __name(equal, "equal");
    function notEqual(a, b) {
      return a !== b;
    }
    __name(notEqual, "notEqual");
    function arrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthComparator, "arrayLengthComparator");
    function arrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
    }
    __name(arrayLengthLessThan, "arrayLengthLessThan");
    function arrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
    }
    __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
    function arrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
    }
    __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
    function arrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
    function arrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
    }
    __name(arrayLengthEqual, "arrayLengthEqual");
    function arrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
    }
    __name(arrayLengthNotEqual, "arrayLengthNotEqual");
    function arrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRange, "arrayLengthRange");
    function arrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
    function arrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
    var uniqueArray = {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique", "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
    var _CombinedPropertyError = class _CombinedPropertyError2 extends BaseError {
      constructor(errors) {
        super("Received one or more errors");
        this.errors = errors;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedPropertyError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors = this.errors.map(([key, error]) => {
          const property = _CombinedPropertyError2.formatProperty(key, options);
          const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  input${property}${padding}${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors}`;
      }
      static formatProperty(key, options) {
        if (typeof key === "string")
          return options.stylize(`.${key}`, "symbol");
        if (typeof key === "number")
          return `[${options.stylize(key.toString(), "number")}]`;
        return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
      }
    };
    __name(_CombinedPropertyError, "CombinedPropertyError");
    var CombinedPropertyError = _CombinedPropertyError;
    var _ValidationError = class _ValidationError extends BaseError {
      constructor(validator, message, given) {
        super(message);
        this.validator = validator;
        this.given = given;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(_ValidationError, "ValidationError");
    var ValidationError = _ValidationError;
    var _ArrayValidator = class _ArrayValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      lengthLessThan(length) {
        return this.addConstraint(arrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(arrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(arrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(arrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(arrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(arrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
      }
      get unique() {
        return this.addConstraint(uniqueArray);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = [];
        for (let i = 0; i < values.length; i++) {
          const result = this.validator.run(values[i]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors.push([i, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(_ArrayValidator, "ArrayValidator");
    var ArrayValidator = _ArrayValidator;
    function bigintComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
        }
      };
    }
    __name(bigintComparator, "bigintComparator");
    function bigintLessThan(value) {
      const expected = `expected < ${value}n`;
      return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
    }
    __name(bigintLessThan, "bigintLessThan");
    function bigintLessThanOrEqual(value) {
      const expected = `expected <= ${value}n`;
      return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
    }
    __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
    function bigintGreaterThan(value) {
      const expected = `expected > ${value}n`;
      return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
    }
    __name(bigintGreaterThan, "bigintGreaterThan");
    function bigintGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}n`;
      return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
    }
    __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
    function bigintEqual(value) {
      const expected = `expected === ${value}n`;
      return bigintComparator(equal, "s.bigint.equal", expected, value);
    }
    __name(bigintEqual, "bigintEqual");
    function bigintNotEqual(value) {
      const expected = `expected !== ${value}n`;
      return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
    }
    __name(bigintNotEqual, "bigintNotEqual");
    function bigintDivisibleBy(divider) {
      const expected = `expected % ${divider}n === 0n`;
      return {
        run(input) {
          return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
        }
      };
    }
    __name(bigintDivisibleBy, "bigintDivisibleBy");
    var _BigIntValidator = class _BigIntValidator extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(bigintLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(bigintLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(bigintGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(bigintGreaterThanOrEqual(number));
      }
      equal(number) {
        return this.addConstraint(bigintEqual(number));
      }
      notEqual(number) {
        return this.addConstraint(bigintNotEqual(number));
      }
      get positive() {
        return this.greaterThanOrEqual(0n);
      }
      get negative() {
        return this.lessThan(0n);
      }
      divisibleBy(number) {
        return this.addConstraint(bigintDivisibleBy(number));
      }
      get abs() {
        return this.transform((value) => value < 0 ? -value : value);
      }
      intN(bits) {
        return this.transform((value) => BigInt.asIntN(bits, value));
      }
      uintN(bits) {
        return this.transform((value) => BigInt.asUintN(bits, value));
      }
      handle(value) {
        return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
      }
    };
    __name(_BigIntValidator, "BigIntValidator");
    var BigIntValidator = _BigIntValidator;
    var booleanTrue = {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
      }
    };
    var booleanFalse = {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
    var _BooleanValidator = class _BooleanValidator extends BaseValidator {
      get true() {
        return this.addConstraint(booleanTrue);
      }
      get false() {
        return this.addConstraint(booleanFalse);
      }
      equal(value) {
        return value ? this.true : this.false;
      }
      notEqual(value) {
        return value ? this.false : this.true;
      }
      handle(value) {
        return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
      }
    };
    __name(_BooleanValidator, "BooleanValidator");
    var BooleanValidator = _BooleanValidator;
    function dateComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
        }
      };
    }
    __name(dateComparator, "dateComparator");
    function dateLessThan(value) {
      const expected = `expected < ${value.toISOString()}`;
      return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
    }
    __name(dateLessThan, "dateLessThan");
    function dateLessThanOrEqual(value) {
      const expected = `expected <= ${value.toISOString()}`;
      return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
    }
    __name(dateLessThanOrEqual, "dateLessThanOrEqual");
    function dateGreaterThan(value) {
      const expected = `expected > ${value.toISOString()}`;
      return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
    }
    __name(dateGreaterThan, "dateGreaterThan");
    function dateGreaterThanOrEqual(value) {
      const expected = `expected >= ${value.toISOString()}`;
      return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
    }
    __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
    function dateEqual(value) {
      const expected = `expected === ${value.toISOString()}`;
      return dateComparator(equal, "s.date.equal", expected, value.getTime());
    }
    __name(dateEqual, "dateEqual");
    function dateNotEqual(value) {
      const expected = `expected !== ${value.toISOString()}`;
      return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
    }
    __name(dateNotEqual, "dateNotEqual");
    var dateInvalid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
      }
    };
    var dateValid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    var _DateValidator = class _DateValidator extends BaseValidator {
      lessThan(date) {
        return this.addConstraint(dateLessThan(new Date(date)));
      }
      lessThanOrEqual(date) {
        return this.addConstraint(dateLessThanOrEqual(new Date(date)));
      }
      greaterThan(date) {
        return this.addConstraint(dateGreaterThan(new Date(date)));
      }
      greaterThanOrEqual(date) {
        return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
      }
      equal(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
      }
      notEqual(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
      }
      get valid() {
        return this.addConstraint(dateValid);
      }
      get invalid() {
        return this.addConstraint(dateInvalid);
      }
      handle(value) {
        return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
      }
    };
    __name(_DateValidator, "DateValidator");
    var DateValidator = _DateValidator;
    var _ExpectedValidationError = class _ExpectedValidationError extends ValidationError {
      constructor(validator, message, given, expected) {
        super(validator, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const expected = util.inspect(this.expected, newOptions).replace(/\n/g, padding);
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(_ExpectedValidationError, "ExpectedValidationError");
    var ExpectedValidationError = _ExpectedValidationError;
    var _InstanceValidator = class _InstanceValidator extends BaseValidator {
      constructor(expected, constraints = []) {
        super(constraints);
        this.expected = expected;
      }
      handle(value) {
        return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(_InstanceValidator, "InstanceValidator");
    var InstanceValidator = _InstanceValidator;
    var _LiteralValidator = class _LiteralValidator extends BaseValidator {
      constructor(literal, constraints = []) {
        super(constraints);
        this.expected = literal;
      }
      handle(value) {
        return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(_LiteralValidator, "LiteralValidator");
    var LiteralValidator = _LiteralValidator;
    var _NeverValidator = class _NeverValidator extends BaseValidator {
      handle(value) {
        return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
      }
    };
    __name(_NeverValidator, "NeverValidator");
    var NeverValidator = _NeverValidator;
    var _NullishValidator = class _NullishValidator extends BaseValidator {
      handle(value) {
        return value === void 0 || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
      }
    };
    __name(_NullishValidator, "NullishValidator");
    var NullishValidator = _NullishValidator;
    function numberComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
        }
      };
    }
    __name(numberComparator, "numberComparator");
    function numberLessThan(value) {
      const expected = `expected < ${value}`;
      return numberComparator(lessThan, "s.number.lessThan", expected, value);
    }
    __name(numberLessThan, "numberLessThan");
    function numberLessThanOrEqual(value) {
      const expected = `expected <= ${value}`;
      return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
    }
    __name(numberLessThanOrEqual, "numberLessThanOrEqual");
    function numberGreaterThan(value) {
      const expected = `expected > ${value}`;
      return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
    }
    __name(numberGreaterThan, "numberGreaterThan");
    function numberGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}`;
      return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
    }
    __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
    function numberEqual(value) {
      const expected = `expected === ${value}`;
      return numberComparator(equal, "s.number.equal", expected, value);
    }
    __name(numberEqual, "numberEqual");
    function numberNotEqual(value) {
      const expected = `expected !== ${value}`;
      return numberComparator(notEqual, "s.number.notEqual", expected, value);
    }
    __name(numberNotEqual, "numberNotEqual");
    var numberInt = {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true")
        );
      }
    };
    var numberSafeInt = {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError(
            "s.number.safeInt",
            "Given value is not a safe integer",
            input,
            "Number.isSafeInteger(expected) to be true"
          )
        );
      }
    };
    var numberFinite = {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
    var numberNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
      }
    };
    var numberNotNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    function numberDivisibleBy(divider) {
      const expected = `expected % ${divider} === 0`;
      return {
        run(input) {
          return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
        }
      };
    }
    __name(numberDivisibleBy, "numberDivisibleBy");
    var _NumberValidator = class _NumberValidator extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(numberLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(numberLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(numberGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(numberGreaterThanOrEqual(number));
      }
      equal(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
      }
      notEqual(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
      }
      get int() {
        return this.addConstraint(numberInt);
      }
      get safeInt() {
        return this.addConstraint(numberSafeInt);
      }
      get finite() {
        return this.addConstraint(numberFinite);
      }
      get positive() {
        return this.greaterThanOrEqual(0);
      }
      get negative() {
        return this.lessThan(0);
      }
      divisibleBy(divider) {
        return this.addConstraint(numberDivisibleBy(divider));
      }
      get abs() {
        return this.transform(Math.abs);
      }
      get sign() {
        return this.transform(Math.sign);
      }
      get trunc() {
        return this.transform(Math.trunc);
      }
      get floor() {
        return this.transform(Math.floor);
      }
      get fround() {
        return this.transform(Math.fround);
      }
      get round() {
        return this.transform(Math.round);
      }
      get ceil() {
        return this.transform(Math.ceil);
      }
      handle(value) {
        return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
      }
    };
    __name(_NumberValidator, "NumberValidator");
    var NumberValidator = _NumberValidator;
    var _MissingPropertyError = class _MissingPropertyError extends BaseError {
      constructor(property) {
        super("A required property is missing");
        this.property = property;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[MissingPropertyError: ${property}]`, "special");
        }
        const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        return `${header}
  ${message}`;
      }
    };
    __name(_MissingPropertyError, "MissingPropertyError");
    var MissingPropertyError = _MissingPropertyError;
    var _UnknownPropertyError = class _UnknownPropertyError extends BaseError {
      constructor(property, value) {
        super("Received unexpected property");
        this.property = property;
        this.value = value;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property,
          value: this.value
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util.inspect(this.value, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(_UnknownPropertyError, "UnknownPropertyError");
    var UnknownPropertyError = _UnknownPropertyError;
    var _DefaultValidator = class _DefaultValidator extends BaseValidator {
      constructor(validator, value, constraints = []) {
        super(constraints);
        this.validator = validator;
        this.defaultValue = value;
      }
      default(value) {
        const clone = this.clone();
        clone.defaultValue = value;
        return clone;
      }
      handle(value) {
        return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);
      }
    };
    __name(_DefaultValidator, "DefaultValidator");
    var DefaultValidator = _DefaultValidator;
    var _CombinedError = class _CombinedError extends BaseError {
      constructor(errors) {
        super("Received one or more errors");
        this.errors = errors;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors = this.errors.map((error, i) => {
          const index = options.stylize((i + 1).toString(), "number");
          const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  ${index} ${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors}`;
      }
    };
    __name(_CombinedError, "CombinedError");
    var CombinedError = _CombinedError;
    var _UnionValidator = class _UnionValidator2 extends BaseValidator {
      constructor(validators, constraints = []) {
        super(constraints);
        this.validators = validators;
      }
      get optional() {
        if (this.validators.length === 0)
          return new _UnionValidator2([new LiteralValidator(void 0)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return this.clone();
          if (validator.expected === null) {
            return new _UnionValidator2(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new _UnionValidator2([new LiteralValidator(void 0), ...this.validators]);
      }
      get required() {
        if (this.validators.length === 0)
          return this.clone();
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return new _UnionValidator2(this.validators.slice(1), this.constraints);
        } else if (validator instanceof NullishValidator) {
          return new _UnionValidator2([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);
        }
        return this.clone();
      }
      get nullable() {
        if (this.validators.length === 0)
          return new _UnionValidator2([new LiteralValidator(null)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null)
            return this.clone();
          if (validator.expected === void 0) {
            return new _UnionValidator2(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new _UnionValidator2([new LiteralValidator(null), ...this.validators]);
      }
      get nullish() {
        if (this.validators.length === 0)
          return new _UnionValidator2([new NullishValidator()], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null || validator.expected === void 0) {
            return new _UnionValidator2([new NullishValidator(), ...this.validators.slice(1)], this.constraints);
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new _UnionValidator2([new NullishValidator(), ...this.validators]);
      }
      or(...predicates) {
        return new _UnionValidator2([...this.validators, ...predicates]);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(value) {
        const errors = [];
        for (const validator of this.validators) {
          const result = validator.run(value);
          if (result.isOk())
            return result;
          errors.push(result.error);
        }
        return Result.err(new CombinedError(errors));
      }
    };
    __name(_UnionValidator, "UnionValidator");
    var UnionValidator = _UnionValidator;
    var _ObjectValidator = class _ObjectValidator2 extends BaseValidator {
      constructor(shape, strategy = 0, constraints = []) {
        super(constraints);
        this.keys = [];
        this.requiredKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */ new Map();
        this.shape = shape;
        this.strategy = strategy;
        switch (this.strategy) {
          case 0:
            this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
            break;
          case 1: {
            this.handleStrategy = (value) => this.handleStrictStrategy(value);
            break;
          }
          case 2:
            this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
            break;
        }
        const shapeEntries = Object.entries(shape);
        this.keys = shapeEntries.map(([key]) => key);
        for (const [key, validator] of shapeEntries) {
          if (validator instanceof UnionValidator) {
            const [possiblyLiteralOrNullishPredicate] = validator["validators"];
            if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
              if (possiblyLiteralOrNullishPredicate.expected === void 0) {
                this.possiblyUndefinedKeys.set(key, validator);
              } else {
                this.requiredKeys.set(key, validator);
              }
            } else if (validator instanceof DefaultValidator) {
              this.possiblyUndefinedKeysWithDefaults.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (validator instanceof LiteralValidator) {
            if (validator.expected === void 0) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        }
      }
      get strict() {
        return Reflect.construct(this.constructor, [this.shape, 1, this.constraints]);
      }
      get ignore() {
        return Reflect.construct(this.constructor, [this.shape, 0, this.constraints]);
      }
      get passthrough() {
        return Reflect.construct(this.constructor, [this.shape, 2, this.constraints]);
      }
      get partial() {
        const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      get required() {
        const shape = Object.fromEntries(
          this.keys.map((key) => {
            let validator = this.shape[key];
            if (validator instanceof UnionValidator)
              validator = validator.required;
            return [key, validator];
          })
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      extend(schema) {
        const shape = { ...this.shape, ...schema instanceof _ObjectValidator2 ? schema.shape : schema };
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      pick(keys) {
        const shape = Object.fromEntries(
          keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      omit(keys) {
        const shape = Object.fromEntries(
          this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue !== "object") {
          return Result.err(new ValidationError("s.object(T)", `Expected the value to be an object, but received ${typeOfValue} instead`, value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        for (const predicate of Object.values(this.shape)) {
          predicate.setParent(this.parent ?? value);
        }
        return this.handleStrategy(value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);
      }
      handleIgnoreStrategy(value) {
        const errors = [];
        const finalObject = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalObject[key] = result.value;
          } else {
            const error = result.error;
            errors.push([key, error]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        if (inputEntries.size === 0) {
          return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
        }
        const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
        if (checkInputEntriesInsteadOfSchemaKeys) {
          for (const [key] of inputEntries) {
            const predicate = this.possiblyUndefinedKeys.get(key);
            if (predicate) {
              runPredicate(key, predicate);
            }
          }
        } else {
          for (const [key, predicate] of this.possiblyUndefinedKeys) {
            if (inputEntries.delete(key)) {
              runPredicate(key, predicate);
            }
          }
        }
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
      }
      handleStrictStrategy(value) {
        const errors = [];
        const finalResult = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalResult[key] = result.value;
          } else {
            const error = result.error;
            errors.push([key, error]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.size === 0) {
            break;
          }
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
        if (inputEntries.size !== 0) {
          for (const [key, value2] of inputEntries.entries()) {
            errors.push([key, new UnknownPropertyError(key, value2)]);
          }
        }
        return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors));
      }
      handlePassthroughStrategy(value) {
        const result = this.handleIgnoreStrategy(value);
        return result.isErr() ? result : Result.ok({ ...value, ...result.value });
      }
    };
    __name(_ObjectValidator, "ObjectValidator");
    var ObjectValidator = _ObjectValidator;
    var _PassthroughValidator = class _PassthroughValidator extends BaseValidator {
      handle(value) {
        return Result.ok(value);
      }
    };
    __name(_PassthroughValidator, "PassthroughValidator");
    var PassthroughValidator = _PassthroughValidator;
    var _RecordValidator = class _RecordValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(value) {
        if (typeof value !== "object") {
          return Result.err(new ValidationError("s.record(T)", "Expected an object", value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors = [];
        const transformed = {};
        for (const [key, val] of Object.entries(value)) {
          const result = this.validator.run(val);
          if (result.isOk())
            transformed[key] = result.value;
          else
            errors.push([key, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(_RecordValidator, "RecordValidator");
    var RecordValidator = _RecordValidator;
    var _SetValidator = class _SetValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!(values instanceof Set)) {
          return Result.err(new ValidationError("s.set(T)", "Expected a set", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = /* @__PURE__ */ new Set();
        for (const value of values) {
          const result = this.validator.run(value);
          if (result.isOk())
            transformed.add(result.value);
          else
            errors.push(result.error);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors));
      }
    };
    __name(_SetValidator, "SetValidator");
    var SetValidator = _SetValidator;
    var accountRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]$/i;
    function validateEmail(email) {
      if (!email)
        return false;
      const atIndex = email.indexOf("@");
      if (atIndex === -1)
        return false;
      if (atIndex > 64)
        return false;
      const domainIndex = atIndex + 1;
      if (email.includes("@", domainIndex))
        return false;
      if (email.length - domainIndex > 255)
        return false;
      let dotIndex = email.indexOf(".", domainIndex);
      if (dotIndex === -1)
        return false;
      let lastDotIndex = domainIndex;
      do {
        if (dotIndex - lastDotIndex > 63)
          return false;
        lastDotIndex = dotIndex + 1;
      } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
      if (email.length - lastDotIndex > 63)
        return false;
      return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
    }
    __name(validateEmail, "validateEmail");
    function validateEmailDomain(domain) {
      try {
        return new URL(`http://${domain}`).hostname === domain;
      } catch {
        return false;
      }
    }
    __name(validateEmailDomain, "validateEmailDomain");
    var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    var IPv4Reg = new RegExp(`^${v4Str}$`);
    var v6Seg = "(?:[0-9a-fA-F]{1,4})";
    var IPv6Reg = new RegExp(
      `^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`
    );
    function isIPv4(s2) {
      return IPv4Reg.test(s2);
    }
    __name(isIPv4, "isIPv4");
    function isIPv6(s2) {
      return IPv6Reg.test(s2);
    }
    __name(isIPv6, "isIPv6");
    function isIP(s2) {
      if (isIPv4(s2))
        return 4;
      if (isIPv6(s2))
        return 6;
      return 0;
    }
    __name(isIP, "isIP");
    var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
    function validatePhoneNumber(input) {
      return phoneNumberRegex.test(input);
    }
    __name(validatePhoneNumber, "validatePhoneNumber");
    var _MultiplePossibilitiesConstraintError = class _MultiplePossibilitiesConstraintError extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const verticalLine = options.stylize("|", "undefined");
        const padding = `
  ${verticalLine} `;
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedPadding = `
  ${verticalLine} - `;
        const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(_MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
    var MultiplePossibilitiesConstraintError = _MultiplePossibilitiesConstraintError;
    function combinedErrorFn(...fns) {
      switch (fns.length) {
        case 0:
          return () => null;
        case 1:
          return fns[0];
        case 2: {
          const [fn0, fn1] = fns;
          return (...params) => fn0(...params) || fn1(...params);
        }
        default: {
          return (...params) => {
            for (const fn of fns) {
              const result = fn(...params);
              if (result)
                return result;
            }
            return null;
          };
        }
      }
    }
    __name(combinedErrorFn, "combinedErrorFn");
    function createUrlValidators(options) {
      var _a, _b;
      const fns = [];
      if ((_a = options == null ? void 0 : options.allowedProtocols) == null ? void 0 : _a.length)
        fns.push(allowedProtocolsFn(options.allowedProtocols));
      if ((_b = options == null ? void 0 : options.allowedDomains) == null ? void 0 : _b.length)
        fns.push(allowedDomainsFn(options.allowedDomains));
      return combinedErrorFn(...fns);
    }
    __name(createUrlValidators, "createUrlValidators");
    function allowedProtocolsFn(allowedProtocols) {
      return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL protocol", input, allowedProtocols);
    }
    __name(allowedProtocolsFn, "allowedProtocolsFn");
    function allowedDomainsFn(allowedDomains) {
      return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL domain", input, allowedDomains);
    }
    __name(allowedDomainsFn, "allowedDomainsFn");
    function stringLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid string length", input, expected));
        }
      };
    }
    __name(stringLengthComparator, "stringLengthComparator");
    function stringLengthLessThan(length) {
      const expected = `expected.length < ${length}`;
      return stringLengthComparator(lessThan, "s.string.lengthLessThan", expected, length);
    }
    __name(stringLengthLessThan, "stringLengthLessThan");
    function stringLengthLessThanOrEqual(length) {
      const expected = `expected.length <= ${length}`;
      return stringLengthComparator(lessThanOrEqual, "s.string.lengthLessThanOrEqual", expected, length);
    }
    __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
    function stringLengthGreaterThan(length) {
      const expected = `expected.length > ${length}`;
      return stringLengthComparator(greaterThan, "s.string.lengthGreaterThan", expected, length);
    }
    __name(stringLengthGreaterThan, "stringLengthGreaterThan");
    function stringLengthGreaterThanOrEqual(length) {
      const expected = `expected.length >= ${length}`;
      return stringLengthComparator(greaterThanOrEqual, "s.string.lengthGreaterThanOrEqual", expected, length);
    }
    __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
    function stringLengthEqual(length) {
      const expected = `expected.length === ${length}`;
      return stringLengthComparator(equal, "s.string.lengthEqual", expected, length);
    }
    __name(stringLengthEqual, "stringLengthEqual");
    function stringLengthNotEqual(length) {
      const expected = `expected.length !== ${length}`;
      return stringLengthComparator(notEqual, "s.string.lengthNotEqual", expected, length);
    }
    __name(stringLengthNotEqual, "stringLengthNotEqual");
    function stringEmail() {
      return {
        run(input) {
          return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.email", "Invalid email address", input, "expected to be an email address"));
        }
      };
    }
    __name(stringEmail, "stringEmail");
    function stringRegexValidator(type, expected, regex) {
      return {
        run(input) {
          return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, "Invalid string format", input, expected));
        }
      };
    }
    __name(stringRegexValidator, "stringRegexValidator");
    function stringUrl(options) {
      const validatorFn = createUrlValidators(options);
      return {
        run(input) {
          let url;
          try {
            url = new URL(input);
          } catch {
            return Result.err(new ExpectedConstraintError("s.string.url", "Invalid URL", input, "expected to match a URL"));
          }
          const validatorFnResult = validatorFn(input, url);
          if (validatorFnResult === null)
            return Result.ok(input);
          return Result.err(validatorFnResult);
        }
      };
    }
    __name(stringUrl, "stringUrl");
    function stringIp(version) {
      const ipVersion = version ? `v${version}` : "";
      const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
      const name = `s.string.ip${ipVersion}`;
      const message = `Invalid IP${ipVersion} address`;
      const expected = `expected to be an IP${ipVersion} address`;
      return {
        run(input) {
          return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));
        }
      };
    }
    __name(stringIp, "stringIp");
    function stringRegex(regex) {
      return stringRegexValidator("s.string.regex", `expected ${regex}.test(expected) to be true`, regex);
    }
    __name(stringRegex, "stringRegex");
    function stringUuid({ version = 4, nullable = false } = {}) {
      version ?? (version = "1-5");
      const regex = new RegExp(
        `^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})$`,
        "i"
      );
      const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
      return stringRegexValidator("s.string.uuid", expected, regex);
    }
    __name(stringUuid, "stringUuid");
    function stringDate() {
      return {
        run(input) {
          const time = Date.parse(input);
          return Number.isNaN(time) ? Result.err(
            new ExpectedConstraintError(
              "s.string.date",
              "Invalid date string",
              input,
              "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)"
            )
          ) : Result.ok(input);
        }
      };
    }
    __name(stringDate, "stringDate");
    function stringPhone() {
      return {
        run(input) {
          return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.phone", "Invalid phone number", input, "expected to be a phone number"));
        }
      };
    }
    __name(stringPhone, "stringPhone");
    var _StringValidator = class _StringValidator extends BaseValidator {
      lengthLessThan(length) {
        return this.addConstraint(stringLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(stringLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(stringLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(stringLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(stringLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(stringLengthNotEqual(length));
      }
      get email() {
        return this.addConstraint(stringEmail());
      }
      url(options) {
        return this.addConstraint(stringUrl(options));
      }
      uuid(options) {
        return this.addConstraint(stringUuid(options));
      }
      regex(regex) {
        return this.addConstraint(stringRegex(regex));
      }
      get date() {
        return this.addConstraint(stringDate());
      }
      get ipv4() {
        return this.ip(4);
      }
      get ipv6() {
        return this.ip(6);
      }
      ip(version) {
        return this.addConstraint(stringIp(version));
      }
      phone() {
        return this.addConstraint(stringPhone());
      }
      handle(value) {
        return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string", "Expected a string primitive", value));
      }
    };
    __name(_StringValidator, "StringValidator");
    var StringValidator = _StringValidator;
    var _TupleValidator = class _TupleValidator extends BaseValidator {
      constructor(validators, constraints = []) {
        super(constraints);
        this.validators = [];
        this.validators = validators;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.tuple(T)", "Expected an array", values));
        }
        if (values.length !== this.validators.length) {
          return Result.err(new ValidationError("s.tuple(T)", `Expected an array of length ${this.validators.length}`, values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = [];
        for (let i = 0; i < values.length; i++) {
          const result = this.validators[i].run(values[i]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors.push([i, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(_TupleValidator, "TupleValidator");
    var TupleValidator = _TupleValidator;
    var _MapValidator = class _MapValidator extends BaseValidator {
      constructor(keyValidator, valueValidator, constraints = []) {
        super(constraints);
        this.keyValidator = keyValidator;
        this.valueValidator = valueValidator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);
      }
      handle(value) {
        if (!(value instanceof Map)) {
          return Result.err(new ValidationError("s.map(K, V)", "Expected a map", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors = [];
        const transformed = /* @__PURE__ */ new Map();
        for (const [key, val] of value.entries()) {
          const keyResult = this.keyValidator.run(key);
          const valueResult = this.valueValidator.run(val);
          const { length } = errors;
          if (keyResult.isErr())
            errors.push([key, keyResult.error]);
          if (valueResult.isErr())
            errors.push([key, valueResult.error]);
          if (errors.length === length)
            transformed.set(keyResult.value, valueResult.value);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(_MapValidator, "MapValidator");
    var MapValidator = _MapValidator;
    var _LazyValidator = class _LazyValidator extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        return this.validator(values).run(values);
      }
    };
    __name(_LazyValidator, "LazyValidator");
    var LazyValidator = _LazyValidator;
    var _UnknownEnumValueError = class _UnknownEnumValueError extends BaseError {
      constructor(value, keys, enumMappings) {
        super("Expected the value to be one of the following enum values:");
        this.value = value;
        this.enumKeys = keys;
        this.enumMappings = enumMappings;
      }
      toJSON() {
        return {
          name: this.name,
          value: this.value,
          enumKeys: this.enumKeys,
          enumMappings: [...this.enumMappings.entries()]
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const value = options.stylize(this.value.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
        }
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const pairs = this.enumKeys.map((key) => {
          const enumValue = this.enumMappings.get(key);
          return `${options.stylize(key, "string")} or ${options.stylize(
            enumValue.toString(),
            typeof enumValue === "number" ? "number" : "string"
          )}`;
        }).join(padding);
        const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
        const message = options.stylize(this.message, "regexp");
        const pairsBlock = `${padding}${pairs}`;
        return `${header}
  ${message}
${pairsBlock}`;
      }
    };
    __name(_UnknownEnumValueError, "UnknownEnumValueError");
    var UnknownEnumValueError = _UnknownEnumValueError;
    var _NativeEnumValidator = class _NativeEnumValidator extends BaseValidator {
      constructor(enumShape) {
        super();
        this.hasNumericElements = false;
        this.enumMapping = /* @__PURE__ */ new Map();
        this.enumShape = enumShape;
        this.enumKeys = Object.keys(enumShape).filter((key) => {
          return typeof enumShape[enumShape[key]] !== "number";
        });
        for (const key of this.enumKeys) {
          const enumValue = enumShape[key];
          this.enumMapping.set(key, enumValue);
          this.enumMapping.set(enumValue, enumValue);
          if (typeof enumValue === "number") {
            this.hasNumericElements = true;
            this.enumMapping.set(`${enumValue}`, enumValue);
          }
        }
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue === "number") {
          if (!this.hasNumericElements) {
            return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string", value));
          }
        } else if (typeOfValue !== "string") {
          return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string or number", value));
        }
        const casted = value;
        const possibleEnumValue = this.enumMapping.get(casted);
        return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.enumShape]);
      }
    };
    __name(_NativeEnumValidator, "NativeEnumValidator");
    var NativeEnumValidator = _NativeEnumValidator;
    function typedArrayByteLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
    function typedArrayByteLengthLessThan(value) {
      const expected = `expected.byteLength < ${value}`;
      return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan", expected, value);
    }
    __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
    function typedArrayByteLengthLessThanOrEqual(value) {
      const expected = `expected.byteLength <= ${value}`;
      return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
    function typedArrayByteLengthGreaterThan(value) {
      const expected = `expected.byteLength > ${value}`;
      return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan", expected, value);
    }
    __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
    function typedArrayByteLengthGreaterThanOrEqual(value) {
      const expected = `expected.byteLength >= ${value}`;
      return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
    function typedArrayByteLengthEqual(value) {
      const expected = `expected.byteLength === ${value}`;
      return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual", expected, value);
    }
    __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
    function typedArrayByteLengthNotEqual(value) {
      const expected = `expected.byteLength !== ${value}`;
      return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual", expected, value);
    }
    __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
    function typedArrayByteLengthRange(start, endBefore) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange", "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
    function typedArrayByteLengthRangeInclusive(start, end) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
    function typedArrayByteLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
    function typedArrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthComparator, "typedArrayLengthComparator");
    function typedArrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan", expected, value);
    }
    __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
    function typedArrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
    function typedArrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan", expected, value);
    }
    __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
    function typedArrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
    function typedArrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual", expected, value);
    }
    __name(typedArrayLengthEqual, "typedArrayLengthEqual");
    function typedArrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual", expected, value);
    }
    __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
    function typedArrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRange, "typedArrayLengthRange");
    function typedArrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
    function typedArrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
    var vowels = ["a", "e", "i", "o", "u"];
    var aOrAn = __name((word) => {
      return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
    }, "aOrAn");
    var TypedArrays = {
      Int8Array: (x) => x instanceof Int8Array,
      Uint8Array: (x) => x instanceof Uint8Array,
      Uint8ClampedArray: (x) => x instanceof Uint8ClampedArray,
      Int16Array: (x) => x instanceof Int16Array,
      Uint16Array: (x) => x instanceof Uint16Array,
      Int32Array: (x) => x instanceof Int32Array,
      Uint32Array: (x) => x instanceof Uint32Array,
      Float32Array: (x) => x instanceof Float32Array,
      Float64Array: (x) => x instanceof Float64Array,
      BigInt64Array: (x) => x instanceof BigInt64Array,
      BigUint64Array: (x) => x instanceof BigUint64Array,
      TypedArray: (x) => ArrayBuffer.isView(x) && !(x instanceof DataView)
    };
    var _TypedArrayValidator = class _TypedArrayValidator extends BaseValidator {
      constructor(type, constraints = []) {
        super(constraints);
        this.type = type;
      }
      byteLengthLessThan(length) {
        return this.addConstraint(typedArrayByteLengthLessThan(length));
      }
      byteLengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));
      }
      byteLengthGreaterThan(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThan(length));
      }
      byteLengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));
      }
      byteLengthEqual(length) {
        return this.addConstraint(typedArrayByteLengthEqual(length));
      }
      byteLengthNotEqual(length) {
        return this.addConstraint(typedArrayByteLengthNotEqual(length));
      }
      byteLengthRange(start, endBefore) {
        return this.addConstraint(typedArrayByteLengthRange(start, endBefore));
      }
      byteLengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));
      }
      byteLengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));
      }
      lengthLessThan(length) {
        return this.addConstraint(typedArrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(typedArrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(typedArrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(typedArrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(typedArrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.type, this.constraints]);
      }
      handle(value) {
        return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray", `Expected ${aOrAn(this.type)}`, value));
      }
    };
    __name(_TypedArrayValidator, "TypedArrayValidator");
    var TypedArrayValidator = _TypedArrayValidator;
    var _Shapes = class _Shapes {
      get string() {
        return new StringValidator();
      }
      get number() {
        return new NumberValidator();
      }
      get bigint() {
        return new BigIntValidator();
      }
      get boolean() {
        return new BooleanValidator();
      }
      get date() {
        return new DateValidator();
      }
      object(shape) {
        return new ObjectValidator(shape);
      }
      get undefined() {
        return this.literal(void 0);
      }
      get null() {
        return this.literal(null);
      }
      get nullish() {
        return new NullishValidator();
      }
      get any() {
        return new PassthroughValidator();
      }
      get unknown() {
        return new PassthroughValidator();
      }
      get never() {
        return new NeverValidator();
      }
      enum(...values) {
        return this.union(...values.map((value) => this.literal(value)));
      }
      nativeEnum(enumShape) {
        return new NativeEnumValidator(enumShape);
      }
      literal(value) {
        if (value instanceof Date)
          return this.date.equal(value);
        return new LiteralValidator(value);
      }
      instance(expected) {
        return new InstanceValidator(expected);
      }
      union(...validators) {
        return new UnionValidator(validators);
      }
      array(validator) {
        return new ArrayValidator(validator);
      }
      typedArray(type = "TypedArray") {
        return new TypedArrayValidator(type);
      }
      get int8Array() {
        return this.typedArray("Int8Array");
      }
      get uint8Array() {
        return this.typedArray("Uint8Array");
      }
      get uint8ClampedArray() {
        return this.typedArray("Uint8ClampedArray");
      }
      get int16Array() {
        return this.typedArray("Int16Array");
      }
      get uint16Array() {
        return this.typedArray("Uint16Array");
      }
      get int32Array() {
        return this.typedArray("Int32Array");
      }
      get uint32Array() {
        return this.typedArray("Uint32Array");
      }
      get float32Array() {
        return this.typedArray("Float32Array");
      }
      get float64Array() {
        return this.typedArray("Float64Array");
      }
      get bigInt64Array() {
        return this.typedArray("BigInt64Array");
      }
      get bigUint64Array() {
        return this.typedArray("BigUint64Array");
      }
      tuple(validators) {
        return new TupleValidator(validators);
      }
      set(validator) {
        return new SetValidator(validator);
      }
      record(validator) {
        return new RecordValidator(validator);
      }
      map(keyValidator, valueValidator) {
        return new MapValidator(keyValidator, valueValidator);
      }
      lazy(validator) {
        return new LazyValidator(validator);
      }
    };
    __name(_Shapes, "Shapes");
    var Shapes = _Shapes;
    var s = new Shapes();
    exports2.BaseError = BaseError;
    exports2.CombinedError = CombinedError;
    exports2.CombinedPropertyError = CombinedPropertyError;
    exports2.ExpectedConstraintError = ExpectedConstraintError;
    exports2.ExpectedValidationError = ExpectedValidationError;
    exports2.MissingPropertyError = MissingPropertyError;
    exports2.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
    exports2.Result = Result;
    exports2.UnknownEnumValueError = UnknownEnumValueError;
    exports2.UnknownPropertyError = UnknownPropertyError;
    exports2.ValidationError = ValidationError;
    exports2.customInspectSymbol = customInspectSymbol;
    exports2.customInspectSymbolStackLess = customInspectSymbolStackLess;
    exports2.getGlobalValidationEnabled = getGlobalValidationEnabled;
    exports2.s = s;
    exports2.setGlobalValidationEnabled = setGlobalValidationEnabled;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/ts-mixer/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Mixin: () => Mixin,
  decorate: () => decorate,
  hasMixin: () => hasMixin,
  mix: () => mix,
  settings: () => settings
});
function Mixin(...constructors) {
  var _a, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== "none") {
    const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
var copyProps, protoChain, nearestCommonProto, hardMixProtos, unique, getIngredientWithProp, proxyMix, softMixProtos, settings, mixins, getMixinsForClass, registerMixins, hasMixin, mergeObjectsOfDecorators, mergePropertyAndMethodDecorators, mergeDecorators, decorators, findAllConstituentClasses, deepDecoratorSearch, directDecoratorSearch, getDecoratorsForClass, decorateClass, decorateMember, decorate, applyPropAndMethodDecorators, mix;
var init_esm = __esm({
  "node_modules/ts-mixer/dist/esm/index.js"() {
    copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    protoChain = (obj, currentChain = [obj]) => {
      const proto = Object.getPrototypeOf(obj);
      if (proto === null)
        return currentChain;
      return protoChain(proto, [...currentChain, proto]);
    };
    nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => protoChain(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto) => proto === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a;
      const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = protoChain(base);
      for (let prototype of ingredients) {
        let protos = protoChain(prototype);
        for (let i = protos.length - 1; i >= 0; i--) {
          let newProto = protos[i];
          if (visitedProtos.indexOf(newProto) === -1) {
            copyProps(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
    getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i = ingredients.length - 1; i >= 0; i--) {
          const searchTarget = protoChains[i][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_, prop) {
        return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
      },
      get(_, prop) {
        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
      },
      set(_, prop, val) {
        const ingredientWithProp = getIngredientWithProp(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
    settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
    mixins = /* @__PURE__ */ new Map();
    getMixinsForClass = (clazz) => mixins.get(clazz);
    registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a;
          const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    mergeObjectsOfDecorators = (o1, o2) => {
      var _a, _b;
      const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = unique([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    mergeDecorators = (d1, d2) => {
      var _a, _b, _c, _d, _e, _f;
      return {
        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    decorators = /* @__PURE__ */ new Map();
    findAllConstituentClasses = (...classes) => {
      var _a;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = protoChain(clazz.prototype).map((proto) => proto.constructor);
          const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = getDecoratorsForClass(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    decorateMember = (decorator) => (object, key, ...otherArgs) => {
      var _a, _b, _c;
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = getDecoratorsForClass(clazz);
      const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
      decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
      decoratorsForTargetType[decoratorType] = decoratorsForType;
      let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
      decoratorsForType[key] = decoratorsForKey;
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
  }
});

// node_modules/@discordjs/builders/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@discordjs/builders/dist/index.js"(exports2, module2) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __decorateClass = (decorators2, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
      for (var i = decorators2.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators2[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp(target, key, result);
      return result;
    };
    var src_exports = {};
    __export2(src_exports, {
      ActionRowBuilder: () => ActionRowBuilder,
      ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
      ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
      ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
      ApplicationCommandOptionWithChoicesAndAutocompleteMixin: () => ApplicationCommandOptionWithChoicesAndAutocompleteMixin,
      BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
      ButtonBuilder: () => ButtonBuilder,
      ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
      ComponentAssertions: () => Assertions_exports2,
      ComponentBuilder: () => ComponentBuilder,
      ContextMenuCommandAssertions: () => Assertions_exports6,
      ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
      EmbedAssertions: () => Assertions_exports,
      EmbedBuilder: () => EmbedBuilder,
      MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
      ModalAssertions: () => Assertions_exports4,
      ModalBuilder: () => ModalBuilder,
      RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
      SelectMenuBuilder: () => StringSelectMenuBuilder,
      SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
      SharedNameAndDescription: () => SharedNameAndDescription,
      SharedSlashCommandOptions: () => SharedSlashCommandOptions,
      SlashCommandAssertions: () => Assertions_exports5,
      SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
      SlashCommandBooleanOption: () => SlashCommandBooleanOption,
      SlashCommandBuilder: () => SlashCommandBuilder,
      SlashCommandChannelOption: () => SlashCommandChannelOption,
      SlashCommandIntegerOption: () => SlashCommandIntegerOption,
      SlashCommandMentionableOption: () => SlashCommandMentionableOption,
      SlashCommandNumberOption: () => SlashCommandNumberOption,
      SlashCommandRoleOption: () => SlashCommandRoleOption,
      SlashCommandStringOption: () => SlashCommandStringOption,
      SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
      SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
      SlashCommandUserOption: () => SlashCommandUserOption,
      StringSelectMenuBuilder: () => StringSelectMenuBuilder,
      StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
      TextInputAssertions: () => Assertions_exports3,
      TextInputBuilder: () => TextInputBuilder,
      UserSelectMenuBuilder: () => UserSelectMenuBuilder,
      createComponentBuilder: () => createComponentBuilder,
      disableValidators: () => disableValidators,
      embedLength: () => embedLength,
      enableValidators: () => enableValidators,
      isValidationEnabled: () => isValidationEnabled,
      normalizeArray: () => normalizeArray,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var Assertions_exports = {};
    __export2(Assertions_exports, {
      RGBPredicate: () => RGBPredicate,
      authorNamePredicate: () => authorNamePredicate,
      colorPredicate: () => colorPredicate,
      descriptionPredicate: () => descriptionPredicate,
      embedAuthorPredicate: () => embedAuthorPredicate,
      embedFieldPredicate: () => embedFieldPredicate,
      embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
      embedFooterPredicate: () => embedFooterPredicate,
      fieldInlinePredicate: () => fieldInlinePredicate,
      fieldLengthPredicate: () => fieldLengthPredicate,
      fieldNamePredicate: () => fieldNamePredicate,
      fieldValuePredicate: () => fieldValuePredicate,
      footerTextPredicate: () => footerTextPredicate,
      imageURLPredicate: () => imageURLPredicate,
      timestampPredicate: () => timestampPredicate,
      titlePredicate: () => titlePredicate,
      urlPredicate: () => urlPredicate,
      validateFieldLength: () => validateFieldLength
    });
    var import_shapeshift = require_cjs2();
    var validate = true;
    function enableValidators() {
      return validate = true;
    }
    __name(enableValidators, "enableValidators");
    function disableValidators() {
      return validate = false;
    }
    __name(disableValidators, "disableValidators");
    function isValidationEnabled() {
      return validate;
    }
    __name(isValidationEnabled, "isValidationEnabled");
    var fieldNamePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
    var fieldValuePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
    var fieldInlinePredicate = import_shapeshift.s.boolean.optional;
    var embedFieldPredicate = import_shapeshift.s.object({
      name: fieldNamePredicate,
      value: fieldValuePredicate,
      inline: fieldInlinePredicate
    }).setValidationEnabled(isValidationEnabled);
    var embedFieldsArrayPredicate = embedFieldPredicate.array.setValidationEnabled(isValidationEnabled);
    var fieldLengthPredicate = import_shapeshift.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateFieldLength(amountAdding, fields) {
      fieldLengthPredicate.parse(((fields == null ? void 0 : fields.length) ?? 0) + amountAdding);
    }
    __name(validateFieldLength, "validateFieldLength");
    var authorNamePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
    var imageURLPredicate = import_shapeshift.s.string.url({
      allowedProtocols: ["http:", "https:", "attachment:"]
    }).nullish.setValidationEnabled(isValidationEnabled);
    var urlPredicate = import_shapeshift.s.string.url({
      allowedProtocols: ["http:", "https:"]
    }).nullish.setValidationEnabled(isValidationEnabled);
    var embedAuthorPredicate = import_shapeshift.s.object({
      name: authorNamePredicate,
      iconURL: imageURLPredicate,
      url: urlPredicate
    }).setValidationEnabled(isValidationEnabled);
    var RGBPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
    var colorPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable.setValidationEnabled(isValidationEnabled);
    var descriptionPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable.setValidationEnabled(isValidationEnabled);
    var footerTextPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable.setValidationEnabled(isValidationEnabled);
    var embedFooterPredicate = import_shapeshift.s.object({
      text: footerTextPredicate,
      iconURL: imageURLPredicate
    }).setValidationEnabled(isValidationEnabled);
    var timestampPredicate = import_shapeshift.s.union(import_shapeshift.s.number, import_shapeshift.s.date).nullable.setValidationEnabled(isValidationEnabled);
    var titlePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
    function normalizeArray(arr) {
      if (Array.isArray(arr[0]))
        return arr[0];
      return arr;
    }
    __name(normalizeArray, "normalizeArray");
    var _a;
    var EmbedBuilder = (_a = class {
      /**
       * Creates a new embed from API data.
       *
       * @param data - The API data to create this embed with
       */
      constructor(data = {}) {
        /**
         * The API data associated with this embed.
         */
        __publicField(this, "data");
        this.data = { ...data };
        if (data.timestamp)
          this.data.timestamp = new Date(data.timestamp).toISOString();
      }
      /**
       * Appends fields to the embed.
       *
       * @remarks
       * This method accepts either an array of fields or a variable number of field parameters.
       * The maximum amount of fields that can be added is 25.
       * @example
       * Using an array:
       * ```ts
       * const fields: APIEmbedField[] = ...;
       * const embed = new EmbedBuilder()
       * 	.addFields(fields);
       * ```
       * @example
       * Using rest parameters (variadic):
       * ```ts
       * const embed = new EmbedBuilder()
       * 	.addFields(
       * 		{ name: 'Field 1', value: 'Value 1' },
       * 		{ name: 'Field 2', value: 'Value 2' },
       * 	);
       * ```
       * @param fields - The fields to add
       */
      addFields(...fields) {
        const normalizedFields = normalizeArray(fields);
        validateFieldLength(normalizedFields.length, this.data.fields);
        embedFieldsArrayPredicate.parse(normalizedFields);
        if (this.data.fields)
          this.data.fields.push(...normalizedFields);
        else
          this.data.fields = normalizedFields;
        return this;
      }
      /**
       * Removes, replaces, or inserts fields for this embed.
       *
       * @remarks
       * This method behaves similarly
       * to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice | Array.prototype.splice()}.
       * The maximum amount of fields that can be added is 25.
       *
       * It's useful for modifying and adjusting order of the already-existing fields of an embed.
       * @example
       * Remove the first field:
       * ```ts
       * embed.spliceFields(0, 1);
       * ```
       * @example
       * Remove the first n fields:
       * ```ts
       * const n = 4;
       * embed.spliceFields(0, n);
       * ```
       * @example
       * Remove the last field:
       * ```ts
       * embed.spliceFields(-1, 1);
       * ```
       * @param index - The index to start at
       * @param deleteCount - The number of fields to remove
       * @param fields - The replacing field objects
       */
      spliceFields(index, deleteCount, ...fields) {
        validateFieldLength(fields.length - deleteCount, this.data.fields);
        embedFieldsArrayPredicate.parse(fields);
        if (this.data.fields)
          this.data.fields.splice(index, deleteCount, ...fields);
        else
          this.data.fields = fields;
        return this;
      }
      /**
       * Sets the fields for this embed.
       *
       * @remarks
       * This method is an alias for {@link EmbedBuilder.spliceFields}. More specifically,
       * it splices the entire array of fields, replacing them with the provided fields.
       *
       * You can set a maximum of 25 fields.
       * @param fields - The fields to set
       */
      setFields(...fields) {
        var _a26;
        this.spliceFields(0, ((_a26 = this.data.fields) == null ? void 0 : _a26.length) ?? 0, ...normalizeArray(fields));
        return this;
      }
      /**
       * Sets the author of this embed.
       *
       * @param options - The options to use
       */
      setAuthor(options) {
        if (options === null) {
          this.data.author = void 0;
          return this;
        }
        embedAuthorPredicate.parse(options);
        this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
        return this;
      }
      /**
       * Sets the color of this embed.
       *
       * @param color - The color to use
       */
      setColor(color) {
        colorPredicate.parse(color);
        if (Array.isArray(color)) {
          const [red, green, blue] = color;
          this.data.color = (red << 16) + (green << 8) + blue;
          return this;
        }
        this.data.color = color ?? void 0;
        return this;
      }
      /**
       * Sets the description of this embed.
       *
       * @param description - The description to use
       */
      setDescription(description) {
        descriptionPredicate.parse(description);
        this.data.description = description ?? void 0;
        return this;
      }
      /**
       * Sets the footer of this embed.
       *
       * @param options - The footer to use
       */
      setFooter(options) {
        if (options === null) {
          this.data.footer = void 0;
          return this;
        }
        embedFooterPredicate.parse(options);
        this.data.footer = { text: options.text, icon_url: options.iconURL };
        return this;
      }
      /**
       * Sets the image of this embed.
       *
       * @param url - The image URL to use
       */
      setImage(url) {
        imageURLPredicate.parse(url);
        this.data.image = url ? { url } : void 0;
        return this;
      }
      /**
       * Sets the thumbnail of this embed.
       *
       * @param url - The thumbnail URL to use
       */
      setThumbnail(url) {
        imageURLPredicate.parse(url);
        this.data.thumbnail = url ? { url } : void 0;
        return this;
      }
      /**
       * Sets the timestamp of this embed.
       *
       * @param timestamp - The timestamp or date to use
       */
      setTimestamp(timestamp = Date.now()) {
        timestampPredicate.parse(timestamp);
        this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : void 0;
        return this;
      }
      /**
       * Sets the title for this embed.
       *
       * @param title - The title to use
       */
      setTitle(title) {
        titlePredicate.parse(title);
        this.data.title = title ?? void 0;
        return this;
      }
      /**
       * Sets the URL of this embed.
       *
       * @param url - The URL to use
       */
      setURL(url) {
        urlPredicate.parse(url);
        this.data.url = url ?? void 0;
        return this;
      }
      /**
       * Serializes this builder to API-compatible JSON data.
       *
       * @remarks
       * This method runs validations on the data before serializing it.
       * As such, it may throw an error if the data is invalid.
       */
      toJSON() {
        return { ...this.data };
      }
    }, __name(_a, "EmbedBuilder"), _a);
    __reExport(src_exports, require_dist7(), module2.exports);
    var Assertions_exports2 = {};
    __export2(Assertions_exports2, {
      buttonLabelValidator: () => buttonLabelValidator,
      buttonStyleValidator: () => buttonStyleValidator,
      channelTypesValidator: () => channelTypesValidator,
      customIdValidator: () => customIdValidator,
      defaultValidator: () => defaultValidator,
      disabledValidator: () => disabledValidator,
      emojiValidator: () => emojiValidator,
      jsonOptionValidator: () => jsonOptionValidator,
      labelValueDescriptionValidator: () => labelValueDescriptionValidator,
      minMaxValidator: () => minMaxValidator,
      optionValidator: () => optionValidator,
      optionsLengthValidator: () => optionsLengthValidator,
      optionsValidator: () => optionsValidator,
      placeholderValidator: () => placeholderValidator,
      urlValidator: () => urlValidator,
      validateRequiredButtonParameters: () => validateRequiredButtonParameters,
      validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
      validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
    });
    var import_shapeshift2 = require_cjs2();
    var import_v10 = require_v106();
    var _a2;
    var StringSelectMenuOptionBuilder = (_a2 = class {
      /**
       * Creates a new string select menu option from API data.
       *
       * @param data - The API data to create this string select menu option with
       * @example
       * Creating a string select menu option from an API data object:
       * ```ts
       * const selectMenuOption = new SelectMenuOptionBuilder({
       * 	label: 'catchy label',
       * 	value: '1',
       * });
       * ```
       * @example
       * Creating a string select menu option using setters and API data:
       * ```ts
       * const selectMenuOption = new SelectMenuOptionBuilder({
       * 	default: true,
       * 	value: '1',
       * })
       * 	.setLabel('woah');
       * ```
       */
      constructor(data = {}) {
        this.data = data;
      }
      /**
       * Sets the label for this option.
       *
       * @param label - The label to use
       */
      setLabel(label) {
        this.data.label = labelValueDescriptionValidator.parse(label);
        return this;
      }
      /**
       * Sets the value for this option.
       *
       * @param value - The value to use
       */
      setValue(value) {
        this.data.value = labelValueDescriptionValidator.parse(value);
        return this;
      }
      /**
       * Sets the description for this option.
       *
       * @param description - The description to use
       */
      setDescription(description) {
        this.data.description = labelValueDescriptionValidator.parse(description);
        return this;
      }
      /**
       * Sets whether this option is selected by default.
       *
       * @param isDefault - Whether this option is selected by default
       */
      setDefault(isDefault = true) {
        this.data.default = defaultValidator.parse(isDefault);
        return this;
      }
      /**
       * Sets the emoji to display for this option.
       *
       * @param emoji - The emoji to use
       */
      setEmoji(emoji) {
        this.data.emoji = emojiValidator.parse(emoji);
        return this;
      }
      /**
       * {@inheritDoc BaseSelectMenuBuilder.toJSON}
       */
      toJSON() {
        validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
        return {
          ...this.data
        };
      }
    }, __name(_a2, "StringSelectMenuOptionBuilder"), _a2);
    var customIdValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var emojiValidator = import_shapeshift2.s.object({
      id: import_shapeshift2.s.string,
      name: import_shapeshift2.s.string,
      animated: import_shapeshift2.s.boolean
    }).partial.strict.setValidationEnabled(isValidationEnabled);
    var disabledValidator = import_shapeshift2.s.boolean;
    var buttonLabelValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
    var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
    var placeholderValidator = import_shapeshift2.s.string.lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
    var minMaxValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    var labelValueDescriptionValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var jsonOptionValidator = import_shapeshift2.s.object({
      label: labelValueDescriptionValidator,
      value: labelValueDescriptionValidator,
      description: labelValueDescriptionValidator.optional,
      emoji: emojiValidator.optional,
      default: import_shapeshift2.s.boolean.optional
    }).setValidationEnabled(isValidationEnabled);
    var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
    var optionsValidator = optionValidator.array.lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
    var optionsLengthValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateRequiredSelectMenuParameters(options, customId) {
      customIdValidator.parse(customId);
      optionsValidator.parse(options);
    }
    __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
    var defaultValidator = import_shapeshift2.s.boolean;
    function validateRequiredSelectMenuOptionParameters(label, value) {
      labelValueDescriptionValidator.parse(label);
      labelValueDescriptionValidator.parse(value);
    }
    __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
    var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array.setValidationEnabled(isValidationEnabled);
    var urlValidator = import_shapeshift2.s.string.url({
      allowedProtocols: ["http:", "https:", "discord:"]
    }).setValidationEnabled(isValidationEnabled);
    function validateRequiredButtonParameters(style, label, emoji, customId, url) {
      if (url && customId) {
        throw new RangeError("URL and custom id are mutually exclusive");
      }
      if (!label && !emoji) {
        throw new RangeError("Buttons must have a label and/or an emoji");
      }
      if (style === import_v10.ButtonStyle.Link) {
        if (!url) {
          throw new RangeError("Link buttons must have a url");
        }
      } else if (url) {
        throw new RangeError("Non-link buttons cannot have a url");
      }
    }
    __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
    var import_v1011 = require_v106();
    var _a3;
    var ComponentBuilder = (_a3 = class {
      /**
       * Constructs a new kind of component.
       *
       * @param data - The data to construct a component out of
       */
      constructor(data) {
        /**
         * The API data associated with this component.
         */
        __publicField(this, "data");
        this.data = data;
      }
    }, __name(_a3, "ComponentBuilder"), _a3);
    var import_v1010 = require_v106();
    var import_v102 = require_v106();
    var _a4;
    var ButtonBuilder = (_a4 = class extends ComponentBuilder {
      /**
       * Creates a new button from API data.
       *
       * @param data - The API data to create this button with
       * @example
       * Creating a button from an API data object:
       * ```ts
       * const button = new ButtonBuilder({
       * 	custom_id: 'a cool button',
       * 	style: ButtonStyle.Primary,
       * 	label: 'Click Me',
       * 	emoji: {
       * 		name: 'smile',
       * 		id: '123456789012345678',
       * 	},
       * });
       * ```
       * @example
       * Creating a button using setters and API data:
       * ```ts
       * const button = new ButtonBuilder({
       * 	style: ButtonStyle.Secondary,
       * 	label: 'Click Me',
       * })
       * 	.setEmoji({ name: '' })
       * 	.setCustomId('another cool button');
       * ```
       */
      constructor(data) {
        super({ type: import_v102.ComponentType.Button, ...data });
      }
      /**
       * Sets the style of this button.
       *
       * @param style - The style to use
       */
      setStyle(style) {
        this.data.style = buttonStyleValidator.parse(style);
        return this;
      }
      /**
       * Sets the URL for this button.
       *
       * @remarks
       * This method is only available to buttons using the `Link` button style.
       * Only three types of URL schemes are currently supported: `https://`, `http://`, and `discord://`.
       * @param url - The URL to use
       */
      setURL(url) {
        this.data.url = urlValidator.parse(url);
        return this;
      }
      /**
       * Sets the custom id for this button.
       *
       * @remarks
       * This method is only applicable to buttons that are not using the `Link` button style.
       * @param customId - The custom id to use
       */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
       * Sets the emoji to display on this button.
       *
       * @param emoji - The emoji to use
       */
      setEmoji(emoji) {
        this.data.emoji = emojiValidator.parse(emoji);
        return this;
      }
      /**
       * Sets whether this button is disabled.
       *
       * @param disabled - Whether to disable this button
       */
      setDisabled(disabled = true) {
        this.data.disabled = disabledValidator.parse(disabled);
        return this;
      }
      /**
       * Sets the label for this button.
       *
       * @param label - The label to use
       */
      setLabel(label) {
        this.data.label = buttonLabelValidator.parse(label);
        return this;
      }
      /**
       * {@inheritDoc ComponentBuilder.toJSON}
       */
      toJSON() {
        validateRequiredButtonParameters(
          this.data.style,
          this.data.label,
          this.data.emoji,
          this.data.custom_id,
          this.data.url
        );
        return {
          ...this.data
        };
      }
    }, __name(_a4, "ButtonBuilder"), _a4);
    var import_v103 = require_v106();
    var _a5;
    var BaseSelectMenuBuilder = (_a5 = class extends ComponentBuilder {
      /**
       * Sets the placeholder for this select menu.
       *
       * @param placeholder - The placeholder to use
       */
      setPlaceholder(placeholder) {
        this.data.placeholder = placeholderValidator.parse(placeholder);
        return this;
      }
      /**
       * Sets the minimum values that must be selected in the select menu.
       *
       * @param minValues - The minimum values that must be selected
       */
      setMinValues(minValues) {
        this.data.min_values = minMaxValidator.parse(minValues);
        return this;
      }
      /**
       * Sets the maximum values that must be selected in the select menu.
       *
       * @param maxValues - The maximum values that must be selected
       */
      setMaxValues(maxValues) {
        this.data.max_values = minMaxValidator.parse(maxValues);
        return this;
      }
      /**
       * Sets the custom id for this select menu.
       *
       * @param customId - The custom id to use
       */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
       * Sets whether this select menu is disabled.
       *
       * @param disabled - Whether this select menu is disabled
       */
      setDisabled(disabled = true) {
        this.data.disabled = disabledValidator.parse(disabled);
        return this;
      }
      /**
       * {@inheritDoc ComponentBuilder.toJSON}
       */
      toJSON() {
        customIdValidator.parse(this.data.custom_id);
        return {
          ...this.data
        };
      }
    }, __name(_a5, "BaseSelectMenuBuilder"), _a5);
    var _a6;
    var ChannelSelectMenuBuilder = (_a6 = class extends BaseSelectMenuBuilder {
      /**
       * Creates a new select menu from API data.
       *
       * @param data - The API data to create this select menu with
       * @example
       * Creating a select menu from an API data object:
       * ```ts
       * const selectMenu = new ChannelSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * 	placeholder: 'select an option',
       * 	max_values: 2,
       * });
       * ```
       * @example
       * Creating a select menu using setters and API data:
       * ```ts
       * const selectMenu = new ChannelSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * })
       * 	.addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement)
       * 	.setMinValues(2);
       * ```
       */
      constructor(data) {
        super({ ...data, type: import_v103.ComponentType.ChannelSelect });
      }
      /**
       * Adds channel types to this select menu.
       *
       * @param types - The channel types to use
       */
      addChannelTypes(...types) {
        var _a26;
        const normalizedTypes = normalizeArray(types);
        (_a26 = this.data).channel_types ?? (_a26.channel_types = []);
        this.data.channel_types.push(...channelTypesValidator.parse(normalizedTypes));
        return this;
      }
      /**
       * Sets channel types for this select menu.
       *
       * @param types - The channel types to use
       */
      setChannelTypes(...types) {
        var _a26;
        const normalizedTypes = normalizeArray(types);
        (_a26 = this.data).channel_types ?? (_a26.channel_types = []);
        this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(normalizedTypes));
        return this;
      }
      /**
       * Adds default channels to this auto populated select menu.
       *
       * @param channels - The channels to add
       */
      addDefaultChannels(...channels) {
        var _a26, _b;
        const normalizedValues = normalizeArray(channels);
        optionsLengthValidator.parse((((_a26 = this.data.default_values) == null ? void 0 : _a26.length) ?? 0) + normalizedValues.length);
        (_b = this.data).default_values ?? (_b.default_values = []);
        this.data.default_values.push(
          ...normalizedValues.map((id) => ({
            id,
            type: import_v103.SelectMenuDefaultValueType.Channel
          }))
        );
        return this;
      }
      /**
       * Sets default channels to this auto populated select menu.
       *
       * @param channels - The channels to set
       */
      setDefaultChannels(...channels) {
        const normalizedValues = normalizeArray(channels);
        optionsLengthValidator.parse(normalizedValues.length);
        this.data.default_values = normalizedValues.map((id) => ({
          id,
          type: import_v103.SelectMenuDefaultValueType.Channel
        }));
        return this;
      }
      /**
       * {@inheritDoc BaseSelectMenuBuilder.toJSON}
       */
      toJSON() {
        customIdValidator.parse(this.data.custom_id);
        return {
          ...this.data
        };
      }
    }, __name(_a6, "ChannelSelectMenuBuilder"), _a6);
    var import_v104 = require_v106();
    var _a7;
    var MentionableSelectMenuBuilder = (_a7 = class extends BaseSelectMenuBuilder {
      /**
       * Creates a new select menu from API data.
       *
       * @param data - The API data to create this select menu with
       * @example
       * Creating a select menu from an API data object:
       * ```ts
       * const selectMenu = new MentionableSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * 	placeholder: 'select an option',
       * 	max_values: 2,
       * });
       * ```
       * @example
       * Creating a select menu using setters and API data:
       * ```ts
       * const selectMenu = new MentionableSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * })
       * 	.setMinValues(1);
       * ```
       */
      constructor(data) {
        super({ ...data, type: import_v104.ComponentType.MentionableSelect });
      }
      /**
       * Adds default roles to this auto populated select menu.
       *
       * @param roles - The roles to add
       */
      addDefaultRoles(...roles) {
        var _a26, _b;
        const normalizedValues = normalizeArray(roles);
        optionsLengthValidator.parse((((_a26 = this.data.default_values) == null ? void 0 : _a26.length) ?? 0) + normalizedValues.length);
        (_b = this.data).default_values ?? (_b.default_values = []);
        this.data.default_values.push(
          ...normalizedValues.map((id) => ({
            id,
            type: import_v104.SelectMenuDefaultValueType.Role
          }))
        );
        return this;
      }
      /**
       * Adds default users to this auto populated select menu.
       *
       * @param users - The users to add
       */
      addDefaultUsers(...users) {
        var _a26, _b;
        const normalizedValues = normalizeArray(users);
        optionsLengthValidator.parse((((_a26 = this.data.default_values) == null ? void 0 : _a26.length) ?? 0) + normalizedValues.length);
        (_b = this.data).default_values ?? (_b.default_values = []);
        this.data.default_values.push(
          ...normalizedValues.map((id) => ({
            id,
            type: import_v104.SelectMenuDefaultValueType.User
          }))
        );
        return this;
      }
      /**
       * Adds default values to this auto populated select menu.
       *
       * @param values - The values to add
       */
      addDefaultValues(...values) {
        var _a26, _b;
        const normalizedValues = normalizeArray(values);
        optionsLengthValidator.parse((((_a26 = this.data.default_values) == null ? void 0 : _a26.length) ?? 0) + normalizedValues.length);
        (_b = this.data).default_values ?? (_b.default_values = []);
        this.data.default_values.push(...normalizedValues);
        return this;
      }
      /**
       * Sets default values to this auto populated select menu.
       *
       * @param values - The values to set
       */
      setDefaultValues(...values) {
        const normalizedValues = normalizeArray(values);
        optionsLengthValidator.parse(normalizedValues.length);
        this.data.default_values = normalizedValues.slice();
        return this;
      }
    }, __name(_a7, "MentionableSelectMenuBuilder"), _a7);
    var import_v105 = require_v106();
    var _a8;
    var RoleSelectMenuBuilder = (_a8 = class extends BaseSelectMenuBuilder {
      /**
       * Creates a new select menu from API data.
       *
       * @param data - The API data to create this select menu with
       * @example
       * Creating a select menu from an API data object:
       * ```ts
       * const selectMenu = new RoleSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * 	placeholder: 'select an option',
       * 	max_values: 2,
       * });
       * ```
       * @example
       * Creating a select menu using setters and API data:
       * ```ts
       * const selectMenu = new RoleSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * })
       * 	.setMinValues(1);
       * ```
       */
      constructor(data) {
        super({ ...data, type: import_v105.ComponentType.RoleSelect });
      }
      /**
       * Adds default roles to this auto populated select menu.
       *
       * @param roles - The roles to add
       */
      addDefaultRoles(...roles) {
        var _a26, _b;
        const normalizedValues = normalizeArray(roles);
        optionsLengthValidator.parse((((_a26 = this.data.default_values) == null ? void 0 : _a26.length) ?? 0) + normalizedValues.length);
        (_b = this.data).default_values ?? (_b.default_values = []);
        this.data.default_values.push(
          ...normalizedValues.map((id) => ({
            id,
            type: import_v105.SelectMenuDefaultValueType.Role
          }))
        );
        return this;
      }
      /**
       * Sets default roles to this auto populated select menu.
       *
       * @param roles - The roles to set
       */
      setDefaultRoles(...roles) {
        const normalizedValues = normalizeArray(roles);
        optionsLengthValidator.parse(normalizedValues.length);
        this.data.default_values = normalizedValues.map((id) => ({
          id,
          type: import_v105.SelectMenuDefaultValueType.Role
        }));
        return this;
      }
    }, __name(_a8, "RoleSelectMenuBuilder"), _a8);
    var import_v106 = require_v106();
    var _a9;
    var StringSelectMenuBuilder = (_a9 = class extends BaseSelectMenuBuilder {
      /**
       * Creates a new select menu from API data.
       *
       * @param data - The API data to create this select menu with
       * @example
       * Creating a select menu from an API data object:
       * ```ts
       * const selectMenu = new StringSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * 	placeholder: 'select an option',
       * 	max_values: 2,
       * 	options: [
       * 		{ label: 'option 1', value: '1' },
       * 		{ label: 'option 2', value: '2' },
       * 		{ label: 'option 3', value: '3' },
       * 	],
       * });
       * ```
       * @example
       * Creating a select menu using setters and API data:
       * ```ts
       * const selectMenu = new StringSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * })
       * 	.setMinValues(1)
       * 	.addOptions({
       * 		label: 'Catchy',
       * 		value: 'catch',
       * 	});
       * ```
       */
      constructor(data) {
        const { options, ...initData } = data ?? {};
        super({ ...initData, type: import_v106.ComponentType.StringSelect });
        /**
         * The options within this select menu.
         */
        __publicField(this, "options");
        this.options = (options == null ? void 0 : options.map((option) => new StringSelectMenuOptionBuilder(option))) ?? [];
      }
      /**
       * Adds options to this select menu.
       *
       * @param options - The options to add
       */
      addOptions(...options) {
        const normalizedOptions = normalizeArray(options);
        optionsLengthValidator.parse(this.options.length + normalizedOptions.length);
        this.options.push(
          ...normalizedOptions.map(
            (normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))
          )
        );
        return this;
      }
      /**
       * Sets the options for this select menu.
       *
       * @param options - The options to set
       */
      setOptions(...options) {
        return this.spliceOptions(0, this.options.length, ...options);
      }
      /**
       * Removes, replaces, or inserts options for this select menu.
       *
       * @remarks
       * This method behaves similarly
       * to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice | Array.prototype.splice()}.
       * It's useful for modifying and adjusting the order of existing options.
       * @example
       * Remove the first option:
       * ```ts
       * selectMenu.spliceOptions(0, 1);
       * ```
       * @example
       * Remove the first n option:
       * ```ts
       * const n = 4;
       * selectMenu.spliceOptions(0, n);
       * ```
       * @example
       * Remove the last option:
       * ```ts
       * selectMenu.spliceOptions(-1, 1);
       * ```
       * @param index - The index to start at
       * @param deleteCount - The number of options to remove
       * @param options - The replacing option objects or builders
       */
      spliceOptions(index, deleteCount, ...options) {
        const normalizedOptions = normalizeArray(options);
        const clone = [...this.options];
        clone.splice(
          index,
          deleteCount,
          ...normalizedOptions.map(
            (normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))
          )
        );
        optionsLengthValidator.parse(clone.length);
        this.options.splice(0, this.options.length, ...clone);
        return this;
      }
      /**
       * {@inheritDoc BaseSelectMenuBuilder.toJSON}
       */
      toJSON() {
        validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
        return {
          ...this.data,
          options: this.options.map((option) => option.toJSON())
        };
      }
    }, __name(_a9, "StringSelectMenuBuilder"), _a9);
    var import_v107 = require_v106();
    var _a10;
    var UserSelectMenuBuilder = (_a10 = class extends BaseSelectMenuBuilder {
      /**
       * Creates a new select menu from API data.
       *
       * @param data - The API data to create this select menu with
       * @example
       * Creating a select menu from an API data object:
       * ```ts
       * const selectMenu = new UserSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * 	placeholder: 'select an option',
       * 	max_values: 2,
       * });
       * ```
       * @example
       * Creating a select menu using setters and API data:
       * ```ts
       * const selectMenu = new UserSelectMenuBuilder({
       * 	custom_id: 'a cool select menu',
       * })
       * 	.setMinValues(1);
       * ```
       */
      constructor(data) {
        super({ ...data, type: import_v107.ComponentType.UserSelect });
      }
      /**
       * Adds default users to this auto populated select menu.
       *
       * @param users - The users to add
       */
      addDefaultUsers(...users) {
        var _a26, _b;
        const normalizedValues = normalizeArray(users);
        optionsLengthValidator.parse((((_a26 = this.data.default_values) == null ? void 0 : _a26.length) ?? 0) + normalizedValues.length);
        (_b = this.data).default_values ?? (_b.default_values = []);
        this.data.default_values.push(
          ...normalizedValues.map((id) => ({
            id,
            type: import_v107.SelectMenuDefaultValueType.User
          }))
        );
        return this;
      }
      /**
       * Sets default users to this auto populated select menu.
       *
       * @param users - The users to set
       */
      setDefaultUsers(...users) {
        const normalizedValues = normalizeArray(users);
        optionsLengthValidator.parse(normalizedValues.length);
        this.data.default_values = normalizedValues.map((id) => ({
          id,
          type: import_v107.SelectMenuDefaultValueType.User
        }));
        return this;
      }
    }, __name(_a10, "UserSelectMenuBuilder"), _a10);
    var import_util = require_dist();
    var import_v109 = require_v106();
    var import_fast_deep_equal = __toESM(require_fast_deep_equal());
    var Assertions_exports3 = {};
    __export2(Assertions_exports3, {
      labelValidator: () => labelValidator,
      maxLengthValidator: () => maxLengthValidator,
      minLengthValidator: () => minLengthValidator,
      placeholderValidator: () => placeholderValidator2,
      requiredValidator: () => requiredValidator,
      textInputStyleValidator: () => textInputStyleValidator,
      validateRequiredParameters: () => validateRequiredParameters,
      valueValidator: () => valueValidator
    });
    var import_shapeshift3 = require_cjs2();
    var import_v108 = require_v106();
    var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
    var minLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var maxLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(1).lessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var requiredValidator = import_shapeshift3.s.boolean;
    var valueValidator = import_shapeshift3.s.string.lengthLessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var placeholderValidator2 = import_shapeshift3.s.string.lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var labelValidator = import_shapeshift3.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
    function validateRequiredParameters(customId, style, label) {
      customIdValidator.parse(customId);
      textInputStyleValidator.parse(style);
      labelValidator.parse(label);
    }
    __name(validateRequiredParameters, "validateRequiredParameters");
    var _a11;
    var TextInputBuilder = (_a11 = class extends ComponentBuilder {
      /**
       * Creates a new text input from API data.
       *
       * @param data - The API data to create this text input with
       * @example
       * Creating a select menu option from an API data object:
       * ```ts
       * const textInput = new TextInputBuilder({
       * 	custom_id: 'a cool select menu',
       * 	label: 'Type something',
       * 	style: TextInputStyle.Short,
       * });
       * ```
       * @example
       * Creating a select menu option using setters and API data:
       * ```ts
       * const textInput = new TextInputBuilder({
       * 	label: 'Type something else',
       * })
       * 	.setCustomId('woah')
       * 	.setStyle(TextInputStyle.Paragraph);
       * ```
       */
      constructor(data) {
        super({ type: import_v109.ComponentType.TextInput, ...data });
      }
      /**
       * Sets the custom id for this text input.
       *
       * @param customId - The custom id to use
       */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
       * Sets the label for this text input.
       *
       * @param label - The label to use
       */
      setLabel(label) {
        this.data.label = labelValidator.parse(label);
        return this;
      }
      /**
       * Sets the style for this text input.
       *
       * @param style - The style to use
       */
      setStyle(style) {
        this.data.style = textInputStyleValidator.parse(style);
        return this;
      }
      /**
       * Sets the minimum length of text for this text input.
       *
       * @param minLength - The minimum length of text for this text input
       */
      setMinLength(minLength) {
        this.data.min_length = minLengthValidator.parse(minLength);
        return this;
      }
      /**
       * Sets the maximum length of text for this text input.
       *
       * @param maxLength - The maximum length of text for this text input
       */
      setMaxLength(maxLength) {
        this.data.max_length = maxLengthValidator.parse(maxLength);
        return this;
      }
      /**
       * Sets the placeholder for this text input.
       *
       * @param placeholder - The placeholder to use
       */
      setPlaceholder(placeholder) {
        this.data.placeholder = placeholderValidator2.parse(placeholder);
        return this;
      }
      /**
       * Sets the value for this text input.
       *
       * @param value - The value to use
       */
      setValue(value) {
        this.data.value = valueValidator.parse(value);
        return this;
      }
      /**
       * Sets whether this text input is required.
       *
       * @param required - Whether this text input is required
       */
      setRequired(required = true) {
        this.data.required = requiredValidator.parse(required);
        return this;
      }
      /**
       * {@inheritDoc ComponentBuilder.toJSON}
       */
      toJSON() {
        validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
        return {
          ...this.data
        };
      }
      /**
       * {@inheritDoc Equatable.equals}
       */
      equals(other) {
        if ((0, import_util.isJSONEncodable)(other)) {
          return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
        }
        return (0, import_fast_deep_equal.default)(other, this.data);
      }
    }, __name(_a11, "TextInputBuilder"), _a11);
    function createComponentBuilder(data) {
      if (data instanceof ComponentBuilder) {
        return data;
      }
      switch (data.type) {
        case import_v1010.ComponentType.ActionRow:
          return new ActionRowBuilder(data);
        case import_v1010.ComponentType.Button:
          return new ButtonBuilder(data);
        case import_v1010.ComponentType.StringSelect:
          return new StringSelectMenuBuilder(data);
        case import_v1010.ComponentType.TextInput:
          return new TextInputBuilder(data);
        case import_v1010.ComponentType.UserSelect:
          return new UserSelectMenuBuilder(data);
        case import_v1010.ComponentType.RoleSelect:
          return new RoleSelectMenuBuilder(data);
        case import_v1010.ComponentType.MentionableSelect:
          return new MentionableSelectMenuBuilder(data);
        case import_v1010.ComponentType.ChannelSelect:
          return new ChannelSelectMenuBuilder(data);
        default:
          throw new Error(`Cannot properly serialize component type: ${data.type}`);
      }
    }
    __name(createComponentBuilder, "createComponentBuilder");
    var _a12;
    var ActionRowBuilder = (_a12 = class extends ComponentBuilder {
      /**
       * Creates a new action row from API data.
       *
       * @param data - The API data to create this action row with
       * @example
       * Creating an action row from an API data object:
       * ```ts
       * const actionRow = new ActionRowBuilder({
       * 	components: [
       * 		{
       * 			custom_id: "custom id",
       * 			label: "Type something",
       * 			style: TextInputStyle.Short,
       * 			type: ComponentType.TextInput,
       * 		},
       * 	],
       * });
       * ```
       * @example
       * Creating an action row using setters and API data:
       * ```ts
       * const actionRow = new ActionRowBuilder({
       * 	components: [
       * 		{
       * 			custom_id: "custom id",
       * 			label: "Click me",
       * 			style: ButtonStyle.Primary,
       * 			type: ComponentType.Button,
       * 		},
       * 	],
       * })
       * 	.addComponents(button2, button3);
       * ```
       */
      constructor({ components, ...data } = {}) {
        super({ type: import_v1011.ComponentType.ActionRow, ...data });
        /**
         * The components within this action row.
         */
        __publicField(this, "components");
        this.components = (components == null ? void 0 : components.map((component) => createComponentBuilder(component))) ?? [];
      }
      /**
       * Adds components to this action row.
       *
       * @param components - The components to add
       */
      addComponents(...components) {
        this.components.push(...normalizeArray(components));
        return this;
      }
      /**
       * Sets components for this action row.
       *
       * @param components - The components to set
       */
      setComponents(...components) {
        this.components.splice(0, this.components.length, ...normalizeArray(components));
        return this;
      }
      /**
       * {@inheritDoc ComponentBuilder.toJSON}
       */
      toJSON() {
        return {
          ...this.data,
          components: this.components.map((component) => component.toJSON())
        };
      }
    }, __name(_a12, "ActionRowBuilder"), _a12);
    var Assertions_exports4 = {};
    __export2(Assertions_exports4, {
      componentsValidator: () => componentsValidator,
      titleValidator: () => titleValidator,
      validateRequiredParameters: () => validateRequiredParameters2
    });
    var import_shapeshift4 = require_cjs2();
    var titleValidator = import_shapeshift4.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
    var componentsValidator = import_shapeshift4.s.instance(ActionRowBuilder).array.lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
    function validateRequiredParameters2(customId, title, components) {
      customIdValidator.parse(customId);
      titleValidator.parse(title);
      componentsValidator.parse(components);
    }
    __name(validateRequiredParameters2, "validateRequiredParameters");
    var _a13;
    var ModalBuilder = (_a13 = class {
      /**
       * Creates a new modal from API data.
       *
       * @param data - The API data to create this modal with
       */
      constructor({ components, ...data } = {}) {
        /**
         * The API data associated with this modal.
         */
        __publicField(this, "data");
        /**
         * The components within this modal.
         */
        __publicField(this, "components", []);
        this.data = { ...data };
        this.components = (components == null ? void 0 : components.map((component) => createComponentBuilder(component))) ?? [];
      }
      /**
       * Sets the title of this modal.
       *
       * @param title - The title to use
       */
      setTitle(title) {
        this.data.title = titleValidator.parse(title);
        return this;
      }
      /**
       * Sets the custom id of this modal.
       *
       * @param customId - The custom id to use
       */
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      /**
       * Adds components to this modal.
       *
       * @param components - The components to add
       */
      addComponents(...components) {
        this.components.push(
          ...normalizeArray(components).map(
            (component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)
          )
        );
        return this;
      }
      /**
       * Sets components for this modal.
       *
       * @param components - The components to set
       */
      setComponents(...components) {
        this.components.splice(0, this.components.length, ...normalizeArray(components));
        return this;
      }
      /**
       * {@inheritDoc ComponentBuilder.toJSON}
       */
      toJSON() {
        validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
        return {
          ...this.data,
          components: this.components.map((component) => component.toJSON())
        };
      }
    }, __name(_a13, "ModalBuilder"), _a13);
    var Assertions_exports5 = {};
    __export2(Assertions_exports5, {
      assertReturnOfBuilder: () => assertReturnOfBuilder,
      localizationMapPredicate: () => localizationMapPredicate,
      validateChoicesLength: () => validateChoicesLength,
      validateDMPermission: () => validateDMPermission,
      validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
      validateDefaultPermission: () => validateDefaultPermission,
      validateDescription: () => validateDescription,
      validateLocale: () => validateLocale,
      validateLocalizationMap: () => validateLocalizationMap,
      validateMaxOptionsLength: () => validateMaxOptionsLength,
      validateNSFW: () => validateNSFW,
      validateName: () => validateName,
      validateRequired: () => validateRequired,
      validateRequiredParameters: () => validateRequiredParameters3
    });
    var import_shapeshift5 = require_cjs2();
    var import_v1012 = require_v106();
    var namePredicate = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
    function validateName(name) {
      namePredicate.parse(name);
    }
    __name(validateName, "validateName");
    var descriptionPredicate2 = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var localePredicate = import_shapeshift5.s.nativeEnum(import_v1012.Locale);
    function validateDescription(description) {
      descriptionPredicate2.parse(description);
    }
    __name(validateDescription, "validateDescription");
    var maxArrayLengthPredicate = import_shapeshift5.s.unknown.array.lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateLocale(locale) {
      return localePredicate.parse(locale);
    }
    __name(validateLocale, "validateLocale");
    function validateMaxOptionsLength(options) {
      maxArrayLengthPredicate.parse(options);
    }
    __name(validateMaxOptionsLength, "validateMaxOptionsLength");
    function validateRequiredParameters3(name, description, options) {
      validateName(name);
      validateDescription(description);
      validateMaxOptionsLength(options);
    }
    __name(validateRequiredParameters3, "validateRequiredParameters");
    var booleanPredicate = import_shapeshift5.s.boolean;
    function validateDefaultPermission(value) {
      booleanPredicate.parse(value);
    }
    __name(validateDefaultPermission, "validateDefaultPermission");
    function validateRequired(required) {
      booleanPredicate.parse(required);
    }
    __name(validateRequired, "validateRequired");
    var choicesLengthPredicate = import_shapeshift5.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateChoicesLength(amountAdding, choices) {
      choicesLengthPredicate.parse(((choices == null ? void 0 : choices.length) ?? 0) + amountAdding);
    }
    __name(validateChoicesLength, "validateChoicesLength");
    function assertReturnOfBuilder(input, ExpectedInstanceOf) {
      import_shapeshift5.s.instance(ExpectedInstanceOf).parse(input);
    }
    __name(assertReturnOfBuilder, "assertReturnOfBuilder");
    var localizationMapPredicate = import_shapeshift5.s.object(Object.fromEntries(Object.values(import_v1012.Locale).map((locale) => [locale, import_shapeshift5.s.string.nullish]))).strict.nullish.setValidationEnabled(isValidationEnabled);
    function validateLocalizationMap(value) {
      localizationMapPredicate.parse(value);
    }
    __name(validateLocalizationMap, "validateLocalizationMap");
    var dmPermissionPredicate = import_shapeshift5.s.boolean.nullish;
    function validateDMPermission(value) {
      dmPermissionPredicate.parse(value);
    }
    __name(validateDMPermission, "validateDMPermission");
    var memberPermissionPredicate = import_shapeshift5.s.union(
      import_shapeshift5.s.bigint.transform((value) => value.toString()),
      import_shapeshift5.s.number.safeInt.transform((value) => value.toString()),
      import_shapeshift5.s.string.regex(/^\d+$/)
    ).nullish;
    function validateDefaultMemberPermissions(permissions) {
      return memberPermissionPredicate.parse(permissions);
    }
    __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
    function validateNSFW(value) {
      booleanPredicate.parse(value);
    }
    __name(validateNSFW, "validateNSFW");
    var import_ts_mixer6 = (init_esm(), __toCommonJS(esm_exports));
    var import_v1024 = require_v106();
    var import_ts_mixer5 = (init_esm(), __toCommonJS(esm_exports));
    var _a14;
    var SharedNameAndDescription = (_a14 = class {
      constructor() {
        /**
         * The name of this command.
         */
        __publicField(this, "name");
        /**
         * The name localizations of this command.
         */
        __publicField(this, "name_localizations");
        /**
         * The description of this command.
         */
        __publicField(this, "description");
        /**
         * The description localizations of this command.
         */
        __publicField(this, "description_localizations");
      }
      /**
       * Sets the name of this command.
       *
       * @param name - The name to use
       */
      setName(name) {
        validateName(name);
        Reflect.set(this, "name", name);
        return this;
      }
      /**
       * Sets the description of this command.
       *
       * @param description - The description to use
       */
      setDescription(description) {
        validateDescription(description);
        Reflect.set(this, "description", description);
        return this;
      }
      /**
       * Sets a name localization for this command.
       *
       * @param locale - The locale to set
       * @param localizedName - The localized name for the given `locale`
       */
      setNameLocalization(locale, localizedName) {
        if (!this.name_localizations) {
          Reflect.set(this, "name_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedName === null) {
          this.name_localizations[parsedLocale] = null;
          return this;
        }
        validateName(localizedName);
        this.name_localizations[parsedLocale] = localizedName;
        return this;
      }
      /**
       * Sets the name localizations for this command.
       *
       * @param localizedNames - The object of localized names to set
       */
      setNameLocalizations(localizedNames) {
        if (localizedNames === null) {
          Reflect.set(this, "name_localizations", null);
          return this;
        }
        Reflect.set(this, "name_localizations", {});
        for (const args of Object.entries(localizedNames)) {
          this.setNameLocalization(...args);
        }
        return this;
      }
      /**
       * Sets a description localization for this command.
       *
       * @param locale - The locale to set
       * @param localizedDescription - The localized description for the given locale
       */
      setDescriptionLocalization(locale, localizedDescription) {
        if (!this.description_localizations) {
          Reflect.set(this, "description_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedDescription === null) {
          this.description_localizations[parsedLocale] = null;
          return this;
        }
        validateDescription(localizedDescription);
        this.description_localizations[parsedLocale] = localizedDescription;
        return this;
      }
      /**
       * Sets the description localizations for this command.
       *
       * @param localizedDescriptions - The object of localized descriptions to set
       */
      setDescriptionLocalizations(localizedDescriptions) {
        if (localizedDescriptions === null) {
          Reflect.set(this, "description_localizations", null);
          return this;
        }
        Reflect.set(this, "description_localizations", {});
        for (const args of Object.entries(localizedDescriptions)) {
          this.setDescriptionLocalization(...args);
        }
        return this;
      }
    }, __name(_a14, "SharedNameAndDescription"), _a14);
    var import_v1013 = require_v106();
    var _a15;
    var ApplicationCommandOptionBase = (_a15 = class extends SharedNameAndDescription {
      constructor() {
        super(...arguments);
        /**
         * Whether this option is required.
         *
         * @defaultValue `false`
         */
        __publicField(this, "required", false);
      }
      /**
       * Sets whether this option is required.
       *
       * @param required - Whether this option should be required
       */
      setRequired(required) {
        validateRequired(required);
        Reflect.set(this, "required", required);
        return this;
      }
      /**
       * This method runs required validators on this builder.
       */
      runRequiredValidations() {
        validateRequiredParameters3(this.name, this.description, []);
        validateLocalizationMap(this.name_localizations);
        validateLocalizationMap(this.description_localizations);
        validateRequired(this.required);
      }
    }, __name(_a15, "ApplicationCommandOptionBase"), _a15);
    var _a16;
    var SlashCommandAttachmentOption = (_a16 = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1013.ApplicationCommandOptionType.Attachment);
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    }, __name(_a16, "SlashCommandAttachmentOption"), _a16);
    var import_v1014 = require_v106();
    var _a17;
    var SlashCommandBooleanOption = (_a17 = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1014.ApplicationCommandOptionType.Boolean);
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    }, __name(_a17, "SlashCommandBooleanOption"), _a17);
    var import_v1016 = require_v106();
    var import_ts_mixer = (init_esm(), __toCommonJS(esm_exports));
    var import_shapeshift6 = require_cjs2();
    var import_v1015 = require_v106();
    var allowedChannelTypes = [
      import_v1015.ChannelType.GuildText,
      import_v1015.ChannelType.GuildVoice,
      import_v1015.ChannelType.GuildCategory,
      import_v1015.ChannelType.GuildAnnouncement,
      import_v1015.ChannelType.AnnouncementThread,
      import_v1015.ChannelType.PublicThread,
      import_v1015.ChannelType.PrivateThread,
      import_v1015.ChannelType.GuildStageVoice,
      import_v1015.ChannelType.GuildForum,
      import_v1015.ChannelType.GuildMedia
    ];
    var channelTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.union(...allowedChannelTypes.map((type) => import_shapeshift6.s.literal(type))));
    var _a18;
    var ApplicationCommandOptionChannelTypesMixin = (_a18 = class {
      constructor() {
        /**
         * The channel types of this option.
         */
        __publicField(this, "channel_types");
      }
      /**
       * Adds channel types to this option.
       *
       * @param channelTypes - The channel types
       */
      addChannelTypes(...channelTypes) {
        if (this.channel_types === void 0) {
          Reflect.set(this, "channel_types", []);
        }
        this.channel_types.push(...channelTypesPredicate.parse(channelTypes));
        return this;
      }
    }, __name(_a18, "ApplicationCommandOptionChannelTypesMixin"), _a18);
    var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1016.ApplicationCommandOptionType.Channel);
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandChannelOption, "SlashCommandChannelOption");
    SlashCommandChannelOption = __decorateClass([
      (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
    ], SlashCommandChannelOption);
    var import_shapeshift8 = require_cjs2();
    var import_v1018 = require_v106();
    var import_ts_mixer2 = (init_esm(), __toCommonJS(esm_exports));
    var _a19;
    var ApplicationCommandNumericOptionMinMaxValueMixin = (_a19 = class {
      constructor() {
        /**
         * The maximum value of this option.
         */
        __publicField(this, "max_value");
        /**
         * The minimum value of this option.
         */
        __publicField(this, "min_value");
      }
    }, __name(_a19, "ApplicationCommandNumericOptionMinMaxValueMixin"), _a19);
    var import_shapeshift7 = require_cjs2();
    var import_v1017 = require_v106();
    var stringPredicate = import_shapeshift7.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
    var numberPredicate = import_shapeshift7.s.number.greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
    var choicesPredicate = import_shapeshift7.s.object({
      name: stringPredicate,
      name_localizations: localizationMapPredicate,
      value: import_shapeshift7.s.union(stringPredicate, numberPredicate)
    }).array;
    var booleanPredicate2 = import_shapeshift7.s.boolean;
    var _a20;
    var ApplicationCommandOptionWithChoicesAndAutocompleteMixin = (_a20 = class {
      constructor() {
        /**
         * The choices of this option.
         */
        __publicField(this, "choices");
        /**
         * Whether this option utilizes autocomplete.
         */
        __publicField(this, "autocomplete");
        /**
         * The type of this option.
         *
         * @privateRemarks Since this is present and this is a mixin, this is needed.
         */
        __publicField(this, "type");
      }
      /**
       * Adds multiple choices to this option.
       *
       * @param choices - The choices to add
       */
      addChoices(...choices) {
        if (choices.length > 0 && this.autocomplete) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        choicesPredicate.parse(choices);
        if (this.choices === void 0) {
          Reflect.set(this, "choices", []);
        }
        validateChoicesLength(choices.length, this.choices);
        for (const { name, name_localizations, value } of choices) {
          if (this.type === import_v1017.ApplicationCommandOptionType.String) {
            stringPredicate.parse(value);
          } else {
            numberPredicate.parse(value);
          }
          this.choices.push({ name, name_localizations, value });
        }
        return this;
      }
      /**
       * Sets multiple choices for this option.
       *
       * @param choices - The choices to set
       */
      setChoices(...choices) {
        if (choices.length > 0 && this.autocomplete) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        choicesPredicate.parse(choices);
        Reflect.set(this, "choices", []);
        this.addChoices(...choices);
        return this;
      }
      /**
       * Whether this option uses autocomplete.
       *
       * @param autocomplete - Whether this option should use autocomplete
       */
      setAutocomplete(autocomplete) {
        booleanPredicate2.parse(autocomplete);
        if (autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        Reflect.set(this, "autocomplete", autocomplete);
        return this;
      }
    }, __name(_a20, "ApplicationCommandOptionWithChoicesAndAutocompleteMixin"), _a20);
    var numberValidator = import_shapeshift8.s.number.int;
    var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1018.ApplicationCommandOptionType.Integer);
      }
      /**
       * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMaxValue}
       */
      setMaxValue(max) {
        numberValidator.parse(max);
        Reflect.set(this, "max_value", max);
        return this;
      }
      /**
       * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMinValue}
       */
      setMinValue(min) {
        numberValidator.parse(min);
        Reflect.set(this, "min_value", min);
        return this;
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return { ...this };
      }
    };
    __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
    SlashCommandIntegerOption = __decorateClass([
      (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandIntegerOption);
    var import_v1019 = require_v106();
    var _a21;
    var SlashCommandMentionableOption = (_a21 = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1019.ApplicationCommandOptionType.Mentionable);
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    }, __name(_a21, "SlashCommandMentionableOption"), _a21);
    var import_shapeshift9 = require_cjs2();
    var import_v1020 = require_v106();
    var import_ts_mixer3 = (init_esm(), __toCommonJS(esm_exports));
    var numberValidator2 = import_shapeshift9.s.number;
    var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1020.ApplicationCommandOptionType.Number);
      }
      /**
       * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMaxValue}
       */
      setMaxValue(max) {
        numberValidator2.parse(max);
        Reflect.set(this, "max_value", max);
        return this;
      }
      /**
       * {@inheritDoc ApplicationCommandNumericOptionMinMaxValueMixin.setMinValue}
       */
      setMinValue(min) {
        numberValidator2.parse(min);
        Reflect.set(this, "min_value", min);
        return this;
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return { ...this };
      }
    };
    __name(SlashCommandNumberOption, "SlashCommandNumberOption");
    SlashCommandNumberOption = __decorateClass([
      (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandNumberOption);
    var import_v1021 = require_v106();
    var _a22;
    var SlashCommandRoleOption = (_a22 = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1021.ApplicationCommandOptionType.Role);
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    }, __name(_a22, "SlashCommandRoleOption"), _a22);
    var import_shapeshift10 = require_cjs2();
    var import_v1022 = require_v106();
    var import_ts_mixer4 = (init_esm(), __toCommonJS(esm_exports));
    var minLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(0).lessThanOrEqual(6e3);
    var maxLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(1).lessThanOrEqual(6e3);
    var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1022.ApplicationCommandOptionType.String);
        /**
         * The maximum length of this option.
         */
        __publicField(this, "max_length");
        /**
         * The minimum length of this option.
         */
        __publicField(this, "min_length");
      }
      /**
       * Sets the maximum length of this string option.
       *
       * @param max - The maximum length this option can be
       */
      setMaxLength(max) {
        maxLengthValidator2.parse(max);
        Reflect.set(this, "max_length", max);
        return this;
      }
      /**
       * Sets the minimum length of this string option.
       *
       * @param min - The minimum length this option can be
       */
      setMinLength(min) {
        minLengthValidator2.parse(min);
        Reflect.set(this, "min_length", min);
        return this;
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return { ...this };
      }
    };
    __name(SlashCommandStringOption, "SlashCommandStringOption");
    SlashCommandStringOption = __decorateClass([
      (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandStringOption);
    var import_v1023 = require_v106();
    var _a23;
    var SlashCommandUserOption = (_a23 = class extends ApplicationCommandOptionBase {
      constructor() {
        super(...arguments);
        /**
         * The type of this option.
         */
        __publicField(this, "type", import_v1023.ApplicationCommandOptionType.User);
      }
      /**
       * {@inheritDoc ApplicationCommandOptionBase.toJSON}
       */
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    }, __name(_a23, "SlashCommandUserOption"), _a23);
    var _a24;
    var SharedSlashCommandOptions = (_a24 = class {
      constructor() {
        __publicField(this, "options");
      }
      /**
       * Adds a boolean option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addBooleanOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
      }
      /**
       * Adds a user option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addUserOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandUserOption);
      }
      /**
       * Adds a channel option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addChannelOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
      }
      /**
       * Adds a role option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addRoleOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
      }
      /**
       * Adds an attachment option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addAttachmentOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
      }
      /**
       * Adds a mentionable option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addMentionableOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
      }
      /**
       * Adds a string option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addStringOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandStringOption);
      }
      /**
       * Adds an integer option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addIntegerOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
      }
      /**
       * Adds a number option.
       *
       * @param input - A function that returns an option builder or an already built builder
       */
      addNumberOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
      }
      /**
       * Where the actual adding magic happens. 
       *
       * @param input - The input. What else?
       * @param Instance - The instance of whatever is being added
       * @internal
       */
      _sharedAddOptionMethod(input, Instance) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new Instance()) : input;
        assertReturnOfBuilder(result, Instance);
        options.push(result);
        return this;
      }
    }, __name(_a24, "SharedSlashCommandOptions"), _a24);
    var SlashCommandSubcommandGroupBuilder = class {
      constructor() {
        /**
         * The name of this subcommand group.
         */
        __publicField(this, "name");
        /**
         * The description of this subcommand group.
         */
        __publicField(this, "description");
        /**
         * The subcommands within this subcommand group.
         */
        __publicField(this, "options", []);
      }
      /**
       * Adds a new subcommand to this group.
       *
       * @param input - A function that returns a subcommand builder or an already built builder
       */
      addSubcommand(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
        options.push(result);
        return this;
      }
      /**
       * Serializes this builder to API-compatible JSON data.
       *
       * @remarks
       * This method runs validations on the data before serializing it.
       * As such, it may throw an error if the data is invalid.
       */
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        return {
          type: import_v1024.ApplicationCommandOptionType.SubcommandGroup,
          name: this.name,
          name_localizations: this.name_localizations,
          description: this.description,
          description_localizations: this.description_localizations,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
    SlashCommandSubcommandGroupBuilder = __decorateClass([
      (0, import_ts_mixer5.mix)(SharedNameAndDescription)
    ], SlashCommandSubcommandGroupBuilder);
    var SlashCommandSubcommandBuilder = class {
      constructor() {
        /**
         * The name of this subcommand.
         */
        __publicField(this, "name");
        /**
         * The description of this subcommand.
         */
        __publicField(this, "description");
        /**
         * The options within this subcommand.
         */
        __publicField(this, "options", []);
      }
      /**
       * Serializes this builder to API-compatible JSON data.
       *
       * @remarks
       * This method runs validations on the data before serializing it.
       * As such, it may throw an error if the data is invalid.
       */
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        return {
          type: import_v1024.ApplicationCommandOptionType.Subcommand,
          name: this.name,
          name_localizations: this.name_localizations,
          description: this.description,
          description_localizations: this.description_localizations,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
    SlashCommandSubcommandBuilder = __decorateClass([
      (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
    ], SlashCommandSubcommandBuilder);
    var SlashCommandBuilder = class {
      constructor() {
        /**
         * The name of this command.
         */
        __publicField(this, "name");
        /**
         * The name localizations of this command.
         */
        __publicField(this, "name_localizations");
        /**
         * The description of this command.
         */
        __publicField(this, "description");
        /**
         * The description localizations of this command.
         */
        __publicField(this, "description_localizations");
        /**
         * The options of this command.
         */
        __publicField(this, "options", []);
        /**
         * Whether this command is enabled by default when the application is added to a guild.
         *
         * @deprecated Use {@link ContextMenuCommandBuilder.setDefaultMemberPermissions} or {@link ContextMenuCommandBuilder.setDMPermission} instead.
         */
        __publicField(this, "default_permission");
        /**
         * The set of permissions represented as a bit set for the command.
         */
        __publicField(this, "default_member_permissions");
        /**
         * Indicates whether the command is available in direct messages with the application.
         *
         * @remarks
         * By default, commands are visible. This property is only for global commands.
         */
        __publicField(this, "dm_permission");
        /**
         * Whether this command is NSFW.
         */
        __publicField(this, "nsfw");
      }
      /**
       * Sets whether the command is enabled by default when the application is added to a guild.
       *
       * @remarks
       * If set to `false`, you will have to later `PUT` the permissions for this command.
       * @param value - Whether or not to enable this command by default
       * @see {@link https://discord.com/developers/docs/interactions/application-commands#permissions}
       * @deprecated Use {@link SlashCommandBuilder.setDefaultMemberPermissions} or {@link SlashCommandBuilder.setDMPermission} instead.
       */
      setDefaultPermission(value) {
        validateDefaultPermission(value);
        Reflect.set(this, "default_permission", value);
        return this;
      }
      /**
       * Sets the default permissions a member should have in order to run the command.
       *
       * @remarks
       * You can set this to `'0'` to disable the command by default.
       * @param permissions - The permissions bit field to set
       * @see {@link https://discord.com/developers/docs/interactions/application-commands#permissions}
       */
      setDefaultMemberPermissions(permissions) {
        const permissionValue = validateDefaultMemberPermissions(permissions);
        Reflect.set(this, "default_member_permissions", permissionValue);
        return this;
      }
      /**
       * Sets if the command is available in direct messages with the application.
       *
       * @remarks
       * By default, commands are visible. This method is only for global commands.
       * @param enabled - Whether the command should be enabled in direct messages
       * @see {@link https://discord.com/developers/docs/interactions/application-commands#permissions}
       */
      setDMPermission(enabled) {
        validateDMPermission(enabled);
        Reflect.set(this, "dm_permission", enabled);
        return this;
      }
      /**
       * Sets whether this command is NSFW.
       *
       * @param nsfw - Whether this command is NSFW
       */
      setNSFW(nsfw = true) {
        validateNSFW(nsfw);
        Reflect.set(this, "nsfw", nsfw);
        return this;
      }
      /**
       * Adds a new subcommand group to this command.
       *
       * @param input - A function that returns a subcommand group builder or an already built builder
       */
      addSubcommandGroup(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandGroupBuilder);
        options.push(result);
        return this;
      }
      /**
       * Adds a new subcommand to this command.
       *
       * @param input - A function that returns a subcommand builder or an already built builder
       */
      addSubcommand(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
        options.push(result);
        return this;
      }
      /**
       * Serializes this builder to API-compatible JSON data.
       *
       * @remarks
       * This method runs validations on the data before serializing it.
       * As such, it may throw an error if the data is invalid.
       */
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        validateLocalizationMap(this.name_localizations);
        validateLocalizationMap(this.description_localizations);
        return {
          ...this,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(SlashCommandBuilder, "SlashCommandBuilder");
    SlashCommandBuilder = __decorateClass([
      (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription)
    ], SlashCommandBuilder);
    var Assertions_exports6 = {};
    __export2(Assertions_exports6, {
      validateDMPermission: () => validateDMPermission2,
      validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
      validateDefaultPermission: () => validateDefaultPermission2,
      validateName: () => validateName2,
      validateRequiredParameters: () => validateRequiredParameters4,
      validateType: () => validateType
    });
    var import_shapeshift11 = require_cjs2();
    var import_v1025 = require_v106();
    var namePredicate2 = import_shapeshift11.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{P}\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}]+ *)+$/u).setValidationEnabled(isValidationEnabled);
    var typePredicate = import_shapeshift11.s.union(import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.User), import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.Message)).setValidationEnabled(isValidationEnabled);
    var booleanPredicate3 = import_shapeshift11.s.boolean;
    function validateDefaultPermission2(value) {
      booleanPredicate3.parse(value);
    }
    __name(validateDefaultPermission2, "validateDefaultPermission");
    function validateName2(name) {
      namePredicate2.parse(name);
    }
    __name(validateName2, "validateName");
    function validateType(type) {
      typePredicate.parse(type);
    }
    __name(validateType, "validateType");
    function validateRequiredParameters4(name, type) {
      validateName2(name);
      validateType(type);
    }
    __name(validateRequiredParameters4, "validateRequiredParameters");
    var dmPermissionPredicate2 = import_shapeshift11.s.boolean.nullish;
    function validateDMPermission2(value) {
      dmPermissionPredicate2.parse(value);
    }
    __name(validateDMPermission2, "validateDMPermission");
    var memberPermissionPredicate2 = import_shapeshift11.s.union(
      import_shapeshift11.s.bigint.transform((value) => value.toString()),
      import_shapeshift11.s.number.safeInt.transform((value) => value.toString()),
      import_shapeshift11.s.string.regex(/^\d+$/)
    ).nullish;
    function validateDefaultMemberPermissions2(permissions) {
      return memberPermissionPredicate2.parse(permissions);
    }
    __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
    var _a25;
    var ContextMenuCommandBuilder = (_a25 = class {
      constructor() {
        /**
         * The name of this command.
         */
        __publicField(this, "name");
        /**
         * The name localizations of this command.
         */
        __publicField(this, "name_localizations");
        /**
         * The type of this command.
         */
        __publicField(this, "type");
        /**
         * Whether this command is enabled by default when the application is added to a guild.
         *
         * @deprecated Use {@link ContextMenuCommandBuilder.setDefaultMemberPermissions} or {@link ContextMenuCommandBuilder.setDMPermission} instead.
         */
        __publicField(this, "default_permission");
        /**
         * The set of permissions represented as a bit set for the command.
         */
        __publicField(this, "default_member_permissions");
        /**
         * Indicates whether the command is available in direct messages with the application.
         *
         * @remarks
         * By default, commands are visible. This property is only for global commands.
         */
        __publicField(this, "dm_permission");
      }
      /**
       * Sets the name of this command.
       *
       * @param name - The name to use
       */
      setName(name) {
        validateName2(name);
        Reflect.set(this, "name", name);
        return this;
      }
      /**
       * Sets the type of this command.
       *
       * @param type - The type to use
       */
      setType(type) {
        validateType(type);
        Reflect.set(this, "type", type);
        return this;
      }
      /**
       * Sets whether the command is enabled by default when the application is added to a guild.
       *
       * @remarks
       * If set to `false`, you will have to later `PUT` the permissions for this command.
       * @param value - Whether to enable this command by default
       * @see {@link https://discord.com/developers/docs/interactions/application-commands#permissions}
       * @deprecated Use {@link ContextMenuCommandBuilder.setDefaultMemberPermissions} or {@link ContextMenuCommandBuilder.setDMPermission} instead.
       */
      setDefaultPermission(value) {
        validateDefaultPermission2(value);
        Reflect.set(this, "default_permission", value);
        return this;
      }
      /**
       * Sets the default permissions a member should have in order to run this command.
       *
       * @remarks
       * You can set this to `'0'` to disable the command by default.
       * @param permissions - The permissions bit field to set
       * @see {@link https://discord.com/developers/docs/interactions/application-commands#permissions}
       */
      setDefaultMemberPermissions(permissions) {
        const permissionValue = validateDefaultMemberPermissions2(permissions);
        Reflect.set(this, "default_member_permissions", permissionValue);
        return this;
      }
      /**
       * Sets if the command is available in direct messages with the application.
       *
       * @remarks
       * By default, commands are visible. This method is only for global commands.
       * @param enabled - Whether the command should be enabled in direct messages
       * @see {@link https://discord.com/developers/docs/interactions/application-commands#permissions}
       */
      setDMPermission(enabled) {
        validateDMPermission2(enabled);
        Reflect.set(this, "dm_permission", enabled);
        return this;
      }
      /**
       * Sets a name localization for this command.
       *
       * @param locale - The locale to set
       * @param localizedName - The localized name for the given `locale`
       */
      setNameLocalization(locale, localizedName) {
        if (!this.name_localizations) {
          Reflect.set(this, "name_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedName === null) {
          this.name_localizations[parsedLocale] = null;
          return this;
        }
        validateName2(localizedName);
        this.name_localizations[parsedLocale] = localizedName;
        return this;
      }
      /**
       * Sets the name localizations for this command.
       *
       * @param localizedNames - The object of localized names to set
       */
      setNameLocalizations(localizedNames) {
        if (localizedNames === null) {
          Reflect.set(this, "name_localizations", null);
          return this;
        }
        Reflect.set(this, "name_localizations", {});
        for (const args of Object.entries(localizedNames))
          this.setNameLocalization(...args);
        return this;
      }
      /**
       * Serializes this builder to API-compatible JSON data.
       *
       * @remarks
       * This method runs validations on the data before serializing it.
       * As such, it may throw an error if the data is invalid.
       */
      toJSON() {
        validateRequiredParameters4(this.name, this.type);
        validateLocalizationMap(this.name_localizations);
        return { ...this };
      }
    }, __name(_a25, "ContextMenuCommandBuilder"), _a25);
    function embedLength(data) {
      var _a26, _b, _c, _d, _e;
      return (((_a26 = data.title) == null ? void 0 : _a26.length) ?? 0) + (((_b = data.description) == null ? void 0 : _b.length) ?? 0) + (((_c = data.fields) == null ? void 0 : _c.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0)) ?? 0) + (((_d = data.footer) == null ? void 0 : _d.text.length) ?? 0) + (((_e = data.author) == null ? void 0 : _e.name.length) ?? 0);
    }
    __name(embedLength, "embedLength");
    var version = "1.7.0";
  }
});

// node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS({
  "node_modules/discord.js/src/structures/Component.js"(exports2, module2) {
    "use strict";
    var isEqual = require_fast_deep_equal();
    var Component = class _Component {
      constructor(data) {
        this.data = data;
      }
      /**
       * The type of the component
       * @type {ComponentType}
       * @readonly
       */
      get type() {
        return this.data.type;
      }
      /**
       * Whether or not the given components are equal
       * @param {Component|APIMessageComponent} other The component to compare against
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof _Component) {
          return isEqual(other.data, this.data);
        }
        return isEqual(other, this.data);
      }
      /**
       * Returns the API-compatible JSON for this component
       * @returns {APIMessageComponent}
       */
      toJSON() {
        return { ...this.data };
      }
    };
    module2.exports = Component;
  }
});

// node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS({
  "node_modules/discord.js/src/structures/ActionRow.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require_node_util();
    var { isJSONEncodable } = require_dist();
    var Component = require_Component();
    var { createComponent } = require_Components();
    var _ActionRow = class _ActionRow extends Component {
      constructor({ components, ...data }) {
        super(data);
        this.components = components.map((component) => createComponent(component));
      }
      /**
       * Returns the API-compatible JSON for this component
       * @returns {APIActionRowComponent}
       */
      toJSON() {
        return { ...this.data, components: this.components.map((component) => component.toJSON()) };
      }
    };
    /**
     * Creates a new action row builder from JSON data
     * @method from
     * @memberof ActionRow
     * @param {ActionRowBuilder|ActionRow|APIActionRowComponent} other The other data
     * @returns {ActionRowBuilder}
     * @deprecated Use {@link ActionRowBuilder.from} instead.
     */
    __publicField(_ActionRow, "from", deprecate(
      (other) => new _ActionRow(isJSONEncodable(other) ? other.toJSON() : other),
      "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead."
    ));
    var ActionRow = _ActionRow;
    module2.exports = ActionRow;
  }
});

// node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ButtonBuilder.js"(exports2, module2) {
    "use strict";
    var { ButtonBuilder: BuildersButton } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var ButtonBuilder = class extends BuildersButton {
      constructor({ emoji, ...data } = {}) {
        super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
      }
      /**
       * Sets the emoji to display on this button
       * @param {string|APIMessageComponentEmoji} emoji The emoji to display on this button
       * @returns {ButtonBuilder}
       */
      setEmoji(emoji) {
        if (typeof emoji === "string") {
          return super.setEmoji(resolvePartialEmoji(emoji));
        }
        return super.setEmoji(emoji);
      }
      /**
       * Creates a new button builder from JSON data
       * @param {ButtonBuilder|ButtonComponent|APIButtonComponent} other The other data
       * @returns {ButtonBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = ButtonBuilder;
  }
});

// node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS({
  "node_modules/discord.js/src/structures/ButtonComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var ButtonComponent = class extends Component {
      /**
       * The style of this button
       * @type {ButtonStyle}
       * @readonly
       */
      get style() {
        return this.data.style;
      }
      /**
       * The label of this button
       * @type {?string}
       * @readonly
       */
      get label() {
        return this.data.label ?? null;
      }
      /**
       * The emoji used in this button
       * @type {?APIMessageComponentEmoji}
       * @readonly
       */
      get emoji() {
        return this.data.emoji ?? null;
      }
      /**
       * Whether this button is disabled
       * @type {boolean}
       * @readonly
       */
      get disabled() {
        return this.data.disabled ?? false;
      }
      /**
       * The custom id of this button (only defined on non-link buttons)
       * @type {?string}
       * @readonly
       */
      get customId() {
        return this.data.custom_id ?? null;
      }
      /**
       * The URL of this button (only defined on link buttons)
       * @type {?string}
       * @readonly
       */
      get url() {
        return this.data.url ?? null;
      }
    };
    module2.exports = ButtonComponent;
  }
});

// node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var ChannelSelectMenuBuilder = class extends BuildersChannelSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from JSON data
       * @param {ChannelSelectMenuBuilder|ChannelSelectMenuComponent|APIChannelSelectComponent} other The other data
       * @returns {ChannelSelectMenuBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = ChannelSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/BaseSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var BaseSelectMenuComponent = class extends Component {
      /**
       * The placeholder for this select menu
       * @type {?string}
       * @readonly
       */
      get placeholder() {
        return this.data.placeholder ?? null;
      }
      /**
       * The maximum amount of options that can be selected
       * @type {?number}
       * @readonly
       */
      get maxValues() {
        return this.data.max_values ?? null;
      }
      /**
       * The minimum amount of options that must be selected
       * @type {?number}
       * @readonly
       */
      get minValues() {
        return this.data.min_values ?? null;
      }
      /**
       * The custom id of this select menu
       * @type {string}
       * @readonly
       */
      get customId() {
        return this.data.custom_id;
      }
      /**
       * Whether this select menu is disabled
       * @type {boolean}
       * @readonly
       */
      get disabled() {
        return this.data.disabled ?? false;
      }
    };
    module2.exports = BaseSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var ChannelSelectMenuComponent = class extends BaseSelectMenuComponent {
      /**
       * The options in this select menu
       * @type {?(ChannelType[])}
       * @readonly
       */
      get channelTypes() {
        return this.data.channel_types ?? null;
      }
    };
    module2.exports = ChannelSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var MentionableSelectMenuBuilder = class extends BuildersMentionableSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from JSON data
       * @param {MentionableSelectMenuBuilder|MentionableSelectMenuComponent|APIMentionableSelectComponent} other
       * The other data
       * @returns {MentionableSelectMenuBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = MentionableSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var MentionableSelectMenuComponent = class extends BaseSelectMenuComponent {
    };
    module2.exports = MentionableSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { RoleSelectMenuBuilder: BuildersRoleSelectMenu } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var RoleSelectMenuBuilder = class extends BuildersRoleSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from JSON data
       * @param {RoleSelectMenuBuilder|RoleSelectMenuComponent|APIRoleSelectComponent} other The other data
       * @returns {RoleSelectMenuBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = RoleSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/RoleSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var RoleSelectMenuComponent = class extends BaseSelectMenuComponent {
    };
    module2.exports = RoleSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { SelectMenuBuilder: BuildersSelectMenu, normalizeArray } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var StringSelectMenuBuilder = class _StringSelectMenuBuilder extends BuildersSelectMenu {
      constructor({ options, ...data } = {}) {
        super(
          toSnakeCase({
            ...data,
            options: options == null ? void 0 : options.map(({ emoji, ...option }) => ({
              ...option,
              emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
            }))
          })
        );
      }
      /**
       * Normalizes a select menu option emoji
       * @param {SelectMenuOptionData|APISelectMenuOption} selectMenuOption The option to normalize
       * @returns {SelectMenuOptionBuilder|APISelectMenuOption}
       * @private
       */
      static normalizeEmoji(selectMenuOption) {
        if (isJSONEncodable(selectMenuOption)) {
          return selectMenuOption;
        }
        const { emoji, ...option } = selectMenuOption;
        return {
          ...option,
          emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        };
      }
      /**
       * Adds options to this select menu
       * @param {RestOrArray<APISelectMenuOption>} options The options to add to this select menu
       * @returns {StringSelectMenuBuilder}
       */
      addOptions(...options) {
        return super.addOptions(normalizeArray(options).map((option) => _StringSelectMenuBuilder.normalizeEmoji(option)));
      }
      /**
       * Sets the options on this select menu
       * @param {RestOrArray<APISelectMenuOption>} options The options to set on this select menu
       * @returns {StringSelectMenuBuilder}
       */
      setOptions(...options) {
        return super.setOptions(normalizeArray(options).map((option) => _StringSelectMenuBuilder.normalizeEmoji(option)));
      }
      /**
       * Creates a new select menu builder from json data
       * @param {StringSelectMenuBuilder|StringSelectMenuComponent|APIStringSelectComponent} other The other data
       * @returns {StringSelectMenuBuilder}
       */
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = StringSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var StringSelectMenuComponent = class extends BaseSelectMenuComponent {
      /**
       * The options in this select menu
       * @type {APISelectMenuOption[]}
       * @readonly
       */
      get options() {
        return this.data.options;
      }
    };
    module2.exports = StringSelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS({
  "node_modules/discord.js/src/structures/TextInputBuilder.js"(exports2, module2) {
    "use strict";
    var { TextInputBuilder: BuildersTextInput } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var TextInputBuilder = class extends BuildersTextInput {
      constructor(data) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new text input builder from JSON data
       * @param {TextInputBuilder|TextInputComponent|APITextInputComponent} other The other data
       * @returns {TextInputBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = TextInputBuilder;
  }
});

// node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS({
  "node_modules/discord.js/src/structures/TextInputComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var TextInputComponent = class extends Component {
      /**
       * The custom id of this text input
       * @type {string}
       * @readonly
       */
      get customId() {
        return this.data.custom_id;
      }
      /**
       * The value for this text input
       * @type {string}
       * @readonly
       */
      get value() {
        return this.data.value;
      }
    };
    module2.exports = TextInputComponent;
  }
});

// node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/UserSelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { UserSelectMenuBuilder: BuildersUserSelectMenu } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var UserSelectMenuBuilder = class extends BuildersUserSelectMenu {
      constructor(data = {}) {
        super(toSnakeCase(data));
      }
      /**
       * Creates a new select menu builder from JSON data
       * @param {UserSelectMenuBuilder|UserSelectMenuComponent|APIUserSelectComponent} other The other data
       * @returns {UserSelectMenuBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = UserSelectMenuBuilder;
  }
});

// node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/UserSelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    var UserSelectMenuComponent = class extends BaseSelectMenuComponent {
    };
    module2.exports = UserSelectMenuComponent;
  }
});

// node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS({
  "node_modules/discord.js/src/util/Components.js"(exports2, module2) {
    "use strict";
    var { ComponentBuilder } = require_dist8();
    var { ComponentType } = require_v106();
    function createComponent(data) {
      if (data instanceof Component) {
        return data;
      }
      switch (data.type) {
        case ComponentType.ActionRow:
          return new ActionRow(data);
        case ComponentType.Button:
          return new ButtonComponent(data);
        case ComponentType.StringSelect:
          return new StringSelectMenuComponent(data);
        case ComponentType.TextInput:
          return new TextInputComponent(data);
        case ComponentType.UserSelect:
          return new UserSelectMenuComponent(data);
        case ComponentType.RoleSelect:
          return new RoleSelectMenuComponent(data);
        case ComponentType.MentionableSelect:
          return new MentionableSelectMenuComponent(data);
        case ComponentType.ChannelSelect:
          return new ChannelSelectMenuComponent(data);
        default:
          return new Component(data);
      }
    }
    function createComponentBuilder(data) {
      if (data instanceof ComponentBuilder) {
        return data;
      }
      switch (data.type) {
        case ComponentType.ActionRow:
          return new ActionRowBuilder(data);
        case ComponentType.Button:
          return new ButtonBuilder(data);
        case ComponentType.StringSelect:
          return new StringSelectMenuBuilder(data);
        case ComponentType.TextInput:
          return new TextInputBuilder(data);
        case ComponentType.UserSelect:
          return new UserSelectMenuBuilder(data);
        case ComponentType.RoleSelect:
          return new RoleSelectMenuBuilder(data);
        case ComponentType.MentionableSelect:
          return new MentionableSelectMenuBuilder(data);
        case ComponentType.ChannelSelect:
          return new ChannelSelectMenuBuilder(data);
        default:
          return new ComponentBuilder(data);
      }
    }
    module2.exports = { createComponent, createComponentBuilder };
    var ActionRow = require_ActionRow();
    var ActionRowBuilder = require_ActionRowBuilder();
    var ButtonBuilder = require_ButtonBuilder();
    var ButtonComponent = require_ButtonComponent();
    var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
    var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
    var Component = require_Component();
    var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
    var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
    var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
    var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
    var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
    var StringSelectMenuComponent = require_StringSelectMenuComponent();
    var TextInputBuilder = require_TextInputBuilder();
    var TextInputComponent = require_TextInputComponent();
    var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
    var UserSelectMenuComponent = require_UserSelectMenuComponent();
  }
});

// node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ActionRowBuilder.js"(exports2, module2) {
    "use strict";
    var { ActionRowBuilder: BuildersActionRow } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { createComponentBuilder } = require_Components();
    var { toSnakeCase } = require_Transformers();
    var ActionRowBuilder = class extends BuildersActionRow {
      constructor({ components, ...data } = {}) {
        super({
          ...toSnakeCase(data),
          components: components == null ? void 0 : components.map((component) => createComponentBuilder(component))
        });
      }
      /**
       * Creates a new action row builder from JSON data
       * @param {ActionRow|ActionRowBuilder|APIActionRowComponent} other The other data
       * @returns {ActionRowBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = ActionRowBuilder;
  }
});

// browser-external:node:fs/promises
var require_promises = __commonJS({
  "browser-external:node:fs/promises"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs/promises" has been externalized for browser compatibility. Cannot access "node:fs/promises.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS({
  "node_modules/discord.js/src/structures/GuildScheduledEvent.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildScheduledEvent = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.guildId = data.guild_id;
        this._patch(data);
      }
      _patch(data) {
        var _a;
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ?? (this.channelId = null);
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        } else {
          this.creatorId ?? (this.creatorId = null);
        }
        if ("name" in data) {
          this.name = data.name;
        } else {
          this.name ?? (this.name = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("scheduled_start_time" in data) {
          this.scheduledStartTimestamp = Date.parse(data.scheduled_start_time);
        } else {
          this.scheduledStartTimestamp ?? (this.scheduledStartTimestamp = null);
        }
        if ("scheduled_end_time" in data) {
          this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
        } else {
          this.scheduledEndTimestamp ?? (this.scheduledEndTimestamp = null);
        }
        if ("privacy_level" in data) {
          this.privacyLevel = data.privacy_level;
        } else {
          this.privacyLevel ?? (this.privacyLevel = null);
        }
        if ("status" in data) {
          this.status = data.status;
        } else {
          this.status ?? (this.status = null);
        }
        if ("entity_type" in data) {
          this.entityType = data.entity_type;
        } else {
          this.entityType ?? (this.entityType = null);
        }
        if ("entity_id" in data) {
          this.entityId = data.entity_id;
        } else {
          this.entityId ?? (this.entityId = null);
        }
        if ("user_count" in data) {
          this.userCount = data.user_count;
        } else {
          this.userCount ?? (this.userCount = null);
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        } else {
          this.creator ?? (this.creator = this.client.users.resolve(this.creatorId));
        }
        if ("entity_metadata" in data) {
          if (data.entity_metadata) {
            this.entityMetadata = {
              location: data.entity_metadata.location ?? ((_a = this.entityMetadata) == null ? void 0 : _a.location) ?? null
            };
          } else {
            this.entityMetadata = null;
          }
        } else {
          this.entityMetadata ?? (this.entityMetadata = null);
        }
        if ("image" in data) {
          this.image = data.image;
        } else {
          this.image ?? (this.image = null);
        }
      }
      /**
       * Whether this guild scheduled event is partial.
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.name === null;
      }
      /**
       * The URL of this scheduled event's cover image
       * @param {BaseImageURLOptions} [options={}] Options for image URL
       * @returns {?string}
       */
      coverImageURL(options = {}) {
        return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
      }
      /**
       * The timestamp the guild scheduled event was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the guild scheduled event was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time the guild scheduled event will start at
       * <info>This can be potentially `null` only when it's an {@link AuditLogEntryTarget}</info>
       * @type {?Date}
       * @readonly
       */
      get scheduledStartAt() {
        return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
      }
      /**
       * The time the guild scheduled event will end at,
       * or `null` if the event does not have a scheduled time to end
       * @type {?Date}
       * @readonly
       */
      get scheduledEndAt() {
        return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
      }
      /**
       * The channel associated with this scheduled event
       * @type {?(VoiceChannel|StageChannel)}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild this scheduled event belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The URL to the guild scheduled event
       * @type {string}
       * @readonly
       */
      get url() {
        return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
      }
      /**
       * Options used to create an invite URL to a {@link GuildScheduledEvent}
       * @typedef {InviteCreateOptions} GuildScheduledEventInviteURLCreateOptions
       * @property {GuildInvitableChannelResolvable} [channel] The channel to create the invite in.
       * <warn>This is required when the `entityType` of `GuildScheduledEvent` is
       * {@link GuildScheduledEventEntityType.External}, gets ignored otherwise</warn>
       */
      /**
       * Creates an invite URL to this guild scheduled event.
       * @param {GuildScheduledEventInviteURLCreateOptions} [options] The options to create the invite
       * @returns {Promise<string>}
       */
      async createInviteURL(options) {
        let channelId = this.channelId;
        if (this.entityType === GuildScheduledEventEntityType.External) {
          if (!(options == null ? void 0 : options.channel))
            throw new DiscordjsError2(ErrorCodes2.InviteOptionsMissingChannel);
          channelId = this.guild.channels.resolveId(options.channel);
          if (!channelId)
            throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        }
        const invite = await this.guild.invites.create(channelId, options);
        return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
      }
      /**
       * Edits this guild scheduled event.
       * @param {GuildScheduledEventEditOptions} options The options to edit the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Edit a guild scheduled event
       * guildScheduledEvent.edit({ name: 'Party' })
       *  .then(guildScheduledEvent => console.log(guildScheduledEvent))
       *  .catch(console.error);
       */
      edit(options) {
        return this.guild.scheduledEvents.edit(this.id, options);
      }
      /**
       * Fetches this guild scheduled event.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildScheduledEvent>}
       */
      fetch(force = true) {
        return this.guild.scheduledEvents.fetch({ guildScheduledEvent: this.id, force });
      }
      /**
       * Deletes this guild scheduled event.
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Delete a guild scheduled event
       * guildScheduledEvent.delete()
       *  .then(guildScheduledEvent => console.log(guildScheduledEvent))
       *  .catch(console.error);
       */
      async delete() {
        await this.guild.scheduledEvents.delete(this.id);
        return this;
      }
      /**
       * Sets a new name for the guild scheduled event.
       * @param {string} name The new name of the guild scheduled event
       * @param {string} [reason] The reason for changing the name
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set name of a guild scheduled event
       * guildScheduledEvent.setName('Birthday Party')
       *  .then(guildScheduledEvent => console.log(`Set the name to: ${guildScheduledEvent.name}`))
       *  .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets a new time to schedule the event at.
       * @param {DateResolvable} scheduledStartTime The time to schedule the event at
       * @param {string} [reason] The reason for changing the scheduled start time
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set start time of a guild scheduled event
       * guildScheduledEvent.setScheduledStartTime('2022-09-24T00:00:00+05:30')
       *  .then(guildScheduledEvent => console.log(`Set the start time to: ${guildScheduledEvent.scheduledStartTime}`))
       *  .catch(console.error);
       */
      setScheduledStartTime(scheduledStartTime, reason) {
        return this.edit({ scheduledStartTime, reason });
      }
      // TODO: scheduledEndTime gets reset on passing null but it hasn't been documented
      /**
       * Sets a new time to end the event at.
       * @param {DateResolvable} scheduledEndTime The time to end the event at
       * @param {string} [reason] The reason for changing the scheduled end time
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set end time of a guild scheduled event
       * guildScheduledEvent.setScheduledEndTime('2022-09-25T00:00:00+05:30')
       *  .then(guildScheduledEvent => console.log(`Set the end time to: ${guildScheduledEvent.scheduledEndTime}`))
       *  .catch(console.error);
       */
      setScheduledEndTime(scheduledEndTime, reason) {
        return this.edit({ scheduledEndTime, reason });
      }
      /**
       * Sets the new description of the guild scheduled event.
       * @param {string} description The description of the guild scheduled event
       * @param {string} [reason] The reason for changing the description
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set description of a guild scheduled event
       * guildScheduledEvent.setDescription('A virtual birthday party')
       *  .then(guildScheduledEvent => console.log(`Set the description to: ${guildScheduledEvent.description}`))
       *  .catch(console.error);
       */
      setDescription(description, reason) {
        return this.edit({ description, reason });
      }
      /**
       * Sets the new status of the guild scheduled event.
       * <info>If you're working with TypeScript, use this method in conjunction with status type-guards
       * like {@link GuildScheduledEvent#isScheduled} to get only valid status as suggestion</info>
       * @param {GuildScheduledEventStatus} status The status of the guild scheduled event
       * @param {string} [reason] The reason for changing the status
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set status of a guild scheduled event
       * guildScheduledEvent.setStatus(GuildScheduledEventStatus.Active)
       *  .then(guildScheduledEvent => console.log(`Set the status to: ${guildScheduledEvent.status}`))
       *  .catch(console.error);
       */
      setStatus(status, reason) {
        return this.edit({ status, reason });
      }
      /**
       * Sets the new location of the guild scheduled event.
       * @param {string} location The location of the guild scheduled event
       * @param {string} [reason] The reason for changing the location
       * @returns {Promise<GuildScheduledEvent>}
       * @example
       * // Set location of a guild scheduled event
       * guildScheduledEvent.setLocation('Earth')
       *  .then(guildScheduledEvent => console.log(`Set the location to: ${guildScheduledEvent.entityMetadata.location}`))
       *  .catch(console.error);
       */
      setLocation(location, reason) {
        return this.edit({ entityMetadata: { location }, reason });
      }
      /**
       * Fetches subscribers of this guild scheduled event.
       * @param {FetchGuildScheduledEventSubscribersOptions} [options] Options for fetching the subscribers
       * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}
       */
      fetchSubscribers(options) {
        return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
      }
      /**
       * When concatenated with a string, this automatically concatenates the event's URL instead of the object.
       * @returns {string}
       * @example
       * // Logs: Event: https://discord.com/events/412345678901234567/499876543211234567
       * console.log(`Event: ${guildScheduledEvent}`);
       */
      toString() {
        return this.url;
      }
      /**
       * Indicates whether this guild scheduled event has an {@link GuildScheduledEventStatus.Active} status.
       * @returns {boolean}
       */
      isActive() {
        return this.status === GuildScheduledEventStatus.Active;
      }
      /**
       * Indicates whether this guild scheduled event has a {@link GuildScheduledEventStatus.Canceled} status.
       * @returns {boolean}
       */
      isCanceled() {
        return this.status === GuildScheduledEventStatus.Canceled;
      }
      /**
       * Indicates whether this guild scheduled event has a {@link GuildScheduledEventStatus.Completed} status.
       * @returns {boolean}
       */
      isCompleted() {
        return this.status === GuildScheduledEventStatus.Completed;
      }
      /**
       * Indicates whether this guild scheduled event has a {@link GuildScheduledEventStatus.Scheduled} status.
       * @returns {boolean}
       */
      isScheduled() {
        return this.status === GuildScheduledEventStatus.Scheduled;
      }
    };
    exports2.GuildScheduledEvent = GuildScheduledEvent;
  }
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/Application.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var Application = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        } else {
          this.name ?? (this.name = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ?? (this.icon = null);
        }
      }
      /**
       * The timestamp the application was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the application was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the application's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
      }
      /**
       * A link to this application's cover image.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      coverURL(options = {}) {
        return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
      }
      /**
       * When concatenated with a string, this automatically returns the application's name instead of the
       * Application object.
       * @returns {?string}
       * @example
       * // Logs: Application name: My App
       * console.log(`Application name: ${application}`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Application;
  }
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS({
  "node_modules/discord.js/src/structures/IntegrationApplication.js"(exports2, module2) {
    "use strict";
    var Application = require_Application();
    var IntegrationApplication = class extends Application {
      _patch(data) {
        super._patch(data);
        if ("bot" in data) {
          this.bot = this.client.users._add(data.bot);
        } else {
          this.bot ?? (this.bot = null);
        }
        if ("terms_of_service_url" in data) {
          this.termsOfServiceURL = data.terms_of_service_url;
        } else {
          this.termsOfServiceURL ?? (this.termsOfServiceURL = null);
        }
        if ("privacy_policy_url" in data) {
          this.privacyPolicyURL = data.privacy_policy_url;
        } else {
          this.privacyPolicyURL ?? (this.privacyPolicyURL = null);
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ?? (this.rpcOrigins = []);
        }
        if ("hook" in data) {
          this.hook = data.hook;
        } else {
          this.hook ?? (this.hook = null);
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ?? (this.cover = null);
        }
        if ("verify_key" in data) {
          this.verifyKey = data.verify_key;
        } else {
          this.verifyKey ?? (this.verifyKey = null);
        }
      }
    };
    module2.exports = IntegrationApplication;
  }
});

// node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS({
  "node_modules/discord.js/src/structures/InviteStageInstance.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Base = require_Base();
    var InviteStageInstance = class extends Base {
      constructor(client, data, channelId, guildId) {
        super(client);
        this.channelId = channelId;
        this.guildId = guildId;
        this.members = new Collection2();
        this._patch(data);
      }
      _patch(data) {
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("participant_count" in data) {
          this.participantCount = data.participant_count;
        }
        if ("speaker_count" in data) {
          this.speakerCount = data.speaker_count;
        }
        this.members.clear();
        for (const rawMember of data.members) {
          const member = this.guild.members._add(rawMember);
          this.members.set(member.id, member);
        }
      }
      /**
       * The stage channel this invite is for
       * @type {?StageChannel}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild of the stage channel this invite is for
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
    };
    module2.exports = InviteStageInstance;
  }
});

// node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuild.js"(exports2, module2) {
    "use strict";
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2, GuildFeature } = require_v106();
    var Base = require_Base();
    var BaseGuild = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.name = data.name;
        this.icon = data.icon;
        this.features = data.features;
      }
      /**
       * The timestamp this guild was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this guild was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The acronym that shows up in place of a guild icon
       * @type {string}
       * @readonly
       */
      get nameAcronym() {
        return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
      }
      /**
       * Whether this guild is partnered
       * @type {boolean}
       * @readonly
       */
      get partnered() {
        return this.features.includes(GuildFeature.Partnered);
      }
      /**
       * Whether this guild is verified
       * @type {boolean}
       * @readonly
       */
      get verified() {
        return this.features.includes(GuildFeature.Verified);
      }
      /**
       * The URL to this guild's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
      }
      /**
       * Fetches this guild.
       * @returns {Promise<Guild>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.guild(this.id), {
          query: makeURLSearchParams2({ with_counts: true })
        });
        return this.client.guilds._add(data);
      }
      /**
       * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
    };
    module2.exports = BaseGuild;
  }
});

// node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS({
  "node_modules/discord.js/src/structures/AnonymousGuild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var AnonymousGuild = class extends BaseGuild {
      constructor(client, data, immediatePatch = true) {
        super(client, data);
        if (immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        if ("features" in data)
          this.features = data.features;
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("banner" in data) {
          this.banner = data.banner;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("verification_level" in data) {
          this.verificationLevel = data.verification_level;
        }
        if ("vanity_url_code" in data) {
          this.vanityURLCode = data.vanity_url_code;
        }
        if ("nsfw_level" in data) {
          this.nsfwLevel = data.nsfw_level;
        }
        if ("premium_subscription_count" in data) {
          this.premiumSubscriptionCount = data.premium_subscription_count;
        } else {
          this.premiumSubscriptionCount ?? (this.premiumSubscriptionCount = null);
        }
      }
      /**
       * The URL to this guild's banner.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      bannerURL(options = {}) {
        return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
      }
      /**
       * The URL to this guild's invite splash image.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      splashURL(options = {}) {
        return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
      }
    };
    module2.exports = AnonymousGuild;
  }
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS({
  "node_modules/discord.js/src/structures/Emoji.js"(exports2) {
    "use strict";
    var process2 = require_node_process();
    var { formatEmoji } = require_dist7();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var deprecationEmittedForURL = false;
    var Emoji = class extends Base {
      constructor(client, emoji) {
        super(client);
        this.animated = emoji.animated ?? null;
        this.name = emoji.name ?? null;
        this.id = emoji.id ?? null;
      }
      /**
       * The identifier of this emoji, used for message reactions
       * @type {string}
       * @readonly
       */
      get identifier() {
        if (this.id)
          return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
        return encodeURIComponent(this.name);
      }
      /**
       * Returns a URL for the emoji or `null` if this is not a custom emoji.
       * @param {BaseImageURLOptions} [options] Options for the image URL
       * @returns {?string}
       */
      imageURL(options) {
        return this.id && this.client.rest.cdn.emoji(this.id, options);
      }
      /**
       * Returns a URL for the emoji or `null` if this is not a custom emoji.
       * @type {?string}
       * @readonly
       * @deprecated Use {@link Emoji#imageURL} instead.
       */
      get url() {
        if (!deprecationEmittedForURL) {
          process2.emitWarning("The Emoji#url getter is deprecated. Use Emoji#imageURL() instead.", "DeprecationWarning");
          deprecationEmittedForURL = true;
        }
        return this.imageURL({ extension: this.animated ? "gif" : "png" });
      }
      /**
       * The timestamp the emoji was created at, or null if unicode
       * @type {?number}
       * @readonly
       */
      get createdTimestamp() {
        return this.id && DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the emoji was created at, or null if unicode
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.id && new Date(this.createdTimestamp);
      }
      /**
       * When concatenated with a string, this automatically returns the text required to form a graphical emoji on Discord
       * instead of the Emoji object.
       * @returns {string}
       * @example
       * // Send a custom emoji from a guild:
       * const emoji = guild.emojis.cache.first();
       * msg.channel.send(`Hello! ${emoji}`);
       * @example
       * // Send the emoji used in a reaction to the channel the reaction is part of
       * reaction.message.channel.send(`The emoji used was: ${reaction.emoji}`);
       */
      toString() {
        return this.id ? formatEmoji(this.id, this.animated) : this.name;
      }
      toJSON() {
        return super.toJSON({
          guild: "guildId",
          createdTimestamp: true,
          url: true,
          identifier: true
        });
      }
    };
    exports2.Emoji = Emoji;
  }
});

// node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS({
  "node_modules/discord.js/src/structures/WelcomeChannel.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var WelcomeChannel = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description;
        this._emoji = {
          name: data.emoji_name,
          id: data.emoji_id
        };
        this.channelId = data.channel_id;
      }
      /**
       * The channel of this welcome channel
       * @type {?(TextChannel|NewsChannel|ForumChannel|MediaChannel)}
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The emoji of this welcome channel
       * @type {GuildEmoji|Emoji}
       */
      get emoji() {
        return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
      }
    };
    module2.exports = WelcomeChannel;
  }
});

// node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS({
  "node_modules/discord.js/src/structures/WelcomeScreen.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { GuildFeature } = require_v106();
    var Base = require_Base();
    var WelcomeChannel = require_WelcomeChannel();
    var WelcomeScreen = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description ?? null;
        this.welcomeChannels = new Collection2();
        for (const channel of data.welcome_channels) {
          const welcomeChannel = new WelcomeChannel(this.guild, channel);
          this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
        }
      }
      /**
       * Whether the welcome screen is enabled on the guild
       * @type {boolean}
       */
      get enabled() {
        return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
      }
    };
    module2.exports = WelcomeScreen;
  }
});

// node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS({
  "node_modules/discord.js/src/structures/InviteGuild.js"(exports2, module2) {
    "use strict";
    var AnonymousGuild = require_AnonymousGuild();
    var WelcomeScreen = require_WelcomeScreen();
    var InviteGuild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data);
        this.welcomeScreen = data.welcome_screen !== void 0 ? new WelcomeScreen(this, data.welcome_screen) : null;
      }
    };
    module2.exports = InviteGuild;
  }
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS({
  "node_modules/discord.js/src/structures/Invite.js"(exports2, module2) {
    "use strict";
    var { RouteBases, Routes: Routes2, PermissionFlagsBits } = require_v106();
    var Base = require_Base();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var IntegrationApplication = require_IntegrationApplication();
    var InviteStageInstance = require_InviteStageInstance();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Invite2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        const InviteGuild = require_InviteGuild();
        this.guild ?? (this.guild = null);
        if (data.guild) {
          this.guild = this.client.guilds.resolve(data.guild.id) ?? new InviteGuild(this.client, data.guild);
        }
        if ("code" in data) {
          this.code = data.code;
        }
        if ("approximate_presence_count" in data) {
          this.presenceCount = data.approximate_presence_count;
        } else {
          this.presenceCount ?? (this.presenceCount = null);
        }
        if ("approximate_member_count" in data) {
          this.memberCount = data.approximate_member_count;
        } else {
          this.memberCount ?? (this.memberCount = null);
        }
        if ("temporary" in data) {
          this.temporary = data.temporary ?? null;
        } else {
          this.temporary ?? (this.temporary = null);
        }
        if ("max_age" in data) {
          this.maxAge = data.max_age;
        } else {
          this.maxAge ?? (this.maxAge = null);
        }
        if ("uses" in data) {
          this.uses = data.uses;
        } else {
          this.uses ?? (this.uses = null);
        }
        if ("max_uses" in data) {
          this.maxUses = data.max_uses;
        } else {
          this.maxUses ?? (this.maxUses = null);
        }
        if ("inviter_id" in data) {
          this.inviterId = data.inviter_id;
        } else {
          this.inviterId ?? (this.inviterId = null);
        }
        if ("inviter" in data) {
          this.client.users._add(data.inviter);
          this.inviterId = data.inviter.id;
        }
        if ("target_user" in data) {
          this.targetUser = this.client.users._add(data.target_user);
        } else {
          this.targetUser ?? (this.targetUser = null);
        }
        if ("target_application" in data) {
          this.targetApplication = new IntegrationApplication(this.client, data.target_application);
        } else {
          this.targetApplication ?? (this.targetApplication = null);
        }
        if ("target_type" in data) {
          this.targetType = data.target_type;
        } else {
          this.targetType ?? (this.targetType = null);
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("channel" in data) {
          this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
          this.channelId ?? (this.channelId = data.channel.id);
        }
        if ("created_at" in data) {
          this.createdTimestamp = Date.parse(data.created_at);
        } else {
          this.createdTimestamp ?? (this.createdTimestamp = null);
        }
        if ("expires_at" in data) {
          this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
        } else {
          this._expiresTimestamp ?? (this._expiresTimestamp = null);
        }
        if ("stage_instance" in data) {
          this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
        } else {
          this.stageInstance ?? (this.stageInstance = null);
        }
        if ("guild_scheduled_event" in data) {
          this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
        } else {
          this.guildScheduledEvent ?? (this.guildScheduledEvent = null);
        }
      }
      /**
       * The time the invite was created at
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      /**
       * Whether the invite is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        var _a;
        const guild = this.guild;
        if (!guild || !this.client.guilds.cache.has(guild.id))
          return false;
        if (!guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return Boolean(
          ((_a = this.channel) == null ? void 0 : _a.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false)) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild)
        );
      }
      /**
       * The timestamp the invite will expire at
       * @type {?number}
       * @readonly
       */
      get expiresTimestamp() {
        return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1e3 : null);
      }
      /**
       * The time the invite will expire at
       * @type {?Date}
       * @readonly
       */
      get expiresAt() {
        return this.expiresTimestamp && new Date(this.expiresTimestamp);
      }
      /**
       * The user who created this invite
       * @type {?User}
       * @readonly
       */
      get inviter() {
        return this.inviterId && this.client.users.resolve(this.inviterId);
      }
      /**
       * The URL to the invite
       * @type {string}
       * @readonly
       */
      get url() {
        return `${RouteBases.invite}/${this.code}`;
      }
      /**
       * Deletes this invite.
       * @param {string} [reason] Reason for deleting this invite
       * @returns {Promise<Invite>}
       */
      async delete(reason) {
        await this.client.rest.delete(Routes2.invite(this.code), { reason });
        return this;
      }
      /**
       * When concatenated with a string, this automatically concatenates the invite's URL instead of the object.
       * @returns {string}
       * @example
       * // Logs: Invite: https://discord.gg/A1b2C3
       * console.log(`Invite: ${invite}`);
       */
      toString() {
        return this.url;
      }
      toJSON() {
        return super.toJSON({
          url: true,
          expiresTimestamp: true,
          presenceCount: false,
          memberCount: false,
          uses: false,
          channel: "channelId",
          inviter: "inviterId",
          guild: "guildId"
        });
      }
      valueOf() {
        return this.code;
      }
    };
    /**
     * A regular expression that matches Discord invite links.
     * The `code` group property is present on the `exec()` result of this expression.
     * @type {RegExp}
     * @memberof Invite
     */
    __publicField(Invite2, "InvitesPattern", /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i);
    module2.exports = Invite2;
  }
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS({
  "node_modules/discord.js/src/structures/GuildTemplate.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require_node_timers();
    var { RouteBases, Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var DataResolver2 = require_DataResolver();
    var Events2 = require_Events();
    var GuildTemplate2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        if ("code" in data) {
          this.code = data.code;
        }
        if ("name" in data) {
          this.name = data.name;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("usage_count" in data) {
          this.usageCount = data.usage_count;
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        }
        if ("created_at" in data) {
          this.createdTimestamp = Date.parse(data.created_at);
        }
        if ("updated_at" in data) {
          this.updatedTimestamp = Date.parse(data.updated_at);
        }
        if ("source_guild_id" in data) {
          this.guildId = data.source_guild_id;
        }
        if ("serialized_source_guild" in data) {
          this.serializedGuild = data.serialized_source_guild;
        }
        this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
        return this;
      }
      /**
       * Creates a guild based on this template.
       * <warn>This is only available to bots in fewer than 10 guilds.</warn>
       * @param {string} name The name of the guild
       * @param {BufferResolvable|Base64Resolvable} [icon] The icon for the guild
       * @returns {Promise<Guild>}
       */
      async createGuild(name, icon) {
        const { client } = this;
        const data = await client.rest.post(Routes2.template(this.code), {
          body: {
            name,
            icon: await DataResolver2.resolveImage(icon)
          }
        });
        if (client.guilds.cache.has(data.id))
          return client.guilds.cache.get(data.id);
        return new Promise((resolve) => {
          const resolveGuild = (guild) => {
            client.off(Events2.GuildCreate, handleGuild);
            client.decrementMaxListeners();
            resolve(guild);
          };
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout2(timeout);
              resolveGuild(guild);
            }
          };
          client.incrementMaxListeners();
          client.on(Events2.GuildCreate, handleGuild);
          const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
        });
      }
      /**
       * Options used to edit a guild template.
       * @typedef {Object} GuildTemplateEditOptions
       * @property {string} [name] The name of this template
       * @property {string} [description] The description of this template
       */
      /**
       * Updates the metadata of this template.
       * @param {GuildTemplateEditOptions} [options] Options for editing the template
       * @returns {Promise<GuildTemplate>}
       */
      async edit({ name, description } = {}) {
        const data = await this.client.rest.patch(Routes2.guildTemplate(this.guildId, this.code), {
          body: { name, description }
        });
        return this._patch(data);
      }
      /**
       * Deletes this template.
       * @returns {Promise<GuildTemplate>}
       */
      async delete() {
        await this.client.rest.delete(Routes2.guildTemplate(this.guildId, this.code));
        return this;
      }
      /**
       * Syncs this template to the current state of the guild.
       * @returns {Promise<GuildTemplate>}
       */
      async sync() {
        const data = await this.client.rest.put(Routes2.guildTemplate(this.guildId, this.code));
        return this._patch(data);
      }
      /**
       * The time when this template was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time when this template was last synced to the guild
       * @type {Date}
       * @readonly
       */
      get updatedAt() {
        return new Date(this.updatedTimestamp);
      }
      /**
       * The guild that this template belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The URL of this template
       * @type {string}
       * @readonly
       */
      get url() {
        return `${RouteBases.template}/${this.code}`;
      }
      /**
       * When concatenated with a string, this automatically returns the template's code instead of the template object.
       * @returns {string}
       * @example
       * // Logs: Template: FKvmczH2HyUf
       * console.log(`Template: ${guildTemplate}!`);
       */
      toString() {
        return this.code;
      }
    };
    /**
     * A regular expression that matches guild template links.
     * The `code` group property is present on the `exec()` result of this expression.
     * @type {RegExp}
     * @memberof GuildTemplate
     */
    __publicField(GuildTemplate2, "GuildTemplatesPattern", /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i);
    module2.exports = GuildTemplate2;
  }
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS({
  "node_modules/discord.js/src/util/DataResolver.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var fs = require_promises();
    var path = require_node_path();
    var { fetch: fetch2 } = require_undici();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Invite2 = require_Invite();
    var DataResolver2 = class extends null {
      /**
       * Data that can be resolved to give an invite code. This can be:
       * * An invite code
       * * An invite URL
       * @typedef {string} InviteResolvable
       */
      /**
       * Data that can be resolved to give a template code. This can be:
       * * A template code
       * * A template URL
       * @typedef {string} GuildTemplateResolvable
       */
      /**
       * Resolves the string to a code based on the passed regex.
       * @param {string} data The string to resolve
       * @param {RegExp} regex The RegExp used to extract the code
       * @returns {string}
       */
      static resolveCode(data, regex) {
        var _a;
        return ((_a = regex.exec(data)) == null ? void 0 : _a[1]) ?? data;
      }
      /**
       * Resolves InviteResolvable to an invite code.
       * @param {InviteResolvable} data The invite resolvable to resolve
       * @returns {string}
       */
      static resolveInviteCode(data) {
        return this.resolveCode(data, Invite2.InvitesPattern);
      }
      /**
       * Resolves GuildTemplateResolvable to a template code.
       * @param {GuildTemplateResolvable} data The template resolvable to resolve
       * @returns {string}
       */
      static resolveGuildTemplateCode(data) {
        const GuildTemplate2 = require_GuildTemplate();
        return this.resolveCode(data, GuildTemplate2.GuildTemplatesPattern);
      }
      /**
       * Resolves a Base64Resolvable, a string, or a BufferResolvable to a Base 64 image.
       * @param {BufferResolvable|Base64Resolvable} image The image to be resolved
       * @returns {Promise<?string>}
       */
      static async resolveImage(image) {
        if (!image)
          return null;
        if (typeof image === "string" && image.startsWith("data:")) {
          return image;
        }
        const file = await this.resolveFile(image);
        return this.resolveBase64(file.data);
      }
      /**
       * Data that resolves to give a Base64 string, typically for image uploading. This can be:
       * * A Buffer
       * * A base64 string
       * @typedef {Buffer|string} Base64Resolvable
       */
      /**
       * Resolves a Base64Resolvable to a Base 64 image.
       * @param {Base64Resolvable} data The base 64 resolvable you want to resolve
       * @returns {?string}
       */
      static resolveBase64(data) {
        if (Buffer2.isBuffer(data))
          return `data:image/jpg;base64,${data.toString("base64")}`;
        return data;
      }
      /**
       * Data that can be resolved to give a Buffer. This can be:
       * * A Buffer
       * * The path to a local file
       * * A URL <warn>When provided a URL, discord.js will fetch the URL internally in order to create a Buffer.
       * This can pose a security risk when the URL has not been sanitized</warn>
       * @typedef {string|Buffer} BufferResolvable
       */
      /**
       * @external Stream
       * @see {@link https://nodejs.org/api/stream.html}
       */
      /**
       * @typedef {Object} ResolvedFile
       * @property {Buffer} data Buffer containing the file data
       * @property {string} [contentType] Content type of the file
       */
      /**
       * Resolves a BufferResolvable to a Buffer.
       * @param {BufferResolvable|Stream} resource The buffer or stream resolvable to resolve
       * @returns {Promise<ResolvedFile>}
       */
      static async resolveFile(resource) {
        if (Buffer2.isBuffer(resource))
          return { data: resource };
        if (typeof resource[Symbol.asyncIterator] === "function") {
          const buffers = [];
          for await (const data of resource)
            buffers.push(Buffer2.from(data));
          return { data: Buffer2.concat(buffers) };
        }
        if (typeof resource === "string") {
          if (/^https?:\/\//.test(resource)) {
            const res = await fetch2(resource);
            return { data: Buffer2.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
          }
          const file = path.resolve(resource);
          const stats = await fs.stat(file);
          if (!stats.isFile())
            throw new DiscordjsError2(ErrorCodes2.FileNotFound, file);
          return { data: await fs.readFile(file) };
        }
        throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
      }
    };
    module2.exports = DataResolver2;
  }
});

// node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/MessageFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { MessageFlags } = require_v106();
    var BitField = require_BitField();
    var MessageFlagsBitField = class extends BitField {
    };
    /**
     * Numeric message flags.
     * @type {MessageFlags}
     * @memberof MessageFlagsBitField
     */
    __publicField(MessageFlagsBitField, "Flags", MessageFlags);
    module2.exports = MessageFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS({
  "node_modules/discord.js/src/structures/BaseInteraction.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require_node_util();
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
    var Base = require_Base();
    var { SelectMenuTypes } = require_Constants();
    var PermissionsBitField2 = require_PermissionsBitField();
    var BaseInteraction = class extends Base {
      constructor(client, data) {
        var _a, _b, _c;
        super(client);
        this.type = data.type;
        this.id = data.id;
        Object.defineProperty(this, "token", { value: data.token });
        this.applicationId = data.application_id;
        this.channelId = ((_a = data.channel) == null ? void 0 : _a.id) ?? null;
        this.guildId = data.guild_id ?? null;
        this.user = this.client.users._add(data.user ?? data.member.user);
        this.member = data.member ? ((_b = this.guild) == null ? void 0 : _b.members._add(data.member)) ?? data.member : null;
        this.version = data.version;
        this.appPermissions = data.app_permissions ? new PermissionsBitField2(data.app_permissions).freeze() : null;
        this.memberPermissions = ((_c = data.member) == null ? void 0 : _c.permissions) ? new PermissionsBitField2(data.member.permissions).freeze() : null;
        this.locale = data.locale;
        this.guildLocale = data.guild_locale ?? null;
      }
      /**
       * The timestamp the interaction was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the interaction was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The channel this interaction was sent in
       * @type {?TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * The guild this interaction was sent in
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId) ?? null;
      }
      /**
       * Indicates whether this interaction is received from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return Boolean(this.guildId && this.member);
      }
      /**
       * Indicates whether or not this interaction is both cached and received from a guild.
       * @returns {boolean}
       */
      inCachedGuild() {
        return Boolean(this.guild && this.member);
      }
      /**
       * Indicates whether or not this interaction is received from an uncached guild.
       * @returns {boolean}
       */
      inRawGuild() {
        return Boolean(this.guildId && !this.guild && this.member);
      }
      /**
       * Indicates whether this interaction is an {@link AutocompleteInteraction}
       * @returns {boolean}
       */
      isAutocomplete() {
        return this.type === InteractionType.ApplicationCommandAutocomplete;
      }
      /**
       * Indicates whether this interaction is a {@link CommandInteraction}
       * @returns {boolean}
       */
      isCommand() {
        return this.type === InteractionType.ApplicationCommand;
      }
      /**
       * Indicates whether this interaction is a {@link ChatInputCommandInteraction}.
       * @returns {boolean}
       */
      isChatInputCommand() {
        return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
      }
      /**
       * Indicates whether this interaction is a {@link ContextMenuCommandInteraction}
       * @returns {boolean}
       */
      isContextMenuCommand() {
        return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
      }
      /**
       * Indicates whether this interaction is a {@link MessageComponentInteraction}
       * @returns {boolean}
       */
      isMessageComponent() {
        return this.type === InteractionType.MessageComponent;
      }
      /**
       * Indicates whether this interaction is a {@link ModalSubmitInteraction}
       * @returns {boolean}
       */
      isModalSubmit() {
        return this.type === InteractionType.ModalSubmit;
      }
      /**
       * Indicates whether this interaction is a {@link UserContextMenuCommandInteraction}
       * @returns {boolean}
       */
      isUserContextMenuCommand() {
        return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
      }
      /**
       * Indicates whether this interaction is a {@link MessageContextMenuCommandInteraction}
       * @returns {boolean}
       */
      isMessageContextMenuCommand() {
        return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
      }
      /**
       * Indicates whether this interaction is a {@link ButtonInteraction}.
       * @returns {boolean}
       */
      isButton() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
      }
      /**
       * Indicates whether this interaction is a {@link StringSelectMenuInteraction}.
       * @returns {boolean}
       * @deprecated Use {@link BaseInteraction#isStringSelectMenu} instead.
       */
      isSelectMenu() {
        return this.isStringSelectMenu();
      }
      /**
       * Indicates whether this interaction is a select menu of any known type.
       * @returns {boolean}
       */
      isAnySelectMenu() {
        return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
      }
      /**
       * Indicates whether this interaction is a {@link StringSelectMenuInteraction}.
       * @returns {boolean}
       */
      isStringSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
      }
      /**
       * Indicates whether this interaction is a {@link UserSelectMenuInteraction}
       * @returns {boolean}
       */
      isUserSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
      }
      /**
       * Indicates whether this interaction is a {@link RoleSelectMenuInteraction}
       * @returns {boolean}
       */
      isRoleSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
      }
      /**
       * Indicates whether this interaction is a {@link ChannelSelectMenuInteraction}
       * @returns {boolean}
       */
      isChannelSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
      }
      /**
       * Indicates whether this interaction is a {@link MentionableSelectMenuInteraction}
       * @returns {boolean}
       */
      isMentionableSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
      }
      /**
       * Indicates whether this interaction can be replied to.
       * @returns {boolean}
       */
      isRepliable() {
        return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
      }
    };
    BaseInteraction.prototype.isSelectMenu = deprecate(
      BaseInteraction.prototype.isSelectMenu,
      "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead."
    );
    module2.exports = BaseInteraction;
  }
});

// node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS({
  "node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js"(exports2) {
    "use strict";
    var ApplicationRoleConnectionMetadata = class {
      constructor(data) {
        this.name = data.name;
        this.nameLocalizations = data.name_localizations ?? null;
        this.description = data.description;
        this.descriptionLocalizations = data.description_localizations ?? null;
        this.key = data.key;
        this.type = data.type;
      }
    };
    exports2.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
  }
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS({
  "node_modules/discord.js/src/structures/TeamMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var TeamMember = class extends Base {
      constructor(team, data) {
        super(team.client);
        this.team = team;
        this._patch(data);
      }
      _patch(data) {
        if ("permissions" in data) {
          this.permissions = data.permissions;
        }
        if ("membership_state" in data) {
          this.membershipState = data.membership_state;
        }
        if ("user" in data) {
          this.user = this.client.users._add(data.user);
        }
        if ("role" in data) {
          this.role = data.role;
        }
      }
      /**
       * The Team Member's id
       * @type {Snowflake}
       * @readonly
       */
      get id() {
        return this.user.id;
      }
      /**
       * When concatenated with a string, this automatically returns the team member's mention instead of the
       * TeamMember object.
       * @returns {string}
       * @example
       * // Logs: Team Member's mention: <@123456789012345678>
       * console.log(`Team Member's mention: ${teamMember}`);
       */
      toString() {
        return this.user.toString();
      }
    };
    module2.exports = TeamMember;
  }
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS({
  "node_modules/discord.js/src/structures/Team.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var TeamMember = require_TeamMember();
    var Team = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ?? (this.icon = null);
        }
        if ("owner_user_id" in data) {
          this.ownerId = data.owner_user_id;
        } else {
          this.ownerId ?? (this.ownerId = null);
        }
        this.members = new Collection2();
        for (const memberData of data.members) {
          const member = new TeamMember(this, memberData);
          this.members.set(member.id, member);
        }
      }
      /**
       * The owner of this team
       * @type {?TeamMember}
       * @readonly
       */
      get owner() {
        return this.members.get(this.ownerId) ?? null;
      }
      /**
       * The timestamp the team was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the team was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the team's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
      }
      /**
       * When concatenated with a string, this automatically returns the Team's name instead of the
       * Team object.
       * @returns {string}
       * @example
       * // Logs: Team name: My Team
       * console.log(`Team name: ${team}`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Team;
  }
});

// node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS({
  "node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes: Routes2 } = require_v106();
    var BaseManager = require_BaseManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ApplicationCommandPermissionsManager = class extends BaseManager {
      constructor(manager) {
        var _a;
        super(manager.client);
        this.manager = manager;
        this.guild = manager.guild ?? null;
        this.guildId = manager.guildId ?? ((_a = manager.guild) == null ? void 0 : _a.id) ?? null;
        this.commandId = manager.id ?? null;
      }
      /**
       * The APIRouter path to the commands
       * @param {Snowflake} guildId The guild's id to use in the path,
       * @param {Snowflake} [commandId] The application command's id
       * @returns {string}
       * @private
       */
      permissionsPath(guildId, commandId) {
        if (commandId) {
          return Routes2.applicationCommandPermissions(this.client.application.id, guildId, commandId);
        }
        return Routes2.guildApplicationCommandsPermissions(this.client.application.id, guildId);
      }
      /* eslint-disable max-len */
      /**
       * The object returned when fetching permissions for an application command.
       * @typedef {Object} ApplicationCommandPermissions
       * @property {Snowflake} id The role, user, or channel's id. Can also be a
       * {@link https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-application-command-permissions-constants permission constant}.
       * @property {ApplicationCommandPermissionType} type Whether this permission is for a role or a user
       * @property {boolean} permission Whether the role or user has the permission to use this command
       */
      /* eslint-enable max-len */
      /**
       * Options for managing permissions for one or more Application Commands
       * <warn>When passing these options to a manager where `guildId` is `null`,
       * `guild` is a required parameter</warn>
       * @typedef {Object} BaseApplicationCommandPermissionsOptions
       * @property {GuildResolvable} [guild] The guild to modify / check permissions for
       * <warn>Ignored when the manager has a non-null `guildId` property</warn>
       * @property {ApplicationCommandResolvable} [command] The command to modify / check permissions for
       * <warn>Ignored when the manager has a non-null `commandId` property</warn>
       */
      /**
       * Fetches the permissions for one or multiple commands. Providing the client's id as the "command id" will fetch
       * *only* the guild level permissions
       * @param {BaseApplicationCommandPermissionsOptions} [options] Options used to fetch permissions
       * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
       * @example
       * // Fetch permissions for one command
       * guild.commands.permissions.fetch({ command: '123456789012345678' })
       *   .then(perms => console.log(`Fetched ${perms.length} overwrites`))
       *   .catch(console.error);
       * @example
       * // Fetch permissions for all commands in a guild
       * client.application.commands.permissions.fetch({ guild: '123456789012345678' })
       *   .then(perms => console.log(`Fetched permissions for ${perms.size} commands`))
       *   .catch(console.error);
       * @example
       * // Fetch guild level permissions
       * guild.commands.permissions.fetch({ command: client.user.id })
       *   .then(perms => console.log(`Fetched ${perms.length} guild level permissions`))
       *   .catch(console.error);
       */
      async fetch({ guild, command } = {}) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (commandId) {
          const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
          return data2.permissions;
        }
        const data = await this.client.rest.get(this.permissionsPath(guildId));
        return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection2());
      }
      /**
       * Options used to set permissions for one or more Application Commands in a guild
       * <warn>Omitting the `command` parameter edits the guild wide permissions
       * when the manager's `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} ApplicationCommandPermissionsEditOptions
       * @property {ApplicationCommandPermissions[]} permissions The new permissions for the guild or overwrite
       * @property {string} token The bearer token to use that authorizes the permission edit
       */
      /**
       * Sets the permissions for the guild or a command overwrite.
       * @param {ApplicationCommandPermissionsEditOptions} options Options used to set permissions
       * @returns {Promise<ApplicationCommandPermissions[]|Collection<Snowflake, ApplicationCommandPermissions[]>>}
       * @example
       * // Set a permission overwrite for a command
       * client.application.commands.permissions.set({
       *  guild: '892455839386304532',
       *  command: '123456789012345678',
       *  token: 'TotallyRealToken',
       *  permissions: [
       *    {
       *      id: '876543210987654321',
       *      type: ApplicationCommandPermissionType.User,
       *      permission: false,
       *    },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Set the permissions used for the guild (commands without overwrites)
       * guild.commands.permissions.set({ token: 'TotallyRealToken', permissions: [
       *   {
       *     id: '123456789012345678',
       *     permissions: [{
       *       id: '876543210987654321',
       *       type: ApplicationCommandPermissionType.User,
       *       permission: false,
       *     }],
       *   },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       */
      async set({ guild, command, permissions, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command);
        if (!Array.isArray(permissions)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissions",
            "Array of ApplicationCommandPermissions",
            true
          );
        }
        if (!commandId) {
          commandId = this.client.user.id;
        }
        const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
          body: { permissions },
          auth: false,
          headers: { Authorization: `Bearer ${token}` }
        });
        return data.permissions;
      }
      /**
       * Add permissions to a command.
       * @param {ApplicationCommandPermissionsEditOptions} options Options used to add permissions
       * @returns {Promise<ApplicationCommandPermissions[]>}
       * @example
       * // Add a rule to block a role from using a command
       * guild.commands.permissions.add({ command: '123456789012345678', token: 'TotallyRealToken', permissions: [
       *   {
       *     id: '876543211234567890',
       *     type: ApplicationCommandPermissionType.Role,
       *     permission: false
       *   },
       * ]})
       *   .then(console.log)
       *   .catch(console.error);
       */
      async add({ guild, command, permissions, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) {
          commandId = this.client.user.id;
        }
        if (!Array.isArray(permissions)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissions",
            "Array of ApplicationCommandPermissions",
            true
          );
        }
        let existingPermissions = [];
        try {
          existingPermissions = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        const newPermissions = permissions.slice();
        for (const existingPermission of existingPermissions) {
          if (!newPermissions.some((newPermission) => newPermission.id === existingPermission.id)) {
            newPermissions.push(existingPermission);
          }
        }
        return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
      }
      /**
       * A static snowflake that identifies the everyone role for application command permissions.
       * It is the same as the guild id
       * @typedef {Snowflake} RolePermissionConstant
       */
      /**
       * A static snowflake that identifies the "all channels" entity for application command permissions.
       * It will be the result of the calculation `guildId - 1`
       * @typedef {Snowflake} ChannelPermissionConstant
       */
      /**
       * Options used to remove permissions from a command
       * <warn>Omitting the `command` parameter removes from the guild wide permissions
       * when the managers `commandId` is `null`</warn>
       * <warn>At least one of `users`, `roles`, and `channels` is required</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} RemoveApplicationCommandPermissionsOptions
       * @property {string} token The bearer token to use that authorizes the permission removal
       * @property {UserResolvable[]} [users] The user(s) to remove
       * @property {Array<RoleResolvable|RolePermissionConstant>} [roles] The role(s) to remove
       * @property {Array<GuildChannelResolvable|ChannelPermissionConstant>} [channels] The channel(s) to remove
       */
      /**
       * Remove permissions from a command.
       * @param {RemoveApplicationCommandPermissionsOptions} options Options used to remove permissions
       * @returns {Promise<ApplicationCommandPermissions[]>}
       * @example
       * // Remove a user permission from this command
       * guild.commands.permissions.remove({
       *  command: '123456789012345678', users: '876543210123456789', token: 'TotallyRealToken',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove multiple roles from this command
       * guild.commands.permissions.remove({
       *   command: '123456789012345678', roles: ['876543210123456789', '765432101234567890'], token: 'TotallyRealToken',
       * })
       *    .then(console.log)
       *    .catch(console.error);
       */
      async remove({ guild, command, users, roles, channels, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId) {
          commandId = this.client.user.id;
        }
        if (!users && !roles && !channels) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
        }
        let resolvedUserIds = [];
        if (Array.isArray(users)) {
          for (const user of users) {
            const userId = this.client.users.resolveId(user);
            if (!userId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "users", user);
            resolvedUserIds.push(userId);
          }
        }
        let resolvedRoleIds = [];
        if (Array.isArray(roles)) {
          for (const role of roles) {
            if (typeof role === "string") {
              resolvedRoleIds.push(role);
              continue;
            }
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "roles");
            const roleId = this.guild.roles.resolveId(role);
            if (!roleId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "users", role);
            resolvedRoleIds.push(roleId);
          }
        }
        let resolvedChannelIds = [];
        if (Array.isArray(channels)) {
          for (const channel of channels) {
            if (typeof channel === "string") {
              resolvedChannelIds.push(channel);
              continue;
            }
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "channels");
            const channelId = this.guild.channels.resolveId(channel);
            if (!channelId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "channels", channel);
            resolvedChannelIds.push(channelId);
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        const permissions = existing.filter((perm) => {
          switch (perm.type) {
            case ApplicationCommandPermissionType.Role:
              return !resolvedRoleIds.includes(perm.id);
            case ApplicationCommandPermissionType.User:
              return !resolvedUserIds.includes(perm.id);
            case ApplicationCommandPermissionType.Channel:
              return !resolvedChannelIds.includes(perm.id);
          }
          return true;
        });
        return this.set({ guild: guildId, command: commandId, permissions, token });
      }
      /**
       * Options used to check the existence of permissions on a command
       * <warn>The `command` parameter is not optional when the managers `commandId` is `null`</warn>
       * @typedef {BaseApplicationCommandPermissionsOptions} HasApplicationCommandPermissionsOptions
       * @property {ApplicationCommandPermissionIdResolvable} permissionId The entity to check if a permission exists for
       * on this command.
       * @property {ApplicationCommandPermissionType} [permissionType] Check for a specific type of permission
       */
      /**
       * Check whether a permission exists for a user, role, or channel
       * @param {HasApplicationCommandPermissionsOptions} options Options used to check permissions
       * @returns {Promise<boolean>}
       * @example
       * // Check whether a user has permission to use a command
       * guild.commands.permissions.has({ command: '123456789012345678', permissionId: '876543210123456789' })
       *  .then(console.log)
       *  .catch(console.error);
       */
      async has({ guild, command, permissionId, permissionType }) {
        const { guildId, commandId } = this._validateOptions(guild, command);
        if (!commandId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        if (!permissionId) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissionId",
            "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant"
          );
        }
        let resolvedId = permissionId;
        if (typeof permissionId !== "string") {
          resolvedId = this.client.users.resolveId(permissionId);
          if (!resolvedId) {
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "roles");
            resolvedId = this.guild.roles.resolveId(permissionId);
          }
          if (!resolvedId) {
            resolvedId = this.guild.channels.resolveId(permissionId);
          }
          if (!resolvedId) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "permissionId",
              "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant"
            );
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
      }
      _validateOptions(guild, command) {
        var _a, _b, _c;
        const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
        if (!guildId)
          throw new DiscordjsError2(ErrorCodes2.GlobalCommandPermissions);
        let commandId = this.commandId;
        if (command && !commandId) {
          commandId = (_b = (_a = this.manager).resolveId) == null ? void 0 : _b.call(_a, command);
          if (!commandId && this.guild) {
            commandId = this.guild.commands.resolveId(command);
          }
          commandId ?? (commandId = (_c = this.client.application) == null ? void 0 : _c.commands.resolveId(command));
          if (!commandId) {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable", true);
          }
        }
        return { guildId, commandId };
      }
    };
    module2.exports = ApplicationCommandPermissionsManager;
  }
});

// node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS({
  "node_modules/discord.js/src/structures/ApplicationCommand.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { ApplicationCommandOptionType } = require_v106();
    var isEqual = require_fast_deep_equal();
    var Base = require_Base();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var PermissionsBitField2 = require_PermissionsBitField();
    var ApplicationCommand = class extends Base {
      constructor(client, data, guild, guildId) {
        super(client);
        this.id = data.id;
        this.applicationId = data.application_id;
        this.guild = guild ?? null;
        this.guildId = (guild == null ? void 0 : guild.id) ?? guildId ?? null;
        this.permissions = new ApplicationCommandPermissionsManager(this);
        this.type = data.type;
        this.nsfw = data.nsfw ?? false;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        if ("name_localizations" in data) {
          this.nameLocalizations = data.name_localizations;
        } else {
          this.nameLocalizations ?? (this.nameLocalizations = null);
        }
        if ("name_localized" in data) {
          this.nameLocalized = data.name_localized;
        } else {
          this.nameLocalized ?? (this.nameLocalized = null);
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("description_localizations" in data) {
          this.descriptionLocalizations = data.description_localizations;
        } else {
          this.descriptionLocalizations ?? (this.descriptionLocalizations = null);
        }
        if ("description_localized" in data) {
          this.descriptionLocalized = data.description_localized;
        } else {
          this.descriptionLocalized ?? (this.descriptionLocalized = null);
        }
        if ("options" in data) {
          this.options = data.options.map((option) => this.constructor.transformOption(option, true));
        } else {
          this.options ?? (this.options = []);
        }
        if ("default_member_permissions" in data) {
          this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField2(BigInt(data.default_member_permissions)).freeze() : null;
        } else {
          this.defaultMemberPermissions ?? (this.defaultMemberPermissions = null);
        }
        if ("dm_permission" in data) {
          this.dmPermission = data.dm_permission;
        } else {
          this.dmPermission ?? (this.dmPermission = null);
        }
        if ("version" in data) {
          this.version = data.version;
        }
      }
      /**
       * The timestamp the command was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the command was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The manager that this command belongs to
       * @type {ApplicationCommandManager}
       * @readonly
       */
      get manager() {
        return (this.guild ?? this.client.application).commands;
      }
      /**
       * Data for creating or editing an application command.
       * @typedef {Object} ApplicationCommandData
       * @property {string} name The name of the command, must be in all lowercase if type is
       * {@link ApplicationCommandType.ChatInput}
       * @property {Object<Locale, string>} [nameLocalizations] The localizations for the command name
       * @property {string} description The description of the command, if type is {@link ApplicationCommandType.ChatInput}
       * @property {boolean} [nsfw] Whether the command is age-restricted
       * @property {Object<Locale, string>} [descriptionLocalizations] The localizations for the command description,
       * if type is {@link ApplicationCommandType.ChatInput}
       * @property {ApplicationCommandType} [type=ApplicationCommandType.ChatInput] The type of the command
       * @property {ApplicationCommandOptionData[]} [options] Options for the command
       * @property {?PermissionResolvable} [defaultMemberPermissions] The bitfield used to determine the default permissions
       * a member needs in order to run the command
       * @property {boolean} [dmPermission] Whether the command is enabled in DMs
       */
      /**
       * An option for an application command or subcommand.
       * <info>In addition to the listed properties, when used as a parameter,
       * API style `snake_case` properties can be used for compatibility with generators like `@discordjs/builders`.</info>
       * <warn>Note that providing a value for the `camelCase` counterpart for any `snake_case` property
       * will discard the provided `snake_case` property.</warn>
       * @typedef {Object} ApplicationCommandOptionData
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {string} name The name of the option
       * @property {Object<Locale, string>} [nameLocalizations] The name localizations for the option
       * @property {string} description The description of the option
       * @property {Object<Locale, string>} [descriptionLocalizations] The description localizations for the option
       * @property {boolean} [autocomplete] Whether the autocomplete interaction is enabled for a
       * {@link ApplicationCommandOptionType.String}, {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {boolean} [required] Whether the option is required
       * @property {ApplicationCommandOptionChoiceData[]} [choices] The choices of the option for the user to pick from
       * @property {ApplicationCommandOptionData[]} [options] Additional options if this option is a subcommand (group)
       * @property {ChannelType[]} [channelTypes] When the option type is channel,
       * the allowed types of channels that can be selected
       * @property {number} [minValue] The minimum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [maxValue] The maximum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [minLength] The minimum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       * @property {number} [maxLength] The maximum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       */
      /**
       * @typedef {Object} ApplicationCommandOptionChoiceData
       * @property {string} name The name of the choice
       * @property {Object<Locale, string>} [nameLocalizations] The localized names for this choice
       * @property {string|number} value The value of the choice
       */
      /**
       * Edits this application command.
       * @param {Partial<ApplicationCommandData>} data The data to update the command with
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the description of this command
       * command.edit({
       *   description: 'New description',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      edit(data) {
        return this.manager.edit(this, data, this.guildId);
      }
      /**
       * Edits the name of this ApplicationCommand
       * @param {string} name The new name of the command
       * @returns {Promise<ApplicationCommand>}
       */
      setName(name) {
        return this.edit({ name });
      }
      /**
       * Edits the localized names of this ApplicationCommand
       * @param {Object<Locale, string>} nameLocalizations The new localized names for the command
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the name localizations of this command
       * command.setLocalizedNames({
       *   'en-GB': 'test',
       *   'pt-BR': 'teste',
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      setNameLocalizations(nameLocalizations) {
        return this.edit({ nameLocalizations });
      }
      /**
       * Edits the description of this ApplicationCommand
       * @param {string} description The new description of the command
       * @returns {Promise<ApplicationCommand>}
       */
      setDescription(description) {
        return this.edit({ description });
      }
      /**
       * Edits the localized descriptions of this ApplicationCommand
       * @param {Object<Locale, string>} descriptionLocalizations The new localized descriptions for the command
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit the description localizations of this command
       * command.setDescriptionLocalizations({
       *   'en-GB': 'A test command',
       *   'pt-BR': 'Um comando de teste',
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      setDescriptionLocalizations(descriptionLocalizations) {
        return this.edit({ descriptionLocalizations });
      }
      /**
       * Edits the default member permissions of this ApplicationCommand
       * @param {?PermissionResolvable} defaultMemberPermissions The default member permissions required to run this command
       * @returns {Promise<ApplicationCommand>}
       */
      setDefaultMemberPermissions(defaultMemberPermissions) {
        return this.edit({ defaultMemberPermissions });
      }
      /**
       * Edits the DM permission of this ApplicationCommand
       * @param {boolean} [dmPermission=true] Whether the command can be used in DMs
       * @returns {Promise<ApplicationCommand>}
       */
      setDMPermission(dmPermission = true) {
        return this.edit({ dmPermission });
      }
      /**
       * Edits the options of this ApplicationCommand
       * @param {ApplicationCommandOptionData[]} options The options to set for this command
       * @returns {Promise<ApplicationCommand>}
       */
      setOptions(options) {
        return this.edit({ options });
      }
      /**
       * Deletes this command.
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Delete this command
       * command.delete()
       *   .then(console.log)
       *   .catch(console.error);
       */
      delete() {
        return this.manager.delete(this, this.guildId);
      }
      /**
       * Whether this command equals another command. It compares all properties, so for most operations
       * it is advisable to just compare `command.id === command2.id` as it is much faster and is often
       * what most users need.
       * @param {ApplicationCommand|ApplicationCommandData|APIApplicationCommand} command The command to compare with
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same
       * order in the array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       */
      equals(command, enforceOptionOrder = false) {
        var _a, _b, _c;
        if (command.id && this.id !== command.id)
          return false;
        let defaultMemberPermissions = null;
        let dmPermission = command.dmPermission ?? command.dm_permission;
        if ("default_member_permissions" in command) {
          defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField2(BigInt(command.default_member_permissions)).bitfield : null;
        }
        if ("defaultMemberPermissions" in command) {
          defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField2(command.defaultMemberPermissions).bitfield : null;
        }
        if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || command.type && command.type !== this.type || "nsfw" in command && command.nsfw !== this.nsfw || // Future proof for options being nullable
        // TODO: remove ?? 0 on each when nullable
        (((_a = command.options) == null ? void 0 : _a.length) ?? 0) !== (((_b = this.options) == null ? void 0 : _b.length) ?? 0) || defaultMemberPermissions !== (((_c = this.defaultMemberPermissions) == null ? void 0 : _c.bitfield) ?? null) || dmPermission !== void 0 && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(
          command.descriptionLocalizations ?? command.description_localizations ?? {},
          this.descriptionLocalizations ?? {}
        )) {
          return false;
        }
        if (command.options) {
          return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
        }
        return true;
      }
      /**
       * Recursively checks that all options for an {@link ApplicationCommand} are equal to the provided options.
       * In most cases it is better to compare using {@link ApplicationCommand#equals}
       * @param {ApplicationCommandOptionData[]} existing The options on the existing command,
       * should be {@link ApplicationCommand#options}
       * @param {ApplicationCommandOptionData[]|APIApplicationCommandOption[]} options The options to compare against
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options and choices are in the same
       * order in the array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       */
      static optionsEqual(existing, options, enforceOptionOrder = false) {
        if (existing.length !== options.length)
          return false;
        if (enforceOptionOrder) {
          return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
        }
        const newOptions = new Map(options.map((option) => [option.name, option]));
        for (const option of existing) {
          const foundOption = newOptions.get(option.name);
          if (!foundOption || !this._optionEquals(option, foundOption))
            return false;
        }
        return true;
      }
      /**
       * Checks that an option for an {@link ApplicationCommand} is equal to the provided option
       * In most cases it is better to compare using {@link ApplicationCommand#equals}
       * @param {ApplicationCommandOptionData} existing The option on the existing command,
       * should be from {@link ApplicationCommand#options}
       * @param {ApplicationCommandOptionData|APIApplicationCommandOption} option The option to compare against
       * @param {boolean} [enforceOptionOrder=false] Whether to strictly check that options or choices are in the same
       * order in their array <info>The client may not always respect this ordering!</info>
       * @returns {boolean}
       * @private
       */
      static _optionEquals(existing, option, enforceOptionOrder = false) {
        var _a, _b, _c, _d, _e, _f;
        if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? void 0 : false)) !== existing.required || ((_a = option.choices) == null ? void 0 : _a.length) !== ((_b = existing.choices) == null ? void 0 : _b.length) || ((_c = option.options) == null ? void 0 : _c.length) !== ((_d = existing.options) == null ? void 0 : _d.length) || ((_e = option.channelTypes ?? option.channel_types) == null ? void 0 : _e.length) !== ((_f = existing.channelTypes) == null ? void 0 : _f.length) || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(
          option.descriptionLocalizations ?? option.description_localizations ?? {},
          existing.descriptionLocalizations ?? {}
        )) {
          return false;
        }
        if (existing.choices) {
          if (enforceOptionOrder && !existing.choices.every(
            (choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(
              choice.nameLocalizations ?? {},
              option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}
            )
          )) {
            return false;
          }
          if (!enforceOptionOrder) {
            const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
            for (const choice of existing.choices) {
              const foundChoice = newChoices.get(choice.name);
              if (!foundChoice || foundChoice.value !== choice.value)
                return false;
            }
          }
        }
        if (existing.channelTypes) {
          const newTypes = option.channelTypes ?? option.channel_types;
          for (const type of existing.channelTypes) {
            if (!newTypes.includes(type))
              return false;
          }
        }
        if (existing.options) {
          return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
        }
        return true;
      }
      /**
       * An option for an application command or subcommand.
       * @typedef {Object} ApplicationCommandOption
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {string} name The name of the option
       * @property {Object<Locale, string>} [nameLocalizations] The localizations for the option name
       * @property {string} [nameLocalized] The localized name for this option
       * @property {string} description The description of the option
       * @property {Object<Locale, string>} [descriptionLocalizations] The localizations for the option description
       * @property {string} [descriptionLocalized] The localized description for this option
       * @property {boolean} [required] Whether the option is required
       * @property {boolean} [autocomplete] Whether the autocomplete interaction is enabled for a
       * {@link ApplicationCommandOptionType.String}, {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {ApplicationCommandOptionChoice[]} [choices] The choices of the option for the user to pick from
       * @property {ApplicationCommandOption[]} [options] Additional options if this option is a subcommand (group)
       * @property {ApplicationCommandOptionAllowedChannelTypes[]} [channelTypes] When the option type is channel,
       * the allowed types of channels that can be selected
       * @property {number} [minValue] The minimum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [maxValue] The maximum value for an {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {number} [minLength] The minimum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       * @property {number} [maxLength] The maximum length for an {@link ApplicationCommandOptionType.String} option
       * (maximum of `6000`)
       */
      /**
       * A choice for an application command option.
       * @typedef {Object} ApplicationCommandOptionChoice
       * @property {string} name The name of the choice
       * @property {?string} nameLocalized The localized name of the choice in the provided locale, if any
       * @property {?Object<string, string>} [nameLocalizations] The localized names for this choice
       * @property {string|number} value The value of the choice
       */
      /**
       * Transforms an {@link ApplicationCommandOptionData} object into something that can be used with the API.
       * @param {ApplicationCommandOptionData|ApplicationCommandOption} option The option to transform
       * @param {boolean} [received] Whether this option has been received from Discord
       * @returns {APIApplicationCommandOption}
       * @private
       */
      static transformOption(option, received) {
        var _a, _b;
        const channelTypesKey = received ? "channelTypes" : "channel_types";
        const minValueKey = received ? "minValue" : "min_value";
        const maxValueKey = received ? "maxValue" : "max_value";
        const minLengthKey = received ? "minLength" : "min_length";
        const maxLengthKey = received ? "maxLength" : "max_length";
        const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
        const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
        const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
        const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
        return {
          type: option.type,
          name: option.name,
          [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
          [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
          description: option.description,
          [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
          [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
          required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? void 0 : false),
          autocomplete: option.autocomplete,
          choices: (_a = option.choices) == null ? void 0 : _a.map((choice) => ({
            name: choice.name,
            [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
            [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
            value: choice.value
          })),
          options: (_b = option.options) == null ? void 0 : _b.map((opt) => this.transformOption(opt, received)),
          [channelTypesKey]: option.channelTypes ?? option.channel_types,
          [minValueKey]: option.minValue ?? option.min_value,
          [maxValueKey]: option.maxValue ?? option.max_value,
          [minLengthKey]: option.minLength ?? option.min_length,
          [maxLengthKey]: option.maxLength ?? option.max_length
        };
      }
    };
    module2.exports = ApplicationCommand;
  }
});

// node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS({
  "node_modules/discord.js/src/managers/ApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { isJSONEncodable } = require_dist();
    var { Routes: Routes2 } = require_v106();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ApplicationCommand = require_ApplicationCommand();
    var PermissionsBitField2 = require_PermissionsBitField();
    var ApplicationCommandManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, ApplicationCommand, iterable);
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, ApplicationCommand>}
       * @name ApplicationCommandManager#cache
       */
      _add(data, cache, guildId) {
        return super._add(data, cache, { extras: [this.guild, guildId] });
      }
      /**
       * The APIRouter path to the commands
       * @param {Snowflake} [options.id] The application command's id
       * @param {Snowflake} [options.guildId] The guild's id to use in the path,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {string}
       * @private
       */
      commandPath({ id, guildId } = {}) {
        var _a, _b;
        if (this.guild ?? guildId) {
          if (id) {
            return Routes2.applicationGuildCommand(this.client.application.id, ((_a = this.guild) == null ? void 0 : _a.id) ?? guildId, id);
          }
          return Routes2.applicationGuildCommands(this.client.application.id, ((_b = this.guild) == null ? void 0 : _b.id) ?? guildId);
        }
        if (id) {
          return Routes2.applicationCommand(this.client.application.id, id);
        }
        return Routes2.applicationCommands(this.client.application.id);
      }
      /**
       * Data that resolves to give an ApplicationCommand object. This can be:
       * * An ApplicationCommand object
       * * A Snowflake
       * @typedef {ApplicationCommand|Snowflake} ApplicationCommandResolvable
       */
      /**
       * Data that resolves to the data of an ApplicationCommand
       * @typedef {ApplicationCommandData|APIApplicationCommand} ApplicationCommandDataResolvable
       */
      /**
       * Options used to fetch data from Discord
       * @typedef {Object} BaseFetchOptions
       * @property {boolean} [cache=true] Whether to cache the fetched data if it wasn't already
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Options used to fetch Application Commands from Discord
       * @typedef {BaseFetchOptions} FetchApplicationCommandOptions
       * @property {Snowflake} [guildId] The guild's id to fetch commands for, for when the guild is not cached
       * @property {LocaleString} [locale] The locale to use when fetching this command
       * @property {boolean} [withLocalizations] Whether to fetch all localization data
       */
      /**
       * Obtains one or multiple application commands from Discord, or the cache if it's already available.
       * @param {Snowflake|FetchApplicationCommandOptions} [id] Options for fetching application command(s)
       * @param {FetchApplicationCommandOptions} [options] Additional options for this fetch
       * @returns {Promise<ApplicationCommand|Collection<Snowflake, ApplicationCommand>>}
       * @example
       * // Fetch a single command
       * client.application.commands.fetch('123456789012345678')
       *   .then(command => console.log(`Fetched command ${command.name}`))
       *   .catch(console.error);
       * @example
       * // Fetch all commands
       * guild.commands.fetch()
       *   .then(commands => console.log(`Fetched ${commands.size} commands`))
       *   .catch(console.error);
       */
      async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
        if (typeof id === "object") {
          ({ guildId, cache = true, locale, withLocalizations } = id);
        } else if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const command = await this.client.rest.get(this.commandPath({ id, guildId }));
          return this._add(command, cache);
        }
        const data = await this.client.rest.get(this.commandPath({ guildId }), {
          headers: {
            "X-Discord-Locale": locale
          },
          query: makeURLSearchParams2({ with_localizations: withLocalizations })
        });
        return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection2());
      }
      /**
       * Creates an application command.
       * @param {ApplicationCommandDataResolvable} command The command
       * @param {Snowflake} [guildId] The guild's id to create this command in,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Create a new command
       * client.application.commands.create({
       *   name: 'test',
       *   description: 'A test command',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(command, guildId) {
        const data = await this.client.rest.post(this.commandPath({ guildId }), {
          body: this.constructor.transformCommand(command)
        });
        return this._add(data, true, guildId);
      }
      /**
       * Sets all the commands for this application or guild.
       * @param {ApplicationCommandDataResolvable[]} commands The commands
       * @param {Snowflake} [guildId] The guild's id to create the commands in,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<Collection<Snowflake, ApplicationCommand>>}
       * @example
       * // Set all commands to just this one
       * client.application.commands.set([
       *   {
       *     name: 'test',
       *     description: 'A test command',
       *   },
       * ])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all commands
       * guild.commands.set([])
       *   .then(console.log)
       *   .catch(console.error);
       */
      async set(commands, guildId) {
        const data = await this.client.rest.put(this.commandPath({ guildId }), {
          body: commands.map((command) => this.constructor.transformCommand(command))
        });
        return data.reduce(
          (collection, command) => collection.set(command.id, this._add(command, true, guildId)),
          new Collection2()
        );
      }
      /**
       * Edits an application command.
       * @param {ApplicationCommandResolvable} command The command to edit
       * @param {Partial<ApplicationCommandDataResolvable>} data The data to update the command with
       * @param {Snowflake} [guildId] The guild's id where the command registered,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<ApplicationCommand>}
       * @example
       * // Edit an existing command
       * client.application.commands.edit('123456789012345678', {
       *   description: 'New description',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async edit(command, data, guildId) {
        const id = this.resolveId(command);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
          body: this.constructor.transformCommand(data)
        });
        return this._add(patched, true, guildId);
      }
      /**
       * Deletes an application command.
       * @param {ApplicationCommandResolvable} command The command to delete
       * @param {Snowflake} [guildId] The guild's id where the command is registered,
       * ignored when using a {@link GuildApplicationCommandManager}
       * @returns {Promise<?ApplicationCommand>}
       * @example
       * // Delete a command
       * guild.commands.delete('123456789012345678')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(command, guildId) {
        const id = this.resolveId(command);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        await this.client.rest.delete(this.commandPath({ id, guildId }));
        const cached = this.cache.get(id);
        this.cache.delete(id);
        return cached ?? null;
      }
      /**
       * Transforms an {@link ApplicationCommandData} object into something that can be used with the API.
       * @param {ApplicationCommandDataResolvable} command The command to transform
       * @returns {APIApplicationCommand}
       * @private
       */
      static transformCommand(command) {
        var _a;
        if (isJSONEncodable(command))
          return command.toJSON();
        let default_member_permissions;
        if ("default_member_permissions" in command) {
          default_member_permissions = command.default_member_permissions ? new PermissionsBitField2(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
        }
        if ("defaultMemberPermissions" in command) {
          default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField2(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
        }
        return {
          name: command.name,
          name_localizations: command.nameLocalizations ?? command.name_localizations,
          description: command.description,
          nsfw: command.nsfw,
          description_localizations: command.descriptionLocalizations ?? command.description_localizations,
          type: command.type,
          options: (_a = command.options) == null ? void 0 : _a.map((option) => ApplicationCommand.transformOption(option)),
          default_member_permissions,
          dm_permission: command.dmPermission ?? command.dm_permission
        };
      }
    };
    module2.exports = ApplicationCommandManager;
  }
});

// node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ApplicationFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ApplicationFlags } = require_v106();
    var BitField = require_BitField();
    var ApplicationFlagsBitField = class extends BitField {
    };
    /**
     * Numeric application flags. All available properties:
     * @type {ApplicationFlags}
     * @memberof ApplicationFlagsBitField
     */
    __publicField(ApplicationFlagsBitField, "Flags", ApplicationFlags);
    module2.exports = ApplicationFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS({
  "node_modules/discord.js/src/structures/ClientApplication.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
    var Team = require_Team();
    var Application = require_Application();
    var ApplicationCommandManager = require_ApplicationCommandManager();
    var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
    var DataResolver2 = require_DataResolver();
    var PermissionsBitField2 = require_PermissionsBitField();
    var ClientApplication = class extends Application {
      constructor(client, data) {
        super(client, data);
        this.commands = new ApplicationCommandManager(this.client);
      }
      _patch(data) {
        super._patch(data);
        this.tags = data.tags ?? [];
        if ("install_params" in data) {
          this.installParams = {
            scopes: data.install_params.scopes,
            permissions: new PermissionsBitField2(data.install_params.permissions).freeze()
          };
        } else {
          this.installParams ?? (this.installParams = null);
        }
        if ("custom_install_url" in data) {
          this.customInstallURL = data.custom_install_url;
        } else {
          this.customInstallURL = null;
        }
        if ("flags" in data) {
          this.flags = new ApplicationFlagsBitField(data.flags).freeze();
        }
        if ("approximate_guild_count" in data) {
          this.approximateGuildCount = data.approximate_guild_count;
        } else {
          this.approximateGuildCount ?? (this.approximateGuildCount = null);
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        } else {
          this.guildId ?? (this.guildId = null);
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ?? (this.cover = null);
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ?? (this.rpcOrigins = []);
        }
        if ("bot_require_code_grant" in data) {
          this.botRequireCodeGrant = data.bot_require_code_grant;
        } else {
          this.botRequireCodeGrant ?? (this.botRequireCodeGrant = null);
        }
        if ("bot" in data) {
          this.bot = this.client.users._add(data.bot);
        } else {
          this.bot ?? (this.bot = null);
        }
        if ("bot_public" in data) {
          this.botPublic = data.bot_public;
        } else {
          this.botPublic ?? (this.botPublic = null);
        }
        if ("interactions_endpoint_url" in data) {
          this.interactionsEndpointURL = data.interactions_endpoint_url;
        } else {
          this.interactionsEndpointURL ?? (this.interactionsEndpointURL = null);
        }
        if ("role_connections_verification_url" in data) {
          this.roleConnectionsVerificationURL = data.role_connections_verification_url;
        } else {
          this.roleConnectionsVerificationURL ?? (this.roleConnectionsVerificationURL = null);
        }
        this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
      }
      /**
       * The guild associated with this application.
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId) ?? null;
      }
      /**
       * Whether this application is partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !this.name;
      }
      /**
       * Options used for editing an application.
       * @typedef {Object} ClientApplicationEditOptions
       * @property {string} [customInstallURL] The application's custom installation URL
       * @property {string} [description] The application's description
       * @property {string} [roleConnectionsVerificationURL] The application's role connection verification URL
       * @property {ClientApplicationInstallParams} [installParams]
       * Settings for the application's default in-app authorization
       * @property {ApplicationFlagsResolvable} [flags] The flags for the application
       * @property {?(BufferResolvable|Base64Resolvable)} [icon] The application's icon
       * @property {?(BufferResolvable|Base64Resolvable)} [coverImage] The application's cover image
       * @property {string} [interactionsEndpointURL] The application's interaction endpoint URL
       * @property {string[]} [tags] The application's tags
       */
      /**
       * Edits this application.
       * @param {ClientApplicationEditOptions} [options] The options for editing this application
       * @returns {Promise<ClientApplication>}
       */
      async edit({
        customInstallURL,
        description,
        roleConnectionsVerificationURL,
        installParams,
        flags,
        icon,
        coverImage,
        interactionsEndpointURL,
        tags
      } = {}) {
        const data = await this.client.rest.patch(Routes2.currentApplication(), {
          body: {
            custom_install_url: customInstallURL,
            description,
            role_connections_verification_url: roleConnectionsVerificationURL,
            install_params: installParams,
            flags: flags === void 0 ? void 0 : ApplicationFlagsBitField.resolve(flags),
            icon: icon && await DataResolver2.resolveImage(icon),
            cover_image: coverImage && await DataResolver2.resolveImage(coverImage),
            interactions_endpoint_url: interactionsEndpointURL,
            tags
          }
        });
        this._patch(data);
        return this;
      }
      /**
       * Obtains this application from Discord.
       * @returns {Promise<ClientApplication>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.currentApplication());
        this._patch(data);
        return this;
      }
      /**
       * Gets this application's role connection metadata records
       * @returns {Promise<ApplicationRoleConnectionMetadata[]>}
       */
      async fetchRoleConnectionMetadataRecords() {
        const metadata = await this.client.rest.get(Routes2.applicationRoleConnectionMetadata(this.client.user.id));
        return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
      }
      /**
       * Data for creating or editing an application role connection metadata.
       * @typedef {Object} ApplicationRoleConnectionMetadataEditOptions
       * @property {string} name The name of the metadata field
       * @property {?Object<Locale, string>} [nameLocalizations] The name localizations for the metadata field
       * @property {string} description The description of the metadata field
       * @property {?Object<Locale, string>} [descriptionLocalizations] The description localizations for the metadata field
       * @property {string} key The dictionary key of the metadata field
       * @property {ApplicationRoleConnectionMetadataType} type The type of the metadata field
       */
      /**
       * Updates this application's role connection metadata records
       * @param {ApplicationRoleConnectionMetadataEditOptions[]} records The new role connection metadata records
       * @returns {Promise<ApplicationRoleConnectionMetadata[]>}
       */
      async editRoleConnectionMetadataRecords(records) {
        const newRecords = await this.client.rest.put(Routes2.applicationRoleConnectionMetadata(this.client.user.id), {
          body: records.map((record) => ({
            type: record.type,
            key: record.key,
            name: record.name,
            name_localizations: record.nameLocalizations,
            description: record.description,
            description_localizations: record.descriptionLocalizations
          }))
        });
        return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
      }
    };
    module2.exports = ClientApplication;
  }
});

// node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS({
  "node_modules/discord.js/src/structures/Embed.js"(exports2, module2) {
    "use strict";
    var { embedLength } = require_dist8();
    var isEqual = require_fast_deep_equal();
    var Embed = class _Embed {
      constructor(data) {
        this.data = { ...data };
      }
      /**
       * An array of fields of this embed.
       * @type {Array<APIEmbedField>}
       * @readonly
       */
      get fields() {
        return this.data.fields ?? [];
      }
      /**
       * The title of this embed.
       * @type {?string}
       * @readonly
       */
      get title() {
        return this.data.title ?? null;
      }
      /**
       * The description of this embed.
       * @type {?string}
       * @readonly
       */
      get description() {
        return this.data.description ?? null;
      }
      /**
       * The URL of this embed.
       * @type {?string}
       * @readonly
       */
      get url() {
        return this.data.url ?? null;
      }
      /**
       * The color of this embed.
       * @type {?number}
       * @readonly
       */
      get color() {
        return this.data.color ?? null;
      }
      /**
       * The timestamp of this embed. This is in an ISO 8601 format.
       * @type {?string}
       * @readonly
       */
      get timestamp() {
        return this.data.timestamp ?? null;
      }
      /**
       * @typedef {Object} EmbedAssetData
       * @property {?string} url The URL of the image
       * @property {?string} proxyURL The proxy URL of the image
       * @property {?number} height The height of the image
       * @property {?number} width The width of the image
       */
      /**
       * The thumbnail of this embed.
       * @type {?EmbedAssetData}
       * @readonly
       */
      get thumbnail() {
        if (!this.data.thumbnail)
          return null;
        return {
          url: this.data.thumbnail.url,
          proxyURL: this.data.thumbnail.proxy_url,
          height: this.data.thumbnail.height,
          width: this.data.thumbnail.width
        };
      }
      /**
       * The image of this embed.
       * @type {?EmbedAssetData}
       * @readonly
       */
      get image() {
        if (!this.data.image)
          return null;
        return {
          url: this.data.image.url,
          proxyURL: this.data.image.proxy_url,
          height: this.data.image.height,
          width: this.data.image.width
        };
      }
      /**
       * The video of this embed.
       * @type {?EmbedAssetData}
       * @readonly
       */
      get video() {
        if (!this.data.video)
          return null;
        return {
          url: this.data.video.url,
          proxyURL: this.data.video.proxy_url,
          height: this.data.video.height,
          width: this.data.video.width
        };
      }
      /**
       * @typedef {Object} EmbedAuthorData
       * @property {string} name The name of the author
       * @property {?string} url The URL of the author
       * @property {?string} iconURL The icon URL of the author
       * @property {?string} proxyIconURL The proxy icon URL of the author
       */
      /**
       * The author of this embed.
       * @type {?EmbedAuthorData}
       * @readonly
       */
      get author() {
        if (!this.data.author)
          return null;
        return {
          name: this.data.author.name,
          url: this.data.author.url,
          iconURL: this.data.author.icon_url,
          proxyIconURL: this.data.author.proxy_icon_url
        };
      }
      /**
       * The provider of this embed.
       * @type {?APIEmbedProvider}
       * @readonly
       */
      get provider() {
        return this.data.provider ?? null;
      }
      /**
       * @typedef {Object} EmbedFooterData
       * @property {string} text The text of the footer
       * @property {?string} iconURL The URL of the icon
       * @property {?string} proxyIconURL The proxy URL of the icon
       */
      /**
       * The footer of this embed.
       * @type {?EmbedFooterData}
       * @readonly
       */
      get footer() {
        if (!this.data.footer)
          return null;
        return {
          text: this.data.footer.text,
          iconURL: this.data.footer.icon_url,
          proxyIconURL: this.data.footer.proxy_icon_url
        };
      }
      /**
       * The accumulated length for the embed title, description, fields, footer text, and author name.
       * @type {number}
       * @readonly
       */
      get length() {
        return embedLength(this.data);
      }
      /**
       * The hex color of this embed.
       * @type {?string}
       * @readonly
       */
      get hexColor() {
        return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
      }
      /**
       * Returns the API-compatible JSON for this embed.
       * @returns {APIEmbed}
       */
      toJSON() {
        return { ...this.data };
      }
      /**
       * Whether the given embeds are equal.
       * @param {Embed|APIEmbed} other The embed to compare against
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof _Embed) {
          return isEqual(other.data, this.data);
        }
        return isEqual(other, this.data);
      }
    };
    module2.exports = Embed;
  }
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS({
  "node_modules/discord.js/src/structures/MessageMentions.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { FormattingPatterns } = require_v106();
    var { flatten } = require_Util();
    var _MessageMentions = class _MessageMentions {
      constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
        Object.defineProperty(this, "client", { value: message.client });
        Object.defineProperty(this, "guild", { value: message.guild });
        Object.defineProperty(this, "_content", { value: message.content });
        this.everyone = Boolean(everyone);
        if (users) {
          if (users instanceof Collection2) {
            this.users = new Collection2(users);
          } else {
            this.users = new Collection2();
            for (const mention of users) {
              if (mention.member && message.guild) {
                message.guild.members._add(Object.assign(mention.member, { user: mention }));
              }
              const user = message.client.users._add(mention);
              this.users.set(user.id, user);
            }
          }
        } else {
          this.users = new Collection2();
        }
        if (roles instanceof Collection2) {
          this.roles = new Collection2(roles);
        } else if (roles) {
          this.roles = new Collection2();
          const guild = message.guild;
          if (guild) {
            for (const mention of roles) {
              const role = guild.roles.cache.get(mention);
              if (role)
                this.roles.set(role.id, role);
            }
          }
        } else {
          this.roles = new Collection2();
        }
        this._members = null;
        this._channels = null;
        this._parsedUsers = null;
        if (crosspostedChannels) {
          if (crosspostedChannels instanceof Collection2) {
            this.crosspostedChannels = new Collection2(crosspostedChannels);
          } else {
            this.crosspostedChannels = new Collection2();
            for (const crosspostedChannel of crosspostedChannels) {
              this.crosspostedChannels.set(crosspostedChannel.id, {
                channelId: crosspostedChannel.id,
                guildId: crosspostedChannel.guild_id,
                type: crosspostedChannel.type,
                name: crosspostedChannel.name
              });
            }
          }
        } else {
          this.crosspostedChannels = new Collection2();
        }
        this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
      }
      /**
       * Any members that were mentioned (only in {@link Guild}s)
       * <info>Order as received from the API, not as they appear in the message content</info>
       * @type {?Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        if (this._members)
          return this._members;
        if (!this.guild)
          return null;
        this._members = new Collection2();
        this.users.forEach((user) => {
          const member = this.guild.members.resolve(user);
          if (member)
            this._members.set(member.user.id, member);
        });
        return this._members;
      }
      /**
       * Any channels that were mentioned
       * <info>Order as they appear first in the message content</info>
       * @type {Collection<Snowflake, BaseChannel>}
       * @readonly
       */
      get channels() {
        if (this._channels)
          return this._channels;
        this._channels = new Collection2();
        let matches;
        while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
          const channel = this.client.channels.cache.get(matches.groups.id);
          if (channel)
            this._channels.set(channel.id, channel);
        }
        return this._channels;
      }
      /**
       * Any user mentions that were included in the message content
       * <info>Order as they appear first in the message content</info>
       * @type {Collection<Snowflake, User>}
       * @readonly
       */
      get parsedUsers() {
        if (this._parsedUsers)
          return this._parsedUsers;
        this._parsedUsers = new Collection2();
        let matches;
        while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
          const user = this.client.users.cache.get(matches[1]);
          if (user)
            this._parsedUsers.set(user.id, user);
        }
        return this._parsedUsers;
      }
      /**
       * Options used to check for a mention.
       * @typedef {Object} MessageMentionsHasOptions
       * @property {boolean} [ignoreDirect=false] Whether to ignore direct mentions to the item
       * @property {boolean} [ignoreRoles=false] Whether to ignore role mentions to a guild member
       * @property {boolean} [ignoreRepliedUser=false] Whether to ignore replied user mention to an user
       * @property {boolean} [ignoreEveryone=false] Whether to ignore `@everyone`/`@here` mentions
       */
      /**
       * Checks if a user, guild member, thread member, role, or channel is mentioned.
       * Takes into account user mentions, role mentions, channel mentions,
       * replied user mention, and `@everyone`/`@here` mentions.
       * @param {UserResolvable|RoleResolvable|ChannelResolvable} data The User/Role/Channel to check for
       * @param {MessageMentionsHasOptions} [options] The options for the check
       * @returns {boolean}
       */
      has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
        var _a, _b, _c;
        const user = this.client.users.resolve(data);
        if (!ignoreEveryone && user && this.everyone)
          return true;
        const userWasRepliedTo = user && ((_a = this.repliedUser) == null ? void 0 : _a.id) === user.id;
        if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
          return true;
        if (!ignoreDirect) {
          if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
            return true;
          const role = (_b = this.guild) == null ? void 0 : _b.roles.resolve(data);
          if (role && this.roles.has(role.id))
            return true;
          const channel = this.client.channels.resolve(data);
          if (channel && this.channels.has(channel.id))
            return true;
        }
        if (!ignoreRoles) {
          const member = (_c = this.guild) == null ? void 0 : _c.members.resolve(data);
          if (member) {
            for (const mentionedRole of this.roles.values())
              if (member.roles.cache.has(mentionedRole.id))
                return true;
          }
        }
        return false;
      }
      toJSON() {
        return flatten(this, {
          members: true,
          channels: true
        });
      }
    };
    /**
     * A regular expression that matches `@everyone` and `@here`.
     * The `mention` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(_MessageMentions, "EveryonePattern", /@(?<mention>everyone|here)/);
    /**
     * A regular expression that matches user mentions like `<@81440962496172032>`.
     * The `id` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(_MessageMentions, "UsersPattern", FormattingPatterns.UserWithOptionalNickname);
    /**
     * A regular expression that matches role mentions like `<@&297577916114403338>`.
     * The `id` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(_MessageMentions, "RolesPattern", FormattingPatterns.Role);
    /**
     * A regular expression that matches channel mentions like `<#222079895583457280>`.
     * The `id` group property is present on the `exec` result of this expression.
     * @type {RegExp}
     * @memberof MessageMentions
     */
    __publicField(_MessageMentions, "ChannelsPattern", FormattingPatterns.Channel);
    /**
     * A global regular expression variant of {@link MessageMentions.ChannelsPattern}.
     * @type {RegExp}
     * @memberof MessageMentions
     * @private
     */
    __publicField(_MessageMentions, "GlobalChannelsPattern", new RegExp(_MessageMentions.ChannelsPattern.source, "g"));
    /**
     * A global regular expression variant of {@link MessageMentions.UsersPattern}.
     * @type {RegExp}
     * @memberof MessageMentions
     * @private
     */
    __publicField(_MessageMentions, "GlobalUsersPattern", new RegExp(_MessageMentions.UsersPattern.source, "g"));
    var MessageMentions = _MessageMentions;
    module2.exports = MessageMentions;
  }
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS({
  "node_modules/discord.js/src/structures/ReactionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Collector = require_Collector();
    var Events2 = require_Events();
    var ReactionCollector = class _ReactionCollector extends Collector {
      /**
       * @param {Message} message The message upon which to collect reactions
       * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector
       */
      constructor(message, options = {}) {
        super(message.client, options);
        this.message = message;
        this.users = new Collection2();
        this.total = 0;
        this.empty = this.empty.bind(this);
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.message.id))
            this.stop("messageDelete");
        };
        this.client.incrementMaxListeners();
        this.client.on(Events2.MessageReactionAdd, this.handleCollect);
        this.client.on(Events2.MessageReactionRemove, this.handleDispose);
        this.client.on(Events2.MessageReactionRemoveAll, this.empty);
        this.client.on(Events2.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events2.MessageBulkDelete, bulkDeleteListener);
        this.client.on(Events2.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events2.ThreadDelete, this._handleThreadDeletion);
        this.client.on(Events2.GuildDelete, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events2.MessageReactionAdd, this.handleCollect);
          this.client.removeListener(Events2.MessageReactionRemove, this.handleDispose);
          this.client.removeListener(Events2.MessageReactionRemoveAll, this.empty);
          this.client.removeListener(Events2.MessageDelete, this._handleMessageDeletion);
          this.client.removeListener(Events2.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events2.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events2.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events2.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (reaction, user) => {
          if (reaction.count === 1) {
            this.emit("create", reaction, user);
          }
          this.total++;
          this.users.set(user.id, user);
        });
        this.on("remove", (_reaction, user) => {
          this.total--;
          if (!this.collected.some((reaction) => reaction.users.cache.has(user.id)))
            this.users.delete(user.id);
        });
      }
      /**
       * Handles an incoming reaction for possible collection.
       * @param {MessageReaction} reaction The reaction to possibly collect
       * @param {User} user The user that added the reaction
       * @returns {?(Snowflake|string)}
       * @private
       */
      collect(reaction) {
        if (reaction.message.id !== this.message.id)
          return null;
        return _ReactionCollector.key(reaction);
      }
      /**
       * Handles a reaction deletion for possible disposal.
       * @param {MessageReaction} reaction The reaction to possibly dispose of
       * @param {User} user The user that removed the reaction
       * @returns {?(Snowflake|string)}
       */
      dispose(reaction, user) {
        if (reaction.message.id !== this.message.id)
          return null;
        if (this.collected.has(_ReactionCollector.key(reaction)) && this.users.has(user.id)) {
          this.emit("remove", reaction, user);
        }
        return reaction.count ? null : _ReactionCollector.key(reaction);
      }
      /**
       * Empties this reaction collector.
       */
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      /**
       * The reason this collector has ended with, or null if it hasn't ended yet
       * @type {?string}
       * @readonly
       */
      get endReason() {
        if (this.options.max && this.total >= this.options.max)
          return "limit";
        if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
          return "emojiLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
          return "userLimit";
        return super.endReason;
      }
      /**
       * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.
       * @private
       * @param {Message} message The message that was deleted
       * @returns {void}
       */
      _handleMessageDeletion(message) {
        if (message.id === this.message.id) {
          this.stop("messageDelete");
        }
      }
      /**
       * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.
       * @private
       * @param {GuildChannel} channel The channel that was deleted
       * @returns {void}
       */
      _handleChannelDeletion(channel) {
        var _a;
        if (channel.id === this.message.channelId || ((_a = channel.threads) == null ? void 0 : _a.cache.has(this.message.channelId))) {
          this.stop("channelDelete");
        }
      }
      /**
       * Handles checking if the thread has been deleted, and if so, stops the collector with the reason 'threadDelete'.
       * @private
       * @param {ThreadChannel} thread The thread that was deleted
       * @returns {void}
       */
      _handleThreadDeletion(thread) {
        if (thread.id === this.message.channelId) {
          this.stop("threadDelete");
        }
      }
      /**
       * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.
       * @private
       * @param {Guild} guild The guild that was deleted
       * @returns {void}
       */
      _handleGuildDeletion(guild) {
        var _a;
        if (guild.id === ((_a = this.message.guild) == null ? void 0 : _a.id)) {
          this.stop("guildDelete");
        }
      }
      /**
       * Gets the collector key for a reaction.
       * @param {MessageReaction} reaction The message reaction to get the key for
       * @returns {Snowflake|string}
       */
      static key(reaction) {
        return reaction.emoji.id ?? reaction.emoji.name;
      }
    };
    module2.exports = ReactionCollector;
  }
});

// node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS({
  "node_modules/discord.js/src/structures/Sticker.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { StickerFormatExtensionMap } = require_Constants();
    var Sticker2 = class _Sticker extends Base {
      constructor(client, sticker) {
        super(client);
        this._patch(sticker);
      }
      _patch(sticker) {
        this.id = sticker.id;
        if ("description" in sticker) {
          this.description = sticker.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("type" in sticker) {
          this.type = sticker.type;
        } else {
          this.type ?? (this.type = null);
        }
        if ("format_type" in sticker) {
          this.format = sticker.format_type;
        }
        if ("name" in sticker) {
          this.name = sticker.name;
        }
        if ("pack_id" in sticker) {
          this.packId = sticker.pack_id;
        } else {
          this.packId ?? (this.packId = null);
        }
        if ("tags" in sticker) {
          this.tags = sticker.tags;
        } else {
          this.tags ?? (this.tags = null);
        }
        if ("available" in sticker) {
          this.available = sticker.available;
        } else {
          this.available ?? (this.available = null);
        }
        if ("guild_id" in sticker) {
          this.guildId = sticker.guild_id;
        } else {
          this.guildId ?? (this.guildId = null);
        }
        if ("user" in sticker) {
          this.user = this.client.users._add(sticker.user);
        } else {
          this.user ?? (this.user = null);
        }
        if ("sort_value" in sticker) {
          this.sortValue = sticker.sort_value;
        } else {
          this.sortValue ?? (this.sortValue = null);
        }
      }
      /**
       * The timestamp the sticker was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the sticker was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Whether this sticker is partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !this.type;
      }
      /**
       * The guild that owns this sticker
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * A link to the sticker
       * <info>If the sticker's format is {@link StickerFormatType.Lottie}, it returns
       * the URL of the Lottie JSON file.</info>
       * @type {string}
       * @readonly
       */
      get url() {
        return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
      }
      /**
       * Fetches this sticker.
       * @returns {Promise<Sticker>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.sticker(this.id));
        this._patch(data);
        return this;
      }
      /**
       * Fetches the pack that contains this sticker.
       * @returns {Promise<?StickerPack>} The sticker pack or `null` if this sticker does not belong to one.
       */
      async fetchPack() {
        return (this.packId && (await this.client.fetchStickerPacks()).get(this.packId)) ?? null;
      }
      /**
       * Fetches the user who uploaded this sticker, if this is a guild sticker.
       * @returns {Promise<?User>}
       */
      async fetchUser() {
        if (this.partial)
          await this.fetch();
        if (!this.guildId)
          throw new DiscordjsError2(ErrorCodes2.NotGuildSticker);
        return this.guild.stickers.fetchUser(this);
      }
      /**
       * Data for editing a sticker.
       * @typedef {Object} GuildStickerEditOptions
       * @property {string} [name] The name of the sticker
       * @property {?string} [description] The description of the sticker
       * @property {string} [tags] The Discord name of a unicode emoji representing the sticker's expression
       * @property {string} [reason] Reason for editing this sticker
       */
      /**
       * Edits the sticker.
       * @param {GuildStickerEditOptions} options The options to provide
       * @returns {Promise<Sticker>}
       * @example
       * // Update the name of a sticker
       * sticker.edit({ name: 'new name' })
       *   .then(sticker => console.log(`Updated the name of the sticker to ${sticker.name}`))
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.stickers.edit(this, options);
      }
      /**
       * Deletes the sticker.
       * @returns {Promise<Sticker>}
       * @param {string} [reason] Reason for deleting this sticker
       * @example
       * // Delete a message
       * sticker.delete()
       *   .then(sticker => console.log(`Deleted sticker ${sticker.name}`))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.stickers.delete(this, reason);
        return this;
      }
      /**
       * Whether this sticker is the same as another one.
       * @param {Sticker|APISticker} other The sticker to compare it to
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof _Sticker) {
          return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
        } else {
          return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
        }
      }
    };
    exports2.Sticker = Sticker2;
  }
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuildEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var BaseGuildEmoji = class extends Emoji {
      constructor(client, data, guild) {
        super(client, data);
        this.guild = guild;
        this.requiresColons = null;
        this.managed = null;
        this.available = null;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data)
          this.name = data.name;
        if ("require_colons" in data) {
          this.requiresColons = data.require_colons;
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("available" in data) {
          this.available = data.available;
        }
      }
    };
    module2.exports = BaseGuildEmoji;
  }
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildEmojiRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var DataManager = require_DataManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { Role } = require_Role();
    var GuildEmojiRoleManager = class extends DataManager {
      constructor(emoji) {
        super(emoji.client, Role);
        this.emoji = emoji;
        this.guild = emoji.guild;
      }
      /**
       * The cache of roles belonging to this emoji
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get cache() {
        return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
      }
      /**
       * Adds a role (or multiple roles) to the list of roles that can use this emoji.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
       * @returns {Promise<GuildEmoji>}
       */
      add(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2))
          roleOrRoles = [roleOrRoles];
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role));
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles);
      }
      /**
       * Removes a role (or multiple roles) from the list of roles that can use this emoji.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
       * @returns {Promise<GuildEmoji>}
       */
      remove(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2))
          roleOrRoles = [roleOrRoles];
        const resolvedRoleIds = [];
        for (const role of roleOrRoles.values()) {
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId) {
            return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role));
          }
          resolvedRoleIds.push(roleId);
        }
        const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
        return this.set(newRoles);
      }
      /**
       * Sets the role(s) that can use this emoji.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply
       * @returns {Promise<GuildEmoji>}
       * @example
       * // Set the emoji's roles to a single role
       * guildEmoji.roles.set(['391156570408615936'])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all roles from an emoji
       * guildEmoji.roles.set([])
       *    .then(console.log)
       *    .catch(console.error);
       */
      set(roles) {
        return this.emoji.edit({ roles });
      }
      clone() {
        const clone = new this.constructor(this.emoji);
        clone._patch([...this.cache.keys()]);
        return clone;
      }
      /**
       * Patches the roles for this manager's cache
       * @param {Snowflake[]} roles The new roles
       * @private
       */
      _patch(roles) {
        this.emoji._roles = roles;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = GuildEmojiRoleManager;
  }
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS({
  "node_modules/discord.js/src/structures/GuildEmoji.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    var GuildEmoji = class _GuildEmoji extends BaseGuildEmoji {
      constructor(client, data, guild) {
        super(client, data, guild);
        this.author = null;
        Object.defineProperty(this, "_roles", { value: [], writable: true });
        this._patch(data);
      }
      /**
       * The guild this emoji is part of
       * @type {Guild}
       * @name GuildEmoji#guild
       */
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      _patch(data) {
        super._patch(data);
        if (data.user)
          this.author = this.client.users._add(data.user);
        if (data.roles)
          this._roles = data.roles;
      }
      /**
       * Whether the emoji is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageGuildExpressions);
      }
      /**
       * A manager for roles this emoji is active for.
       * @type {GuildEmojiRoleManager}
       * @readonly
       */
      get roles() {
        return new GuildEmojiRoleManager(this);
      }
      /**
       * Fetches the author for this emoji
       * @returns {Promise<User>}
       */
      fetchAuthor() {
        return this.guild.emojis.fetchAuthor(this);
      }
      /**
       * Data for editing an emoji.
       * @typedef {Object} GuildEmojiEditOptions
       * @property {string} [name] The name of the emoji
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to
       * @property {string} [reason] Reason for editing this emoji
       */
      /**
       * Edits the emoji.
       * @param {GuildEmojiEditOptions} options The options to provide
       * @returns {Promise<GuildEmoji>}
       * @example
       * // Edit an emoji
       * emoji.edit({ name: 'newemoji' })
       *   .then(emoji => console.log(`Edited emoji ${emoji}`))
       *   .catch(console.error);
       */
      edit(options) {
        return this.guild.emojis.edit(this.id, options);
      }
      /**
       * Sets the name of the emoji.
       * @param {string} name The new name for the emoji
       * @param {string} [reason] Reason for changing the emoji's name
       * @returns {Promise<GuildEmoji>}
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Deletes the emoji.
       * @param {string} [reason] Reason for deleting the emoji
       * @returns {Promise<GuildEmoji>}
       */
      async delete(reason) {
        await this.guild.emojis.delete(this.id, reason);
        return this;
      }
      /**
       * Whether this emoji is the same as another one.
       * @param {GuildEmoji|APIEmoji} other The emoji to compare it to
       * @returns {boolean}
       */
      equals(other) {
        if (other instanceof _GuildEmoji) {
          return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
        } else {
          return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
        }
      }
    };
    module2.exports = GuildEmoji;
  }
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS({
  "node_modules/discord.js/src/structures/ReactionEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var { flatten } = require_Util();
    var ReactionEmoji = class extends Emoji {
      constructor(reaction, emoji) {
        super(reaction.message.client, emoji);
        this.reaction = reaction;
      }
      toJSON() {
        return flatten(this, { identifier: true });
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = ReactionEmoji;
  }
});

// node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/UserFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { UserFlags } = require_v106();
    var BitField = require_BitField();
    var UserFlagsBitField = class extends BitField {
    };
    /**
     * Numeric user flags.
     * @type {UserFlags}
     * @memberof UserFlagsBitField
     */
    __publicField(UserFlagsBitField, "Flags", UserFlags);
    module2.exports = UserFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS({
  "node_modules/discord.js/src/structures/User.js"(exports2, module2) {
    "use strict";
    var { userMention } = require_dist7();
    var { calculateUserDefaultAvatarIndex } = require_web();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var TextBasedChannel = require_TextBasedChannel();
    var UserFlagsBitField = require_UserFlagsBitField();
    var User = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.bot = null;
        this.system = null;
        this.flags = null;
        this._patch(data);
      }
      _patch(data) {
        if ("username" in data) {
          this.username = data.username;
        } else {
          this.username ?? (this.username = null);
        }
        if ("global_name" in data) {
          this.globalName = data.global_name;
        } else {
          this.globalName ?? (this.globalName = null);
        }
        if ("bot" in data) {
          this.bot = Boolean(data.bot);
        } else if (!this.partial && typeof this.bot !== "boolean") {
          this.bot = false;
        }
        if ("discriminator" in data) {
          this.discriminator = data.discriminator;
        } else {
          this.discriminator ?? (this.discriminator = null);
        }
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else {
          this.avatar ?? (this.avatar = null);
        }
        if ("banner" in data) {
          this.banner = data.banner;
        } else if (this.banner !== null) {
          this.banner ?? (this.banner = void 0);
        }
        if ("accent_color" in data) {
          this.accentColor = data.accent_color;
        } else if (this.accentColor !== null) {
          this.accentColor ?? (this.accentColor = void 0);
        }
        if ("system" in data) {
          this.system = Boolean(data.system);
        } else if (!this.partial && typeof this.system !== "boolean") {
          this.system = false;
        }
        if ("public_flags" in data) {
          this.flags = new UserFlagsBitField(data.public_flags);
        }
        if ("avatar_decoration" in data) {
          this.avatarDecoration = data.avatar_decoration;
        } else {
          this.avatarDecoration ?? (this.avatarDecoration = null);
        }
      }
      /**
       * Whether this User is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.username !== "string";
      }
      /**
       * The timestamp the user was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the user was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * A link to the user's avatar.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
      }
      /**
       * A link to the user's avatar decoration.
       * @param {BaseImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarDecorationURL(options = {}) {
        return this.avatarDecoration && this.client.rest.cdn.avatarDecoration(this.id, this.avatarDecoration, options);
      }
      /**
       * A link to the user's default avatar
       * @type {string}
       * @readonly
       */
      get defaultAvatarURL() {
        const index = this.discriminator === "0" ? calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
        return this.client.rest.cdn.defaultAvatar(index);
      }
      /**
       * A link to the user's avatar if they have one.
       * Otherwise a link to their default avatar will be returned.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {string}
       */
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.defaultAvatarURL;
      }
      /**
       * The hexadecimal version of the user accent color, with a leading hash
       * <info>The user must be force fetched for this property to be present</info>
       * @type {?string}
       * @readonly
       */
      get hexAccentColor() {
        if (typeof this.accentColor !== "number")
          return this.accentColor;
        return `#${this.accentColor.toString(16).padStart(6, "0")}`;
      }
      /**
       * A link to the user's banner. See {@link User#banner} for more info
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      bannerURL(options = {}) {
        return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
      }
      /**
       * The tag of this user
       * <info>This user's username, or their legacy tag (e.g. `hydrabolt#0001`)
       * if they're using the legacy username system</info>
       * @type {?string}
       * @readonly
       */
      get tag() {
        return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
      }
      /**
       * The global name of this user, or their username if they don't have one
       * @type {?string}
       * @readonly
       */
      get displayName() {
        return this.globalName ?? this.username;
      }
      /**
       * The DM between the client's user and this user
       * @type {?DMChannel}
       * @readonly
       */
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      /**
       * Creates a DM channel between the client and the user.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      createDM(force = false) {
        return this.client.users.createDM(this.id, { force });
      }
      /**
       * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.
       * @returns {Promise<DMChannel>}
       */
      deleteDM() {
        return this.client.users.deleteDM(this.id);
      }
      /**
       * Checks if the user is equal to another.
       * It compares id, username, discriminator, avatar, banner, accent color, and bot flags.
       * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.
       * @param {User} user User to compare with
       * @returns {boolean}
       */
      equals(user) {
        var _a, _b;
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && ((_a = this.flags) == null ? void 0 : _a.bitfield) === ((_b = user.flags) == null ? void 0 : _b.bitfield) && this.banner === user.banner && this.accentColor === user.accentColor;
      }
      /**
       * Compares the user with an API user object
       * @param {APIUser} user The API user object to compare
       * @returns {boolean}
       * @private
       */
      _equals(user) {
        var _a;
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && ((_a = this.flags) == null ? void 0 : _a.bitfield) === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true);
      }
      /**
       * Fetches this user's flags.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<UserFlagsBitField>}
       */
      fetchFlags(force = false) {
        return this.client.users.fetchFlags(this.id, { force });
      }
      /**
       * Fetches this user.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<User>}
       */
      fetch(force = true) {
        return this.client.users.fetch(this.id, { force });
      }
      /**
       * When concatenated with a string, this automatically returns the user's mention instead of the User object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${user}!`);
       */
      toString() {
        return userMention(this.id);
      }
      toJSON(...props) {
        const json = super.toJSON(
          {
            createdTimestamp: true,
            defaultAvatarURL: true,
            hexAccentColor: true,
            tag: true
          },
          ...props
        );
        json.avatarURL = this.avatarURL();
        json.displayAvatarURL = this.displayAvatarURL();
        json.bannerURL = this.banner ? this.bannerURL() : this.banner;
        return json;
      }
    };
    TextBasedChannel.applyToClass(User);
    module2.exports = User;
  }
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS({
  "node_modules/discord.js/src/managers/ReactionUserManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var User = require_User();
    var ReactionUserManager = class extends CachedManager {
      constructor(reaction, iterable) {
        super(reaction.client, User, iterable);
        this.reaction = reaction;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, User>}
       * @name ReactionUserManager#cache
       */
      /**
       * Options used to fetch users who gave a reaction.
       * @typedef {Object} FetchReactionUsersOptions
       * @property {number} [limit=100] The maximum amount of users to fetch, defaults to `100`
       * @property {Snowflake} [after] Limit fetching users to those with an id greater than the supplied id
       */
      /**
       * Fetches all the users that gave this reaction. Resolves with a collection of users, mapped by their ids.
       * @param {FetchReactionUsersOptions} [options] Options for fetching the users
       * @returns {Promise<Collection<Snowflake, User>>}
       */
      async fetch({ limit = 100, after } = {}) {
        const message = this.reaction.message;
        const query = makeURLSearchParams2({ limit, after });
        const data = await this.client.rest.get(
          Routes2.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier),
          { query }
        );
        const users = new Collection2();
        for (const rawUser of data) {
          const user = this.client.users._add(rawUser);
          this.cache.set(user.id, user);
          users.set(user.id, user);
        }
        return users;
      }
      /**
       * Removes a user from this reaction.
       * @param {UserResolvable} [user=this.client.user] The user to remove the reaction of
       * @returns {Promise<MessageReaction>}
       */
      async remove(user = this.client.user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsError2(ErrorCodes2.ReactionResolveUser);
        const message = this.reaction.message;
        const route = userId === this.client.user.id ? Routes2.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes2.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
        await this.client.rest.delete(route);
        return this.reaction;
      }
    };
    module2.exports = ReactionUserManager;
  }
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS({
  "node_modules/discord.js/src/structures/MessageReaction.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var ReactionUserManager = require_ReactionUserManager();
    var { flatten } = require_Util();
    var MessageReaction = class {
      constructor(client, data, message) {
        Object.defineProperty(this, "client", { value: client });
        this.message = message;
        this.me = data.me;
        this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
        this._emoji = new ReactionEmoji(this, data.emoji);
        this._patch(data);
      }
      _patch(data) {
        if ("count" in data) {
          this.count ?? (this.count = data.count);
        }
      }
      /**
       * Makes the client user react with this reaction
       * @returns {Promise<MessageReaction>}
       */
      react() {
        return this.message.react(this.emoji);
      }
      /**
       * Removes all users from this reaction.
       * @returns {Promise<MessageReaction>}
       */
      async remove() {
        await this.client.rest.delete(
          Routes2.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier)
        );
        return this;
      }
      /**
       * The emoji of this reaction. Either a {@link GuildEmoji} object for known custom emojis, or a {@link ReactionEmoji}
       * object which has fewer properties. Whatever the prototype of the emoji, it will still have
       * `name`, `id`, `identifier` and `toString()`
       * @type {GuildEmoji|ReactionEmoji}
       * @readonly
       */
      get emoji() {
        if (this._emoji instanceof GuildEmoji)
          return this._emoji;
        if (this._emoji.id) {
          const emojis = this.message.client.emojis.cache;
          if (emojis.has(this._emoji.id)) {
            const emoji = emojis.get(this._emoji.id);
            this._emoji = emoji;
            return emoji;
          }
        }
        return this._emoji;
      }
      /**
       * Whether or not this reaction is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.count === null;
      }
      /**
       * Fetch this reaction.
       * @returns {Promise<MessageReaction>}
       */
      async fetch() {
        const message = await this.message.fetch();
        const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
        this._patch(existing ?? { count: 0 });
        return this;
      }
      toJSON() {
        return flatten(this, { emoji: "emojiId", message: "messageId" });
      }
      valueOf() {
        return this._emoji.id ?? this._emoji.name;
      }
      _add(user) {
        if (this.partial)
          return;
        this.users.cache.set(user.id, user);
        if (!this.me || user.id !== this.message.client.user.id || this.count === 0)
          this.count++;
        this.me || (this.me = user.id === this.message.client.user.id);
      }
      _remove(user) {
        if (this.partial)
          return;
        this.users.cache.delete(user.id);
        if (!this.me || user.id !== this.message.client.user.id)
          this.count--;
        if (user.id === this.message.client.user.id)
          this.me = false;
        if (this.count <= 0 && this.users.cache.size === 0) {
          this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
        }
      }
    };
    module2.exports = MessageReaction;
  }
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS({
  "node_modules/discord.js/src/managers/ReactionManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var MessageReaction = require_MessageReaction();
    var ReactionManager = class extends CachedManager {
      constructor(message, iterable) {
        super(message.client, MessageReaction, iterable);
        this.message = message;
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
      }
      /**
       * The reaction cache of this manager
       * @type {Collection<string|Snowflake, MessageReaction>}
       * @name ReactionManager#cache
       */
      /**
       * Data that can be resolved to a MessageReaction object. This can be:
       * * A MessageReaction
       * * A Snowflake
       * * The Unicode representation of an emoji
       * @typedef {MessageReaction|Snowflake} MessageReactionResolvable
       */
      /**
       * Resolves a {@link MessageReactionResolvable} to a {@link MessageReaction} object.
       * @method resolve
       * @memberof ReactionManager
       * @instance
       * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
       * @returns {?MessageReaction}
       */
      /**
       * Resolves a {@link MessageReactionResolvable} to a {@link MessageReaction} id.
       * @method resolveId
       * @memberof ReactionManager
       * @instance
       * @param {MessageReactionResolvable} reaction The MessageReaction to resolve
       * @returns {?Snowflake}
       */
      /**
       * Removes all reactions from a message.
       * @returns {Promise<Message>}
       */
      async removeAll() {
        await this.client.rest.delete(Routes2.channelMessageAllReactions(this.message.channelId, this.message.id));
        return this.message;
      }
    };
    module2.exports = ReactionManager;
  }
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS({
  "node_modules/discord.js/src/structures/Message.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { messageLink } = require_dist7();
    var { DiscordSnowflake } = require_dist3();
    var {
      InteractionType,
      ChannelType,
      MessageType,
      MessageFlags,
      PermissionFlagsBits
    } = require_v106();
    var Attachment = require_Attachment();
    var Base = require_Base();
    var ClientApplication = require_ClientApplication();
    var Embed = require_Embed();
    var InteractionCollector = require_InteractionCollector();
    var Mentions = require_MessageMentions();
    var MessagePayload = require_MessagePayload();
    var ReactionCollector = require_ReactionCollector();
    var { Sticker: Sticker2 } = require_Sticker();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ReactionManager = require_ReactionManager();
    var { createComponent } = require_Components();
    var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, DeletableMessageTypes } = require_Constants();
    var MessageFlagsBitField = require_MessageFlagsBitField();
    var PermissionsBitField2 = require_PermissionsBitField();
    var { cleanContent, resolvePartialEmoji, transformResolved } = require_Util();
    var Message = class extends Base {
      constructor(client, data) {
        var _a, _b;
        super(client);
        this.channelId = data.channel_id;
        this.guildId = data.guild_id ?? ((_b = (_a = this.channel) == null ? void 0 : _a.guild) == null ? void 0 : _b.id) ?? null;
        this._patch(data);
      }
      _patch(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.id = data.id;
        this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
        if ("type" in data) {
          this.type = data.type;
          this.system = !NonSystemMessageTypes.includes(this.type);
        } else {
          this.system ?? (this.system = null);
          this.type ?? (this.type = null);
        }
        if ("content" in data) {
          this.content = data.content;
        } else {
          this.content ?? (this.content = null);
        }
        if ("author" in data) {
          this.author = this.client.users._add(data.author, !data.webhook_id);
        } else {
          this.author ?? (this.author = null);
        }
        if ("pinned" in data) {
          this.pinned = Boolean(data.pinned);
        } else {
          this.pinned ?? (this.pinned = null);
        }
        if ("tts" in data) {
          this.tts = data.tts;
        } else {
          this.tts ?? (this.tts = null);
        }
        if ("nonce" in data) {
          this.nonce = data.nonce;
        } else {
          this.nonce ?? (this.nonce = null);
        }
        if ("embeds" in data) {
          this.embeds = data.embeds.map((embed) => new Embed(embed));
        } else {
          this.embeds = ((_a = this.embeds) == null ? void 0 : _a.slice()) ?? [];
        }
        if ("components" in data) {
          this.components = data.components.map((component) => createComponent(component));
        } else {
          this.components = ((_b = this.components) == null ? void 0 : _b.slice()) ?? [];
        }
        if ("attachments" in data) {
          this.attachments = new Collection2();
          if (data.attachments) {
            for (const attachment of data.attachments) {
              this.attachments.set(attachment.id, new Attachment(attachment));
            }
          }
        } else {
          this.attachments = new Collection2(this.attachments);
        }
        if ("sticker_items" in data || "stickers" in data) {
          this.stickers = new Collection2(
            (_c = data.sticker_items ?? data.stickers) == null ? void 0 : _c.map((sticker) => [sticker.id, new Sticker2(this.client, sticker)])
          );
        } else {
          this.stickers = new Collection2(this.stickers);
        }
        if ("position" in data) {
          this.position = data.position;
        } else {
          this.position ?? (this.position = null);
        }
        if ("role_subscription_data" in data) {
          this.roleSubscriptionData = {
            roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
            tierName: data.role_subscription_data.tier_name,
            totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
            isRenewal: data.role_subscription_data.is_renewal
          };
        } else {
          this.roleSubscriptionData ?? (this.roleSubscriptionData = null);
        }
        if ("resolved" in data) {
          this.resolved = transformResolved(
            { client: this.client, guild: this.guild, channel: this.channel },
            data.resolved
          );
        } else {
          this.resolved ?? (this.resolved = null);
        }
        if (data.edited_timestamp) {
          this.editedTimestamp = Date.parse(data.edited_timestamp);
        } else {
          this.editedTimestamp ?? (this.editedTimestamp = null);
        }
        if ("reactions" in data) {
          this.reactions = new ReactionManager(this);
          if (((_d = data.reactions) == null ? void 0 : _d.length) > 0) {
            for (const reaction of data.reactions) {
              this.reactions._add(reaction);
            }
          }
        } else {
          this.reactions ?? (this.reactions = new ReactionManager(this));
        }
        if (!this.mentions) {
          this.mentions = new Mentions(
            this,
            data.mentions,
            data.mention_roles,
            data.mention_everyone,
            data.mention_channels,
            (_e = data.referenced_message) == null ? void 0 : _e.author
          );
        } else {
          this.mentions = new Mentions(
            this,
            data.mentions ?? this.mentions.users,
            data.mention_roles ?? this.mentions.roles,
            data.mention_everyone ?? this.mentions.everyone,
            data.mention_channels ?? this.mentions.crosspostedChannels,
            ((_f = data.referenced_message) == null ? void 0 : _f.author) ?? this.mentions.repliedUser
          );
        }
        if ("webhook_id" in data) {
          this.webhookId = data.webhook_id;
        } else {
          this.webhookId ?? (this.webhookId = null);
        }
        if ("application" in data) {
          this.groupActivityApplication = new ClientApplication(this.client, data.application);
        } else {
          this.groupActivityApplication ?? (this.groupActivityApplication = null);
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ?? (this.applicationId = null);
        }
        if ("activity" in data) {
          this.activity = {
            partyId: data.activity.party_id,
            type: data.activity.type
          };
        } else {
          this.activity ?? (this.activity = null);
        }
        if ("thread" in data) {
          this.client.channels._add(data.thread, this.guild);
        }
        if (this.member && data.member) {
          this.member._patch(data.member);
        } else if (data.member && this.guild && this.author) {
          this.guild.members._add(Object.assign(data.member, { user: this.author }));
        }
        if ("flags" in data) {
          this.flags = new MessageFlagsBitField(data.flags).freeze();
        } else {
          this.flags = new MessageFlagsBitField(this.flags).freeze();
        }
        if ("message_reference" in data) {
          this.reference = {
            channelId: data.message_reference.channel_id,
            guildId: data.message_reference.guild_id,
            messageId: data.message_reference.message_id
          };
        } else {
          this.reference ?? (this.reference = null);
        }
        if (data.referenced_message) {
          (_h = this.channel) == null ? void 0 : _h.messages._add({ guild_id: (_g = data.message_reference) == null ? void 0 : _g.guild_id, ...data.referenced_message });
        }
        if (data.interaction) {
          this.interaction = {
            id: data.interaction.id,
            type: data.interaction.type,
            commandName: data.interaction.name,
            user: this.client.users._add(data.interaction.user)
          };
        } else {
          this.interaction ?? (this.interaction = null);
        }
      }
      /**
       * The channel that the message was sent in
       * @type {TextBasedChannels}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * Whether or not this message is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return typeof this.content !== "string" || !this.author;
      }
      /**
       * Represents the author of the message as a guild member.
       * Only available if the message comes from a guild where the author is still a member
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.members.resolve(this.author)) ?? null;
      }
      /**
       * The time the message was sent at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The time the message was last edited at (if applicable)
       * @type {?Date}
       * @readonly
       */
      get editedAt() {
        return this.editedTimestamp && new Date(this.editedTimestamp);
      }
      /**
       * The guild the message was sent in (if in a guild channel)
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        var _a;
        return this.client.guilds.resolve(this.guildId) ?? ((_a = this.channel) == null ? void 0 : _a.guild) ?? null;
      }
      /**
       * Whether this message has a thread associated with it
       * @type {boolean}
       * @readonly
       */
      get hasThread() {
        return this.flags.has(MessageFlags.HasThread);
      }
      /**
       * The thread started by this message
       * <info>This property is not suitable for checking whether a message has a thread,
       * use {@link Message#hasThread} instead.</info>
       * @type {?ThreadChannel}
       * @readonly
       */
      get thread() {
        var _a, _b;
        return ((_b = (_a = this.channel) == null ? void 0 : _a.threads) == null ? void 0 : _b.resolve(this.id)) ?? null;
      }
      /**
       * The URL to jump to this message
       * @type {string}
       * @readonly
       */
      get url() {
        return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
      }
      /**
       * The message contents with all mentions replaced by the equivalent text.
       * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.
       * @type {?string}
       * @readonly
       */
      get cleanContent() {
        return this.content != null ? cleanContent(this.content, this.channel) : null;
      }
      /**
       * Creates a reaction collector.
       * @param {ReactionCollectorOptions} [options={}] Options to send to the collector
       * @returns {ReactionCollector}
       * @example
       * // Create a reaction collector
       * const filter = (reaction, user) => reaction.emoji.name === '' && user.id === 'someId';
       * const collector = message.createReactionCollector({ filter, time: 15_000 });
       * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createReactionCollector(options = {}) {
        return new ReactionCollector(this, options);
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {ReactionCollectorOptions} AwaitReactionsOptions
       * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
       */
      /**
       * Similar to createReactionCollector but in promise form.
       * Resolves with a collection of reactions that pass the specified filter.
       * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector
       * @returns {Promise<Collection<string | Snowflake, MessageReaction>>}
       * @example
       * // Create a reaction collector
       * const filter = (reaction, user) => reaction.emoji.name === '' && user.id === 'someId'
       * message.awaitReactions({ filter, time: 15_000 })
       *   .then(collected => console.log(`Collected ${collected.size} reactions`))
       *   .catch(console.error);
       */
      awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createReactionCollector(options);
          collector.once("end", (reactions, reason) => {
            var _a;
            if ((_a = options.errors) == null ? void 0 : _a.includes(reason))
              reject(reactions);
            else
              resolve(reactions);
          });
        });
      }
      /**
       * @typedef {CollectorOptions} MessageComponentCollectorOptions
       * @property {ComponentType} [componentType] The type of component to listen for
       * @property {number} [max] The maximum total amount of interactions to collect
       * @property {number} [maxComponents] The maximum number of components to collect
       * @property {number} [maxUsers] The maximum number of users to interact
       */
      /**
       * Creates a message component interaction collector.
       * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector
       * @returns {InteractionCollector}
       * @example
       * // Create a message component interaction collector
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * const collector = message.createMessageComponentCollector({ filter, time: 15_000 });
       * collector.on('collect', i => console.log(`Collected ${i.customId}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionType: InteractionType.MessageComponent,
          message: this
        });
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {Object} AwaitMessageComponentOptions
       * @property {CollectorFilter} [filter] The filter applied to this collector
       * @property {number} [time] Time to wait for an interaction before rejecting
       * @property {ComponentType} [componentType] The type of component interaction to collect
       * @property {number} [idle] Time to wait without another message component interaction before ending the collector
       * @property {boolean} [dispose] Whether to remove the message component interaction after collecting
       * @property {InteractionResponse} [interactionResponse] The interaction response to collect interactions from
       */
      /**
       * Collects a single component interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector
       * @returns {Promise<MessageComponentInteraction>}
       * @example
       * // Collect a message component interaction
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * message.awaitMessageComponent({ filter, time: 15_000 })
       *   .then(interaction => console.log(`${interaction.customId} was clicked!`))
       *   .catch(console.error);
       */
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      /**
       * Whether the message is editable by the client user
       * @type {boolean}
       * @readonly
       */
      get editable() {
        var _a, _b;
        const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || ((_a = this.channel) == null ? void 0 : _a.viewable)));
        if ((_b = this.channel) == null ? void 0 : _b.isThread()) {
          if (this.channel.archived)
            return false;
          if (this.channel.locked) {
            const permissions = this.channel.permissionsFor(this.client.user);
            if (!(permissions == null ? void 0 : permissions.has(PermissionFlagsBits.ManageThreads, true)))
              return false;
          }
        }
        return precheck;
      }
      /**
       * Whether the message is deletable by the client user
       * @type {boolean}
       * @readonly
       */
      get deletable() {
        var _a, _b;
        if (!DeletableMessageTypes.includes(this.type))
          return false;
        if (!this.guild) {
          return this.author.id === this.client.user.id;
        }
        if (!((_a = this.channel) == null ? void 0 : _a.viewable)) {
          return false;
        }
        const permissions = (_b = this.channel) == null ? void 0 : _b.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
      }
      /**
       * Whether the message is bulk deletable by the client user
       * @type {boolean}
       * @readonly
       * @example
       * // Filter for bulk deletable messages
       * channel.bulkDelete(messages.filter(message => message.bulkDeletable));
       */
      get bulkDeletable() {
        var _a;
        return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && ((_a = this.channel) == null ? void 0 : _a.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false))) ?? false;
      }
      /**
       * Whether the message is pinnable by the client user
       * @type {boolean}
       * @readonly
       */
      get pinnable() {
        var _a;
        const { channel } = this;
        return Boolean(
          !this.system && (!this.guild || (channel == null ? void 0 : channel.viewable) && ((_a = channel == null ? void 0 : channel.permissionsFor(this.client.user)) == null ? void 0 : _a.has(PermissionFlagsBits.ManageMessages, false)))
        );
      }
      /**
       * Fetches the Message this crosspost/reply/pin-add references, if available to the client
       * @returns {Promise<Message>}
       */
      async fetchReference() {
        if (!this.reference)
          throw new DiscordjsError2(ErrorCodes2.MessageReferenceMissing);
        const { channelId, messageId } = this.reference;
        const channel = this.client.channels.resolve(channelId);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        const message = await channel.messages.fetch(messageId);
        return message;
      }
      /**
       * Whether the message is crosspostable by the client user
       * @type {boolean}
       * @readonly
       */
      get crosspostable() {
        var _a;
        const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField2.DefaultBit : PermissionFlagsBits.ManageMessages);
        const { channel } = this;
        return Boolean(
          (channel == null ? void 0 : channel.type) === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && ((_a = channel.permissionsFor(this.client.user)) == null ? void 0 : _a.has(bitfield, false))
        );
      }
      /**
       * Edits the content of the message.
       * @param {string|MessagePayload|MessageEditOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Update the content of a message
       * message.edit('This is my new content!')
       *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))
       *   .catch(console.error);
       */
      edit(options) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.edit(this, options);
      }
      /**
       * Publishes a message in an announcement channel to all channels following it.
       * @returns {Promise<Message>}
       * @example
       * // Crosspost a message
       * if (message.channel.type === ChannelType.GuildAnnouncement) {
       *   message.crosspost()
       *     .then(() => console.log('Crossposted message'))
       *     .catch(console.error);
       * }
       */
      crosspost() {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.crosspost(this.id);
      }
      /**
       * Pins this message to the channel's pinned messages.
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<Message>}
       * @example
       * // Pin a message
       * message.pin()
       *   .then(console.log)
       *   .catch(console.error)
       */
      async pin(reason) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.pin(this.id, reason);
        return this;
      }
      /**
       * Unpins this message from the channel's pinned messages.
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<Message>}
       * @example
       * // Unpin a message
       * message.unpin()
       *   .then(console.log)
       *   .catch(console.error)
       */
      async unpin(reason) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.unpin(this.id, reason);
        return this;
      }
      /**
       * Adds a reaction to the message.
       * @param {EmojiIdentifierResolvable} emoji The emoji to react with
       * @returns {Promise<MessageReaction>}
       * @example
       * // React to a message with a unicode emoji
       * message.react('')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // React to a message with a custom emoji
       * message.react(message.guild.emojis.cache.get('123456789012345678'))
       *   .then(console.log)
       *   .catch(console.error);
       */
      async react(emoji) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.react(this.id, emoji);
        return this.client.actions.MessageReactionAdd.handle(
          {
            [this.client.actions.injectedUser]: this.client.user,
            [this.client.actions.injectedChannel]: this.channel,
            [this.client.actions.injectedMessage]: this,
            emoji: resolvePartialEmoji(emoji)
          },
          true
        ).reaction;
      }
      /**
       * Deletes the message.
       * @returns {Promise<Message>}
       * @example
       * // Delete a message
       * message.delete()
       *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))
       *   .catch(console.error);
       */
      async delete() {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.delete(this.id);
        return this;
      }
      /**
       * Options provided when sending a message as an inline reply.
       * @typedef {BaseMessageCreateOptions} MessageReplyOptions
       * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced
       * message does not exist (creates a standard message in this case when false)
       */
      /**
       * Send an inline reply to this message.
       * @param {string|MessagePayload|MessageReplyOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Reply to a message
       * message.reply('This is a reply!')
       *   .then(() => console.log(`Replied to message "${message.content}"`))
       *   .catch(console.error);
       */
      reply(options) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        let data;
        if (options instanceof MessagePayload) {
          data = options;
        } else {
          data = MessagePayload.create(this, options, {
            reply: {
              messageReference: this,
              failIfNotExists: (options == null ? void 0 : options.failIfNotExists) ?? this.client.options.failIfNotExists
            }
          });
        }
        return this.channel.send(data);
      }
      /**
       * Options for starting a thread on a message.
       * @typedef {Object} StartThreadOptions
       * @property {string} name The name of the new thread
       * @property {ThreadAutoArchiveDuration} [autoArchiveDuration=this.channel.defaultAutoArchiveDuration] The amount of
       * time after which the thread should automatically archive in case of no recent activity
       * @property {string} [reason] Reason for creating the thread
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds
       */
      /**
       * Create a new public thread from this message
       * @see GuildTextThreadManager#create
       * @param {StartThreadOptions} [options] Options for starting a thread on this message
       * @returns {Promise<ThreadChannel>}
       */
      startThread(options = {}) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.MessageThreadParent));
        }
        if (this.hasThread)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.MessageExistingThread));
        return this.channel.threads.create({ ...options, startMessage: this });
      }
      /**
       * Fetch this message.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<Message>}
       */
      fetch(force = true) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.fetch({ message: this.id, force });
      }
      /**
       * Fetches the webhook used to create this message.
       * @returns {Promise<?Webhook>}
       */
      fetchWebhook() {
        if (!this.webhookId)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.WebhookMessage));
        if (this.webhookId === this.applicationId)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.WebhookApplication));
        return this.client.fetchWebhook(this.webhookId);
      }
      /**
       * Suppresses or unsuppresses embeds on a message.
       * @param {boolean} [suppress=true] If the embeds should be suppressed or not
       * @returns {Promise<Message>}
       */
      suppressEmbeds(suppress = true) {
        const flags = new MessageFlagsBitField(this.flags.bitfield);
        if (suppress) {
          flags.add(MessageFlags.SuppressEmbeds);
        } else {
          flags.remove(MessageFlags.SuppressEmbeds);
        }
        return this.edit({ flags });
      }
      /**
       * Removes the attachments from this message.
       * @returns {Promise<Message>}
       */
      removeAttachments() {
        return this.edit({ attachments: [] });
      }
      /**
       * Resolves a component by a custom id.
       * @param {string} customId The custom id to resolve against
       * @returns {?MessageActionRowComponent}
       */
      resolveComponent(customId) {
        return this.components.flatMap((row) => row.components).find((component) => component.customId === customId) ?? null;
      }
      /**
       * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages
       * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This
       * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.
       * @param {Message} message The message to compare it to
       * @param {APIMessage} rawData Raw data passed through the WebSocket about this message
       * @returns {boolean}
       */
      equals(message, rawData) {
        if (!message)
          return false;
        const embedUpdate = !message.author && !message.attachments;
        if (embedUpdate)
          return this.id === message.id && this.embeds.length === message.embeds.length;
        let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
        if (equal && rawData) {
          equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
        }
        return equal;
      }
      /**
       * Whether this message is from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return Boolean(this.guildId);
      }
      /**
       * When concatenated with a string, this automatically concatenates the message's content instead of the object.
       * @returns {string}
       * @example
       * // Logs: Message: This is a message!
       * console.log(`Message: ${message}`);
       */
      toString() {
        return this.content;
      }
      toJSON() {
        return super.toJSON({
          channel: "channelId",
          author: "authorId",
          groupActivityApplication: "groupActivityApplicationId",
          guild: "guildId",
          cleanContent: true,
          member: false,
          reactions: false
        });
      }
    };
    exports2.Message = Message;
  }
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS({
  "node_modules/discord.js/src/structures/Webhook.js"(exports2, module2) {
    "use strict";
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { lazy } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2, WebhookType } = require_v106();
    var MessagePayload = require_MessagePayload();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var DataResolver2 = require_DataResolver();
    var getMessage = lazy(() => require_Message().Message);
    var Webhook2 = class _Webhook {
      constructor(client, data) {
        Object.defineProperty(this, "client", { value: client });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        var _a, _b, _c, _d;
        if ("name" in data) {
          this.name = data.name;
        }
        Object.defineProperty(this, "token", {
          value: data.token ?? null,
          writable: true,
          configurable: true
        });
        if ("avatar" in data) {
          this.avatar = data.avatar;
        }
        this.id = data.id;
        if ("type" in data) {
          this.type = data.type;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("user" in data) {
          this.owner = ((_a = this.client.users) == null ? void 0 : _a._add(data.user)) ?? data.user;
        } else {
          this.owner ?? (this.owner = null);
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ?? (this.applicationId = null);
        }
        if ("source_guild" in data) {
          this.sourceGuild = ((_b = this.client.guilds) == null ? void 0 : _b.resolve(data.source_guild.id)) ?? data.source_guild;
        } else {
          this.sourceGuild ?? (this.sourceGuild = null);
        }
        if ("source_channel" in data) {
          this.sourceChannel = ((_d = this.client.channels) == null ? void 0 : _d.resolve((_c = data.source_channel) == null ? void 0 : _c.id)) ?? data.source_channel;
        } else {
          this.sourceChannel ?? (this.sourceChannel = null);
        }
      }
      /**
       * Options that can be passed into send.
       * @typedef {BaseMessageOptions} WebhookMessageCreateOptions
       * @property {boolean} [tts=false] Whether the message should be spoken aloud
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be set.</info>
       * @property {string} [username=this.name] Username override for the message
       * @property {string} [avatarURL] Avatar URL override for the message
       * @property {Snowflake} [threadId] The id of the thread in the channel to send to.
       * <info>For interaction webhooks, this property is ignored</info>
       * @property {string} [threadName] Name of the thread to create (only available if webhook is in a forum channel)
       */
      /**
       * Options that can be passed into editMessage.
       * @typedef {BaseMessageOptions} WebhookMessageEditOptions
       * @property {Attachment[]} [attachments] Attachments to send with the message
       * @property {Snowflake} [threadId] The id of the thread this message belongs to
       * <info>For interaction webhooks, this property is ignored</info>
       */
      /**
       * The channel the webhook belongs to
       * @type {?(TextChannel|VoiceChannel|StageChannel|NewsChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|WebhookMessageCreateOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Send a basic message
       * webhook.send('hello!')
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a basic message in a thread
       * webhook.send({ content: 'hello!', threadId: '836856309672348295' })
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a remote file
       * webhook.send({
       *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send a local file
       * webhook.send({
       *   files: [{
       *     attachment: 'entire/path/to/file.jpg',
       *     name: 'file.jpg'
       *   }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send an embed with a local image inside
       * webhook.send({
       *   content: 'This is an embed',
       *   embeds: [{
       *     thumbnail: {
       *          url: 'attachment://file.jpg'
       *       }
       *    }],
       *    files: [{
       *       attachment: 'entire/path/to/file.jpg',
       *       name: 'file.jpg'
       *    }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async send(options) {
        var _a;
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveBody();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveBody();
        }
        const query = makeURLSearchParams2({
          wait: true,
          thread_id: messagePayload.options.threadId
        });
        const { body, files } = await messagePayload.resolveFiles();
        const d = await this.client.rest.post(Routes2.webhook(this.id, this.token), {
          body,
          files,
          query,
          auth: false
        });
        if (!this.client.channels)
          return d;
        return ((_a = this.client.channels.cache.get(d.channel_id)) == null ? void 0 : _a.messages._add(d, false)) ?? new (getMessage())(this.client, d);
      }
      /**
       * Sends a raw slack message with this webhook.
       * @param {Object} body The raw body to send
       * @returns {Promise<boolean>}
       * @example
       * // Send a slack message
       * webhook.sendSlackMessage({
       *   'username': 'Wumpus',
       *   'attachments': [{
       *     'pretext': 'this looks pretty cool',
       *     'color': '#F0F',
       *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',
       *     'footer': 'Powered by sneks',
       *     'ts': Date.now() / 1_000
       *   }]
       * }).catch(console.error);
       * @see {@link https://api.slack.com/messaging/webhooks}
       */
      async sendSlackMessage(body) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        const data = await this.client.rest.post(Routes2.webhookPlatform(this.id, this.token, "slack"), {
          query: makeURLSearchParams2({ wait: true }),
          auth: false,
          body
        });
        return data.toString() === "ok";
      }
      /**
       * Options used to edit a {@link Webhook}.
       * @typedef {Object} WebhookEditOptions
       * @property {string} [name=this.name] The new name for the webhook
       * @property {?(BufferResolvable)} [avatar] The new avatar for the webhook
       * @property {GuildTextChannelResolvable|VoiceChannel|StageChannel|ForumChannel|MediaChannel} [channel]
       * The new channel for the webhook
       * @property {string} [reason] Reason for editing the webhook
       */
      /**
       * Edits this webhook.
       * @param {WebhookEditOptions} options Options for editing the webhook
       * @returns {Promise<Webhook>}
       */
      async edit({ name = this.name, avatar, channel, reason }) {
        if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        channel && (channel = channel.id ?? channel);
        const data = await this.client.rest.patch(Routes2.webhook(this.id, channel ? void 0 : this.token), {
          body: { name, avatar, channel_id: channel },
          reason,
          auth: !this.token || Boolean(channel)
        });
        this.name = data.name;
        this.avatar = data.avatar;
        this.channelId = data.channel_id;
        return this;
      }
      /**
       * Options that can be passed into fetchMessage.
       * @typedef {options} WebhookFetchMessageOptions
       * @property {boolean} [cache=true] Whether to cache the message.
       * @property {Snowflake} [threadId] The id of the thread this message belongs to.
       * <info>For interaction webhooks, this property is ignored</info>
       */
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake|'@original'} message The id of the message to fetch
       * @param {WebhookFetchMessageOptions} [options={}] The options to provide to fetch the message.
       * @returns {Promise<Message>} Returns the message sent by this webhook
       */
      async fetchMessage(message, { threadId } = {}) {
        var _a;
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        const data = await this.client.rest.get(Routes2.webhookMessage(this.id, this.token, message), {
          query: threadId ? makeURLSearchParams2({ thread_id: threadId }) : void 0,
          auth: false
        });
        if (!this.client.channels)
          return data;
        return ((_a = this.client.channels.cache.get(data.channel_id)) == null ? void 0 : _a.messages._add(data, false)) ?? new (getMessage())(this.client, data);
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to edit
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The options to provide
       * @returns {Promise<Message>} Returns the message edited by this webhook
       */
      async editMessage(message, options) {
        var _a;
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body, files } = await messagePayload.resolveBody().resolveFiles();
        const d = await this.client.rest.patch(
          Routes2.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id),
          {
            body,
            files,
            query: messagePayload.options.threadId ? makeURLSearchParams2({ thread_id: messagePayload.options.threadId }) : void 0,
            auth: false
          }
        );
        const channelManager = this.client.channels;
        if (!channelManager)
          return d;
        const messageManager = (_a = channelManager.cache.get(d.channel_id)) == null ? void 0 : _a.messages;
        if (!messageManager)
          return new (getMessage())(this.client, d);
        const existing = messageManager.cache.get(d.id);
        if (!existing)
          return messageManager._add(d);
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      /**
       * Deletes the webhook.
       * @param {string} [reason] Reason for deleting this webhook
       * @returns {Promise<void>}
       */
      delete(reason) {
        return this.client.deleteWebhook(this.id, { token: this.token, reason });
      }
      /**
       * Delete a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to delete
       * @param {Snowflake} [threadId] The id of the thread this message belongs to
       * @returns {Promise<void>}
       */
      async deleteMessage(message, threadId) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        await this.client.rest.delete(
          Routes2.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id),
          {
            query: threadId ? makeURLSearchParams2({ thread_id: threadId }) : void 0,
            auth: false
          }
        );
      }
      /**
       * The timestamp the webhook was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the webhook was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL of this webhook
       * @type {string}
       * @readonly
       */
      get url() {
        return this.client.options.rest.api + Routes2.webhook(this.id, this.token);
      }
      /**
       * A link to the webhook's avatar.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
      }
      /**
       * Whether this webhook is created by a user.
       * @returns {boolean}
       */
      isUserCreated() {
        return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
      }
      /**
       * Whether this webhook is created by an application.
       * @returns {boolean}
       */
      isApplicationCreated() {
        return this.type === WebhookType.Application;
      }
      /**
       * Whether or not this webhook is a channel follower webhook.
       * @returns {boolean}
       */
      isChannelFollower() {
        return this.type === WebhookType.ChannelFollower;
      }
      /**
       * Whether or not this webhook is an incoming webhook.
       * @returns {boolean}
       */
      isIncoming() {
        return this.type === WebhookType.Incoming;
      }
      static applyToClass(structure, ignore = []) {
        for (const prop of [
          "send",
          "sendSlackMessage",
          "fetchMessage",
          "edit",
          "editMessage",
          "delete",
          "deleteMessage",
          "createdTimestamp",
          "createdAt",
          "url"
        ]) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(_Webhook.prototype, prop));
        }
      }
    };
    module2.exports = Webhook2;
  }
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS({
  "node_modules/discord.js/src/client/WebhookClient.js"(exports2, module2) {
    "use strict";
    var BaseClient2 = require_BaseClient();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Webhook2 = require_Webhook();
    var { parseWebhookURL } = require_Util();
    var WebhookClient = class extends BaseClient2 {
      /**
       * Represents the credentials used for a webhook in the form of its id and token.
       * @typedef {Object} WebhookClientDataIdWithToken
       * @property {Snowflake} id The webhook's id
       * @property {string} token The webhook's token
       */
      /**
       * Represents the credentials used for a webhook in the form of a URL.
       * @typedef {Object} WebhookClientDataURL
       * @property {string} url The full URL for the webhook
       */
      /**
       * Represents the credentials used for a webhook.
       * @typedef {WebhookClientDataIdWithToken|WebhookClientDataURL} WebhookClientData
       */
      /**
       * Options for a webhook client.
       * @typedef {Object} WebhookClientOptions
       * @property {MessageMentionOptions} [allowedMentions] Default value for {@link BaseMessageOptions#allowedMentions}
       * @property {RESTOptions} [rest] Options for the REST manager
       */
      /**
       * @param {WebhookClientData} data The data of the webhook
       * @param {WebhookClientOptions} [options] Options for the webhook client
       */
      constructor(data, options) {
        super(options);
        Object.defineProperty(this, "client", { value: this });
        let { id, token } = data;
        if ("url" in data) {
          const parsed = parseWebhookURL(data.url);
          if (!parsed) {
            throw new DiscordjsError2(ErrorCodes2.WebhookURLInvalid);
          }
          ({ id, token } = parsed);
        }
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      /**
       * The options the webhook client was instantiated with.
       * @type {WebhookClientOptions}
       * @name WebhookClient#options
       */
      // These are here only for documentation purposes - they are implemented by Webhook
      /* eslint-disable no-empty-function, valid-jsdoc */
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|WebhookMessageCreateOptions} options The content for the reply
       * @returns {Promise<APIMessage>}
       */
      send() {
      }
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake} message The id of the message to fetch
       * @param {WebhookFetchMessageOptions} [options={}] The options to provide to fetch the message.
       * @returns {Promise<APIMessage>} Returns the message sent by this webhook
       */
      fetchMessage() {
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable} message The message to edit
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The options to provide
       * @returns {Promise<APIMessage>} Returns the message edited by this webhook
       */
      editMessage() {
      }
      sendSlackMessage() {
      }
      edit() {
      }
      delete() {
      }
      deleteMessage() {
      }
      get createdTimestamp() {
      }
      get createdAt() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(WebhookClient);
    module2.exports = WebhookClient;
  }
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS({
  "node_modules/discord.js/src/structures/VoiceState.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var VoiceState = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.id = data.user_id;
        this._patch(data);
      }
      _patch(data) {
        if ("deaf" in data) {
          this.serverDeaf = data.deaf;
        } else {
          this.serverDeaf ?? (this.serverDeaf = null);
        }
        if ("mute" in data) {
          this.serverMute = data.mute;
        } else {
          this.serverMute ?? (this.serverMute = null);
        }
        if ("self_deaf" in data) {
          this.selfDeaf = data.self_deaf;
        } else {
          this.selfDeaf ?? (this.selfDeaf = null);
        }
        if ("self_mute" in data) {
          this.selfMute = data.self_mute;
        } else {
          this.selfMute ?? (this.selfMute = null);
        }
        if ("self_video" in data) {
          this.selfVideo = data.self_video;
        } else {
          this.selfVideo ?? (this.selfVideo = null);
        }
        if ("session_id" in data) {
          this.sessionId = data.session_id;
        } else {
          this.sessionId ?? (this.sessionId = null);
        }
        if ("self_video" in data) {
          this.streaming = data.self_stream ?? false;
        } else {
          this.streaming ?? (this.streaming = null);
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ?? (this.channelId = null);
        }
        if ("suppress" in data) {
          this.suppress = data.suppress;
        } else {
          this.suppress ?? (this.suppress = null);
        }
        if ("request_to_speak_timestamp" in data) {
          this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
        } else {
          this.requestToSpeakTimestamp ?? (this.requestToSpeakTimestamp = null);
        }
        return this;
      }
      /**
       * The member that this voice state belongs to
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.cache.get(this.id) ?? null;
      }
      /**
       * The channel that the member is connected to
       * @type {?(VoiceChannel|StageChannel)}
       * @readonly
       */
      get channel() {
        return this.guild.channels.cache.get(this.channelId) ?? null;
      }
      /**
       * Whether this member is either self-deafened or server-deafened
       * @type {?boolean}
       * @readonly
       */
      get deaf() {
        return this.serverDeaf || this.selfDeaf;
      }
      /**
       * Whether this member is either self-muted or server-muted
       * @type {?boolean}
       * @readonly
       */
      get mute() {
        return this.serverMute || this.selfMute;
      }
      /**
       * Mutes/unmutes the member of this voice state.
       * @param {boolean} [mute=true] Whether or not the member should be muted
       * @param {string} [reason] Reason for muting or unmuting
       * @returns {Promise<GuildMember>}
       */
      setMute(mute = true, reason) {
        return this.guild.members.edit(this.id, { mute, reason });
      }
      /**
       * Deafens/undeafens the member of this voice state.
       * @param {boolean} [deaf=true] Whether or not the member should be deafened
       * @param {string} [reason] Reason for deafening or undeafening
       * @returns {Promise<GuildMember>}
       */
      setDeaf(deaf = true, reason) {
        return this.guild.members.edit(this.id, { deaf, reason });
      }
      /**
       * Disconnects the member from the channel.
       * @param {string} [reason] Reason for disconnecting the member from the channel
       * @returns {Promise<GuildMember>}
       */
      disconnect(reason) {
        return this.setChannel(null, reason);
      }
      /**
       * Moves the member to a different channel, or disconnects them from the one they're in.
       * @param {?GuildVoiceChannelResolvable} channel Channel to move the member to, or `null` if you want to
       * disconnect them from voice.
       * @param {string} [reason] Reason for moving member to another channel or disconnecting
       * @returns {Promise<GuildMember>}
       */
      setChannel(channel, reason) {
        return this.guild.members.edit(this.id, { channel, reason });
      }
      /**
       * Data to edit the logged in user's own voice state with, when in a stage channel
       * @typedef {Object} VoiceStateEditOptions
       * @property {boolean} [requestToSpeak] Whether or not the client is requesting to become a speaker.
       * <info>Only available to the logged in user's own voice state.</info>
       * @property {boolean} [suppressed] Whether or not the user should be suppressed.
       */
      /**
       * Edits this voice state. Currently only available when in a stage channel
       * @param {VoiceStateEditOptions} options The options to provide
       * @returns {Promise<VoiceState>}
       */
      async edit(options) {
        var _a;
        if (((_a = this.channel) == null ? void 0 : _a.type) !== ChannelType.GuildStageVoice)
          throw new DiscordjsError2(ErrorCodes2.VoiceNotStageChannel);
        const target = this.client.user.id === this.id ? "@me" : this.id;
        if (target !== "@me" && options.requestToSpeak !== void 0) {
          throw new DiscordjsError2(ErrorCodes2.VoiceStateNotOwn);
        }
        if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
          throw new DiscordjsTypeError2(ErrorCodes2.VoiceStateInvalidType, "requestToSpeak");
        }
        if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
          throw new DiscordjsTypeError2(ErrorCodes2.VoiceStateInvalidType, "suppressed");
        }
        await this.client.rest.patch(Routes2.guildVoiceState(this.guild.id, target), {
          body: {
            channel_id: this.channelId,
            request_to_speak_timestamp: options.requestToSpeak ? (/* @__PURE__ */ new Date()).toISOString() : options.requestToSpeak === false ? null : void 0,
            suppress: options.suppressed
          }
        });
        return this;
      }
      /**
       * Toggles the request to speak in the channel.
       * Only applicable for stage channels and for the client's own voice state.
       * @param {boolean} [requestToSpeak=true] Whether or not the client is requesting to become a speaker.
       * @example
       * // Making the client request to speak in a stage channel (raise its hand)
       * guild.members.me.voice.setRequestToSpeak(true);
       * @example
       * // Making the client cancel a request to speak
       * guild.members.me.voice.setRequestToSpeak(false);
       * @returns {Promise<VoiceState>}
       */
      setRequestToSpeak(requestToSpeak = true) {
        return this.edit({ requestToSpeak });
      }
      /**
       * Suppress/unsuppress the user. Only applicable for stage channels.
       * @param {boolean} [suppressed=true] Whether or not the user should be suppressed.
       * @example
       * // Making the client a speaker
       * guild.members.me.voice.setSuppressed(false);
       * @example
       * // Making the client an audience member
       * guild.members.me.voice.setSuppressed(true);
       * @example
       * // Inviting another user to speak
       * voiceState.setSuppressed(false);
       * @example
       * // Moving another user to the audience, or cancelling their invite to speak
       * voiceState.setSuppressed(true);
       * @returns {Promise<VoiceState>}
       */
      setSuppressed(suppressed = true) {
        return this.edit({ suppressed });
      }
      toJSON() {
        return super.toJSON({
          id: true,
          serverDeaf: true,
          serverMute: true,
          selfDeaf: true,
          selfMute: true,
          sessionId: true,
          channelId: "channel"
        });
      }
    };
    module2.exports = VoiceState;
  }
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildMemberRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2 } = require_v106();
    var DataManager = require_DataManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { Role } = require_Role();
    var GuildMemberRoleManager = class extends DataManager {
      constructor(member) {
        super(member.client, Role);
        this.member = member;
        this.guild = member.guild;
      }
      /**
       * The roles of this member
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get cache() {
        const everyone = this.guild.roles.everyone;
        return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
      }
      /**
       * The role of the member used to hoist them in a separate category in the users list
       * @type {?Role}
       * @readonly
       */
      get hoist() {
        const hoistedRoles = this.cache.filter((role) => role.hoist);
        if (!hoistedRoles.size)
          return null;
        return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member used to set their role icon
       * @type {?Role}
       * @readonly
       */
      get icon() {
        const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
        if (!iconRoles.size)
          return null;
        return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member used to set their color
       * @type {?Role}
       * @readonly
       */
      get color() {
        const coloredRoles = this.cache.filter((role) => role.color);
        if (!coloredRoles.size)
          return null;
        return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      /**
       * The role of the member with the highest position
       * @type {Role}
       * @readonly
       */
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
      /**
       * The premium subscriber role of the guild, if present on the member
       * @type {?Role}
       * @readonly
       */
      get premiumSubscriberRole() {
        return this.cache.find((role) => {
          var _a;
          return (_a = role.tags) == null ? void 0 : _a.premiumSubscriberRole;
        }) ?? null;
      }
      /**
       * The managed role this member created when joining the guild, if any
       * <info>Only ever available on bots</info>
       * @type {?Role}
       * @readonly
       */
      get botRole() {
        if (!this.member.user.bot)
          return null;
        return this.cache.find((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.botId) === this.member.user.id;
        }) ?? null;
      }
      /**
       * Adds a role (or multiple roles) to the member.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add
       * @param {string} [reason] Reason for adding the role(s)
       * @returns {Promise<GuildMember>}
       */
      async add(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "roles",
              "Role, Snowflake or Array or Collection of Roles or Snowflakes"
            );
          }
          await this.client.rest.put(Routes2.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
          const clone = this.member._clone();
          clone._roles = [...this.cache.keys(), roleOrRoles];
          return clone;
        }
      }
      /**
       * Removes a role (or multiple roles) from the member.
       * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove
       * @param {string} [reason] Reason for removing the role(s)
       * @returns {Promise<GuildMember>}
       */
      async remove(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "roles",
              "Role, Snowflake or Array or Collection of Roles or Snowflakes"
            );
          }
          await this.client.rest.delete(Routes2.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
          const clone = this.member._clone();
          const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
          clone._roles = [...newRoles.keys()];
          return clone;
        }
      }
      /**
       * Sets the roles applied to the member.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role ids to apply
       * @param {string} [reason] Reason for applying the roles
       * @returns {Promise<GuildMember>}
       * @example
       * // Set the member's roles to a single role
       * guildMember.roles.set(['391156570408615936'])
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove all the roles from a member
       * guildMember.roles.set([])
       *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))
       *   .catch(console.error);
       */
      set(roles, reason) {
        return this.member.edit({ roles, reason });
      }
      clone() {
        const clone = new this.constructor(this.member);
        clone.member._roles = [...this.cache.keys()];
        return clone;
      }
    };
    module2.exports = GuildMemberRoleManager;
  }
});

// node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/GuildMemberFlagsBitField.js"(exports2) {
    "use strict";
    var { GuildMemberFlags } = require_v106();
    var BitField = require_BitField();
    var GuildMemberFlagsBitField = class extends BitField {
    };
    /**
     * Numeric guild guild member flags.
     * @type {GuildMemberFlags}
     * @memberof GuildMemberFlagsBitField
     */
    __publicField(GuildMemberFlagsBitField, "Flags", GuildMemberFlags);
    exports2.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS({
  "node_modules/discord.js/src/structures/GuildMember.js"(exports2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var Base = require_Base();
    var VoiceState = require_VoiceState();
    var TextBasedChannel = require_TextBasedChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildMemberRoleManager = require_GuildMemberRoleManager();
    var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
    var PermissionsBitField2 = require_PermissionsBitField();
    var GuildMember = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.joinedTimestamp = null;
        this.premiumSinceTimestamp = null;
        this.nickname = null;
        this.pending = null;
        this.communicationDisabledUntilTimestamp = null;
        Object.defineProperty(this, "_roles", { value: [], writable: true });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("nick" in data)
          this.nickname = data.nick;
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else if (typeof this.avatar !== "string") {
          this.avatar = null;
        }
        if ("joined_at" in data)
          this.joinedTimestamp = Date.parse(data.joined_at);
        if ("premium_since" in data) {
          this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
        }
        if ("roles" in data)
          this._roles = data.roles;
        if ("pending" in data) {
          this.pending = data.pending;
        } else if (!this.partial) {
          this.pending ?? (this.pending = false);
        }
        if ("communication_disabled_until" in data) {
          this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
        }
        if ("flags" in data) {
          this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new GuildMemberFlagsBitField().freeze());
        }
      }
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      /**
       * Whether this GuildMember is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.joinedTimestamp === null;
      }
      /**
       * A manager for the roles belonging to this member
       * @type {GuildMemberRoleManager}
       * @readonly
       */
      get roles() {
        return new GuildMemberRoleManager(this);
      }
      /**
       * The voice state of this member
       * @type {VoiceState}
       * @readonly
       */
      get voice() {
        return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
      }
      /**
       * A link to the member's guild avatar.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
      }
      /**
       * A link to the member's guild avatar if they have one.
       * Otherwise, a link to their {@link User#displayAvatarURL} will be returned.
       * @param {ImageURLOptions} [options={}] Options for the Image URL
       * @returns {string}
       */
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
      }
      /**
       * The time this member joined the guild
       * @type {?Date}
       * @readonly
       */
      get joinedAt() {
        return this.joinedTimestamp && new Date(this.joinedTimestamp);
      }
      /**
       * The time this member's timeout will be removed
       * @type {?Date}
       * @readonly
       */
      get communicationDisabledUntil() {
        return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
      }
      /**
       * The last time this member started boosting the guild
       * @type {?Date}
       * @readonly
       */
      get premiumSince() {
        return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
      }
      /**
       * The presence of this guild member
       * @type {?Presence}
       * @readonly
       */
      get presence() {
        return this.guild.presences.resolve(this.id);
      }
      /**
       * The displayed role color of this member in base 10
       * @type {number}
       * @readonly
       */
      get displayColor() {
        var _a;
        return ((_a = this.roles.color) == null ? void 0 : _a.color) ?? 0;
      }
      /**
       * The displayed role color of this member in hexadecimal
       * @type {string}
       * @readonly
       */
      get displayHexColor() {
        var _a;
        return ((_a = this.roles.color) == null ? void 0 : _a.hexColor) ?? "#000000";
      }
      /**
       * The member's id
       * @type {Snowflake}
       * @readonly
       */
      get id() {
        return this.user.id;
      }
      /**
       * The DM between the client's user and this member
       * @type {?DMChannel}
       * @readonly
       */
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      /**
       * The nickname of this member, or their user display name if they don't have one
       * @type {?string}
       * @readonly
       */
      get displayName() {
        return this.nickname ?? this.user.displayName;
      }
      /**
       * The overall set of permissions for this member, taking only roles and owner status into account
       * @type {Readonly<PermissionsBitField>}
       * @readonly
       */
      get permissions() {
        if (this.user.id === this.guild.ownerId)
          return new PermissionsBitField2(PermissionsBitField2.All).freeze();
        return new PermissionsBitField2(this.roles.cache.map((role) => role.permissions)).freeze();
      }
      /**
       * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.
       * This is a prerequisite for many moderative actions.
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        if (this.user.id === this.guild.ownerId)
          return false;
        if (this.user.id === this.client.user.id)
          return false;
        if (this.client.user.id === this.guild.ownerId)
          return true;
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
      }
      /**
       * Whether this member is kickable by the client user
       * @type {boolean}
       * @readonly
       */
      get kickable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
      }
      /**
       * Whether this member is bannable by the client user
       * @type {boolean}
       * @readonly
       */
      get bannable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
      }
      /**
       * Whether this member is moderatable by the client user
       * @type {boolean}
       * @readonly
       */
      get moderatable() {
        var _a;
        return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (((_a = this.guild.members.me) == null ? void 0 : _a.permissions.has(PermissionFlagsBits.ModerateMembers)) ?? false);
      }
      /**
       * Whether this member is currently timed out
       * @returns {boolean}
       */
      isCommunicationDisabled() {
        return this.communicationDisabledUntilTimestamp > Date.now();
      }
      /**
       * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,
       * taking into account roles and permission overwrites.
       * @param {GuildChannelResolvable} channel The guild channel to use as context
       * @returns {Readonly<PermissionsBitField>}
       */
      permissionsIn(channel) {
        channel = this.guild.channels.resolve(channel);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        return channel.permissionsFor(this);
      }
      /**
       * Edits this member.
       * @param {GuildMemberEditOptions} options The options to provide
       * @returns {Promise<GuildMember>}
       */
      edit(options) {
        return this.guild.members.edit(this, options);
      }
      /**
       * Sets the flags for this member.
       * @param {GuildMemberFlagsResolvable} flags The flags to set
       * @param {string} [reason] Reason for setting the flags
       * @returns {Promise<GuildMember>}
       */
      setFlags(flags, reason) {
        return this.edit({ flags, reason });
      }
      /**
       * Sets the nickname for this member.
       * @param {?string} nick The nickname for the guild member, or `null` if you want to reset their nickname
       * @param {string} [reason] Reason for setting the nickname
       * @returns {Promise<GuildMember>}
       * @example
       * // Set a nickname for a guild member
       * guildMember.setNickname('cool nickname', 'Needed a new nickname')
       *   .then(member => console.log(`Set nickname of ${member.user.username}`))
       *   .catch(console.error);
       * @example
       * // Remove a nickname for a guild member
       * guildMember.setNickname(null, 'No nicknames allowed!')
       *   .then(member => console.log(`Removed nickname for ${member.user.username}`))
       *   .catch(console.error);
       */
      setNickname(nick, reason) {
        return this.edit({ nick, reason });
      }
      /**
       * Creates a DM channel between the client and this member.
       * @param {boolean} [force=false] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      createDM(force = false) {
        return this.user.createDM(force);
      }
      /**
       * Deletes any DMs with this member.
       * @returns {Promise<DMChannel>}
       */
      deleteDM() {
        return this.user.deleteDM();
      }
      /**
       * Kicks this member from the guild.
       * @param {string} [reason] Reason for kicking user
       * @returns {Promise<GuildMember>}
       */
      kick(reason) {
        return this.guild.members.kick(this, reason);
      }
      /**
       * Bans this guild member.
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember>}
       * @example
       * // Ban a guild member, deleting a week's worth of messages
       * guildMember.ban({ deleteMessageSeconds: 60 * 60 * 24 * 7, reason: 'They deserved it' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      ban(options) {
        return this.guild.bans.create(this, options);
      }
      /**
       * Times this guild member out.
       * @param {?DateResolvable} communicationDisabledUntil The date or timestamp
       * for the member's communication to be disabled until. Provide `null` to remove the timeout.
       * @param {string} [reason] The reason for this timeout.
       * @returns {Promise<GuildMember>}
       * @example
       * // Time a guild member out for 5 minutes
       * guildMember.disableCommunicationUntil(Date.now() + (5 * 60 * 1000), 'They deserved it')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Remove the timeout of a guild member
       * guildMember.disableCommunicationUntil(null)
       *   .then(member => console.log(`Removed timeout for ${member.displayName}`))
       *   .catch(console.error);
       */
      disableCommunicationUntil(communicationDisabledUntil, reason) {
        return this.edit({ communicationDisabledUntil, reason });
      }
      /**
       * Times this guild member out.
       * @param {?number} timeout The duration in milliseconds
       * for the member's communication to be disabled. Provide `null` to remove the timeout.
       * @param {string} [reason] The reason for this timeout.
       * @returns {Promise<GuildMember>}
       * @example
       * // Time a guild member out for 5 minutes
       * guildMember.timeout(5 * 60 * 1000, 'They deserved it')
       *   .then(console.log)
       *   .catch(console.error);
       */
      timeout(timeout, reason) {
        return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
      }
      /**
       * Fetches this GuildMember.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildMember>}
       */
      fetch(force = true) {
        return this.guild.members.fetch({ user: this.id, cache: true, force });
      }
      /**
       * Whether this guild member equals another guild member. It compares all properties, so for most
       * comparison it is advisable to just compare `member.id === member2.id` as it is significantly faster
       * and is often what most users need.
       * @param {GuildMember} member The member to compare with
       * @returns {boolean}
       */
      equals(member) {
        return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
      }
      /**
       * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${member}!`);
       */
      toString() {
        return this.user.toString();
      }
      toJSON() {
        const json = super.toJSON({
          guild: "guildId",
          user: "userId",
          displayName: true,
          roles: true
        });
        json.avatarURL = this.avatarURL();
        json.displayAvatarURL = this.displayAvatarURL();
        return json;
      }
    };
    TextBasedChannel.applyToClass(GuildMember);
    exports2.GuildMember = GuildMember;
  }
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS({
  "node_modules/discord.js/src/managers/MessageManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { Message } = require_Message();
    var MessagePayload = require_MessagePayload();
    var { MakeCacheOverrideSymbol } = require_Symbols();
    var { resolvePartialEmoji } = require_Util();
    var _a;
    var _MessageManager = class _MessageManager extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, Message, iterable);
        this.channel = channel;
      }
      /**
       * The cache of Messages
       * @type {Collection<Snowflake, Message>}
       * @name MessageManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache);
      }
      /**
       * Data that can be resolved to a Message object. This can be:
       * * A Message
       * * A Snowflake
       * @typedef {Message|Snowflake} MessageResolvable
       */
      /**
       * Options used to fetch a message.
       * @typedef {BaseFetchOptions} FetchMessageOptions
       * @property {MessageResolvable} message The message to fetch
       */
      /**
       * Options used to fetch multiple messages.
       * <info>The `before`, `after`, and `around` parameters are mutually exclusive.</info>
       * @typedef {Object} FetchMessagesOptions
       * @property {number} [limit] The maximum number of messages to return
       * @property {Snowflake} [before] Consider only messages before this id
       * @property {Snowflake} [after] Consider only messages after this id
       * @property {Snowflake} [around] Consider only messages around this id
       * @property {boolean} [cache] Whether to cache the fetched messages
       */
      /**
       * Fetches message(s) from a channel.
       * <info>The returned Collection does not contain reaction users of the messages if they were not cached.
       * Those need to be fetched separately in such a case.</info>
       * @param {MessageResolvable|FetchMessageOptions|FetchMessagesOptions} [options] Options for fetching message(s)
       * @returns {Promise<Message|Collection<Snowflake, Message>>}
       * @example
       * // Fetch a message
       * channel.messages.fetch('99539446449315840')
       *   .then(message => console.log(message.content))
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 10 messages without caching
       * channel.messages.fetch({ limit: 10, cache: false })
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 10 messages without caching around a message id
       * channel.messages.fetch({ limit: 10, cache: false, around: '99539446449315840' })
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       * @example
       * // Fetch messages and filter by a user id
       * channel.messages.fetch()
       *   .then(messages => console.log(`${messages.filter(message =>
       *          message.author.id === '84484653687267328').size} messages`))
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { message, cache, force } = options;
        const resolvedMessage = this.resolveId(message ?? options);
        if (resolvedMessage)
          return this._fetchSingle({ message: resolvedMessage, cache, force });
        return this._fetchMany(options);
      }
      async _fetchSingle({ message, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(message);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.channelMessage(this.channel.id, message));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes2.channelMessages(this.channel.id), {
          query: makeURLSearchParams2(options)
        });
        return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection2());
      }
      /**
       * Fetches the pinned messages of this channel and returns a collection of them.
       * <info>The returned Collection does not contain any reaction data of the messages.
       * Those need to be fetched separately.</info>
       * @param {boolean} [cache=true] Whether to cache the message(s)
       * @returns {Promise<Collection<Snowflake, Message>>}
       * @example
       * // Get pinned messages
       * channel.messages.fetchPinned()
       *   .then(messages => console.log(`Received ${messages.size} messages`))
       *   .catch(console.error);
       */
      async fetchPinned(cache = true) {
        const data = await this.client.rest.get(Routes2.channelPins(this.channel.id));
        const messages = new Collection2();
        for (const message of data)
          messages.set(message.id, this._add(message, cache));
        return messages;
      }
      /**
       * Resolves a {@link MessageResolvable} to a {@link Message} object.
       * @method resolve
       * @memberof MessageManager
       * @instance
       * @param {MessageResolvable} message The message resolvable to resolve
       * @returns {?Message}
       */
      /**
       * Resolves a {@link MessageResolvable} to a {@link Message} id.
       * @method resolveId
       * @memberof MessageManager
       * @instance
       * @param {MessageResolvable} message The message resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Data used to reference an attachment.
       * @typedef {Object} MessageEditAttachmentData
       * @property {Snowflake} id The id of the attachment
       */
      /**
       * Options that can be passed to edit a message.
       * @typedef {BaseMessageOptions} MessageEditOptions
       * @property {Array<Attachment|MessageEditAttachmentData>} [attachments] An array of attachments to keep.
       * All attachments will be kept if omitted
       * @property {MessageFlags} [flags] Which flags to set for the message
       * <info>Only the {@link MessageFlags.SuppressEmbeds} flag can be modified.</info>
       */
      /**
       * Edits a message, even if it's not cached.
       * @param {MessageResolvable} message The message to edit
       * @param {string|MessageEditOptions|MessagePayload} options The options to edit the message
       * @returns {Promise<Message>}
       */
      async edit(message, options) {
        const messageId = this.resolveId(message);
        if (!messageId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
        const d = await this.client.rest.patch(Routes2.channelMessage(this.channel.id, messageId), { body, files });
        const existing = this.cache.get(messageId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      /**
       * Publishes a message in an announcement channel to all channels following it, even if it's not cached.
       * @param {MessageResolvable} message The message to publish
       * @returns {Promise<Message>}
       */
      async crosspost(message) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        const data = await this.client.rest.post(Routes2.channelMessageCrosspost(this.channel.id, message));
        return this.cache.get(data.id) ?? this._add(data);
      }
      /**
       * Pins a message to the channel's pinned messages, even if it's not cached.
       * @param {MessageResolvable} message The message to pin
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<void>}
       */
      async pin(message, reason) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.put(Routes2.channelPin(this.channel.id, message), { reason });
      }
      /**
       * Unpins a message from the channel's pinned messages, even if it's not cached.
       * @param {MessageResolvable} message The message to unpin
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<void>}
       */
      async unpin(message, reason) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.delete(Routes2.channelPin(this.channel.id, message), { reason });
      }
      /**
       * Adds a reaction to a message, even if it's not cached.
       * @param {MessageResolvable} message The message to react to
       * @param {EmojiIdentifierResolvable} emoji The emoji to react with
       * @returns {Promise<void>}
       */
      async react(message, emoji) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        emoji = resolvePartialEmoji(emoji);
        if (!emoji)
          throw new DiscordjsTypeError2(ErrorCodes2.EmojiType, "emoji", "EmojiIdentifierResolvable");
        const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
        await this.client.rest.put(Routes2.channelMessageOwnReaction(this.channel.id, message, emojiId));
      }
      /**
       * Deletes a message, even if it's not cached.
       * @param {MessageResolvable} message The message to delete
       * @returns {Promise<void>}
       */
      async delete(message) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.delete(Routes2.channelMessage(this.channel.id, message));
      }
    };
    _a = MakeCacheOverrideSymbol;
    __publicField(_MessageManager, _a, _MessageManager);
    var MessageManager = _MessageManager;
    module2.exports = MessageManager;
  }
});

// node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS({
  "node_modules/discord.js/src/structures/InteractionWebhook.js"(exports2, module2) {
    "use strict";
    var Webhook2 = require_Webhook();
    var InteractionWebhook = class {
      /**
       * @param {Client} client The instantiating client
       * @param {Snowflake} id The application's id
       * @param {string} token The interaction's token
       */
      constructor(client, id, token) {
        Object.defineProperty(this, "client", { value: client });
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      // These are here only for documentation purposes - they are implemented by Webhook
      /* eslint-disable no-empty-function */
      /**
       * Sends a message with this webhook.
       * @param {string|MessagePayload|InteractionReplyOptions} options The content for the reply
       * @returns {Promise<Message>}
       */
      send() {
      }
      /**
       * Gets a message that was sent by this webhook.
       * @param {Snowflake|'@original'} message The id of the message to fetch
       * @returns {Promise<Message>} Returns the message sent by this webhook
       */
      fetchMessage() {
      }
      /**
       * Edits a message that was sent by this webhook.
       * @param {MessageResolvable|'@original'} message The message to edit
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The options to provide
       * @returns {Promise<Message>} Returns the message edited by this webhook
       */
      editMessage() {
      }
      deleteMessage() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
    module2.exports = InteractionWebhook;
  }
});

// node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS({
  "node_modules/discord.js/src/structures/MessagePayload.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_node_buffer();
    var { lazy, isJSONEncodable } = require_dist();
    var { MessageFlags } = require_v106();
    var ActionRowBuilder = require_ActionRowBuilder();
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var DataResolver2 = require_DataResolver();
    var MessageFlagsBitField = require_MessageFlagsBitField();
    var { basename, verifyString } = require_Util();
    var getBaseInteraction = lazy(() => require_BaseInteraction());
    var MessagePayload = class {
      /**
       * @param {MessageTarget} target The target for this message to be sent to
       * @param {MessagePayloadOption} options The payload of this message
       */
      constructor(target, options) {
        this.target = target;
        this.options = options;
        this.body = null;
        this.files = null;
      }
      /**
       * Whether or not the target is a {@link Webhook} or a {@link WebhookClient}
       * @type {boolean}
       * @readonly
       */
      get isWebhook() {
        const Webhook2 = require_Webhook();
        const WebhookClient = require_WebhookClient();
        return this.target instanceof Webhook2 || this.target instanceof WebhookClient;
      }
      /**
       * Whether or not the target is a {@link User}
       * @type {boolean}
       * @readonly
       */
      get isUser() {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        return this.target instanceof User || this.target instanceof GuildMember;
      }
      /**
       * Whether or not the target is a {@link Message}
       * @type {boolean}
       * @readonly
       */
      get isMessage() {
        const { Message } = require_Message();
        return this.target instanceof Message;
      }
      /**
       * Whether or not the target is a {@link MessageManager}
       * @type {boolean}
       * @readonly
       */
      get isMessageManager() {
        const MessageManager = require_MessageManager();
        return this.target instanceof MessageManager;
      }
      /**
       * Whether or not the target is an {@link BaseInteraction} or an {@link InteractionWebhook}
       * @type {boolean}
       * @readonly
       */
      get isInteraction() {
        const BaseInteraction = getBaseInteraction();
        const InteractionWebhook = require_InteractionWebhook();
        return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
      }
      /**
       * Makes the content of this message.
       * @returns {?string}
       */
      makeContent() {
        let content;
        if (this.options.content === null) {
          content = "";
        } else if (this.options.content !== void 0) {
          content = verifyString(this.options.content, DiscordjsRangeError2, ErrorCodes2.MessageContentType, true);
        }
        return content;
      }
      /**
       * Resolves the body.
       * @returns {MessagePayload}
       */
      resolveBody() {
        var _a, _b, _c, _d, _e;
        if (this.body)
          return this;
        const isInteraction = this.isInteraction;
        const isWebhook = this.isWebhook;
        const content = this.makeContent();
        const tts = Boolean(this.options.tts);
        let nonce;
        if (this.options.nonce !== void 0) {
          nonce = this.options.nonce;
          if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
            throw new DiscordjsRangeError2(ErrorCodes2.MessageNonceType);
          }
        }
        const components = (_a = this.options.components) == null ? void 0 : _a.map(
          (component) => (isJSONEncodable(component) ? component : new ActionRowBuilder(component)).toJSON()
        );
        let username;
        let avatarURL;
        let threadName;
        if (isWebhook) {
          username = this.options.username ?? this.target.name;
          if (this.options.avatarURL)
            avatarURL = this.options.avatarURL;
          if (this.options.threadName)
            threadName = this.options.threadName;
        }
        let flags;
        if (this.options.flags !== void 0 || this.isMessage && this.options.reply === void 0 || this.isMessageManager) {
          flags = // eslint-disable-next-line eqeqeq
          this.options.flags != null ? new MessageFlagsBitField(this.options.flags).bitfield : (_b = this.target.flags) == null ? void 0 : _b.bitfield;
        }
        if (isInteraction && this.options.ephemeral) {
          flags |= MessageFlags.Ephemeral;
        }
        let allowedMentions = this.options.allowedMentions === void 0 ? this.target.client.options.allowedMentions : this.options.allowedMentions;
        if ((allowedMentions == null ? void 0 : allowedMentions.repliedUser) !== void 0) {
          allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
          delete allowedMentions.repliedUser;
        }
        let message_reference;
        if (typeof this.options.reply === "object") {
          const reference = this.options.reply.messageReference;
          const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
          if (message_id) {
            message_reference = {
              message_id,
              fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
            };
          }
        }
        const attachments = (_c = this.options.files) == null ? void 0 : _c.map((file, index) => ({
          id: index.toString(),
          description: file.description
        }));
        if (Array.isArray(this.options.attachments)) {
          this.options.attachments.push(...attachments ?? []);
        } else {
          this.options.attachments = attachments;
        }
        this.body = {
          content,
          tts,
          nonce,
          embeds: (_d = this.options.embeds) == null ? void 0 : _d.map(
            (embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)
          ),
          components,
          username,
          avatar_url: avatarURL,
          allowed_mentions: content === void 0 && message_reference === void 0 ? void 0 : allowedMentions,
          flags,
          message_reference,
          attachments: this.options.attachments,
          sticker_ids: (_e = this.options.stickers) == null ? void 0 : _e.map((sticker) => sticker.id ?? sticker),
          thread_name: threadName
        };
        return this;
      }
      /**
       * Resolves files.
       * @returns {Promise<MessagePayload>}
       */
      async resolveFiles() {
        var _a;
        if (this.files)
          return this;
        this.files = await Promise.all(((_a = this.options.files) == null ? void 0 : _a.map((file) => this.constructor.resolveFile(file))) ?? []);
        return this;
      }
      /**
       * Resolves a single file into an object sendable to the API.
       * @param {AttachmentPayload|BufferResolvable|Stream} fileLike Something that could be resolved to a file
       * @returns {Promise<RawFile>}
       */
      static async resolveFile(fileLike) {
        let attachment;
        let name;
        const findName = (thing) => {
          if (typeof thing === "string") {
            return basename(thing);
          }
          if (thing.path) {
            return basename(thing.path);
          }
          return "file.jpg";
        };
        const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
        if (ownAttachment) {
          attachment = fileLike;
          name = findName(attachment);
        } else {
          attachment = fileLike.attachment;
          name = fileLike.name ?? findName(attachment);
        }
        const { data, contentType } = await DataResolver2.resolveFile(attachment);
        return { data, name, contentType };
      }
      /**
       * Creates a {@link MessagePayload} from user-level arguments.
       * @param {MessageTarget} target Target to send to
       * @param {string|MessagePayloadOption} options Options or content to use
       * @param {MessagePayloadOption} [extra={}] Extra options to add onto specified options
       * @returns {MessagePayload}
       */
      static create(target, options, extra = {}) {
        return new this(
          target,
          typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra }
        );
      }
    };
    module2.exports = MessagePayload;
  }
});

// node_modules/discord.js/src/managers/GuildMessageManager.js
var require_GuildMessageManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildMessageManager.js"(exports2, module2) {
    "use strict";
    var MessageManager = require_MessageManager();
    var GuildMessageManager = class extends MessageManager {
      /**
       * The channel that the messages belong to
       * @name GuildMessageManager#channel
       * @type {GuildTextBasedChannel}
       */
    };
    module2.exports = GuildMessageManager;
  }
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType, Routes: Routes2 } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { MaxBulkDeletableMessageAge } = require_Constants();
    var InteractionCollector = require_InteractionCollector();
    var MessageCollector = require_MessageCollector();
    var MessagePayload = require_MessagePayload();
    var TextBasedChannel = class _TextBasedChannel {
      constructor() {
        this.messages = new GuildMessageManager(this);
        this.lastMessageId = null;
        this.lastPinTimestamp = null;
      }
      /**
       * The Message object of the last message in the channel, if one was sent
       * @type {?Message}
       * @readonly
       */
      get lastMessage() {
        return this.messages.resolve(this.lastMessageId);
      }
      /**
       * The date when the last pinned message was pinned, if there was one
       * @type {?Date}
       * @readonly
       */
      get lastPinAt() {
        return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
      }
      /**
       * The base message options for messages.
       * @typedef {Object} BaseMessageOptions
       * @property {?string} [content=''] The content for the message. This can only be `null` when editing a message.
       * @property {Array<(EmbedBuilder|Embed|APIEmbed)>} [embeds] The embeds for the message
       * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content
       * (see [here](https://discord.com/developers/docs/resources/channel#allowed-mentions-object) for more details)
       * @property {Array<(AttachmentBuilder|Attachment|AttachmentPayload|BufferResolvable)>} [files]
       * The files to send with the message.
       * @property {Array<(ActionRowBuilder|ActionRow|APIActionRowComponent)>} [components]
       * Action rows containing interactive components for the message (buttons, select menus)
       */
      /**
       * Options for sending a message with a reply.
       * @typedef {Object} ReplyOptions
       * @property {MessageResolvable} messageReference The message to reply to (must be in the same channel and not system)
       * @property {boolean} [failIfNotExists=this.client.options.failIfNotExists] Whether to error if the referenced
       * message does not exist (creates a standard message in this case when false)
       */
      /**
       * The options for sending a message.
       * @typedef {BaseMessageOptions} BaseMessageCreateOptions
       * @property {boolean} [tts=false] Whether the message should be spoken aloud
       * @property {string} [nonce=''] The nonce for the message
       * @property {StickerResolvable[]} [stickers=[]] The stickers to send in the message
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.SuppressNotifications` can be set.</info>
       */
      /**
       * The options for sending a message.
       * @typedef {BaseMessageCreateOptions} MessageCreateOptions
       * @property {ReplyOptions} [reply] The options for replying to a message
       */
      /**
       * Options provided to control parsing of mentions by Discord
       * @typedef {Object} MessageMentionOptions
       * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed
       * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions
       * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions
       * @property {boolean} [repliedUser=true] Whether the author of the Message being replied to should be pinged
       */
      /**
       * Types of mentions to enable in MessageMentionOptions.
       * - `roles`
       * - `users`
       * - `everyone`
       * @typedef {string} MessageMentionTypes
       */
      /**
       * Sends a message to this channel.
       * @param {string|MessagePayload|MessageCreateOptions} options The options to provide
       * @returns {Promise<Message>}
       * @example
       * // Send a basic message
       * channel.send('hello!')
       *   .then(message => console.log(`Sent message: ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Send a remote file
       * channel.send({
       *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
       * })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Send a local file
       * channel.send({
       *   files: [{
       *     attachment: 'entire/path/to/file.jpg',
       *     name: 'file.jpg',
       *     description: 'A description of the file'
       *   }]
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async send(options) {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        if (this instanceof User || this instanceof GuildMember) {
          const dm = await this.createDM();
          return dm.send(options);
        }
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveBody();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveBody();
        }
        const { body, files } = await messagePayload.resolveFiles();
        const d = await this.client.rest.post(Routes2.channelMessages(this.id), { body, files });
        return this.messages.cache.get(d.id) ?? this.messages._add(d);
      }
      /**
       * Sends a typing indicator in the channel.
       * @returns {Promise<void>} Resolves upon the typing status being sent
       * @example
       * // Start typing in a channel
       * channel.sendTyping();
       */
      async sendTyping() {
        await this.client.rest.post(Routes2.channelTyping(this.id));
      }
      /**
       * Creates a Message Collector.
       * @param {MessageCollectorOptions} [options={}] The options to pass to the collector
       * @returns {MessageCollector}
       * @example
       * // Create a message collector
       * const filter = message => message.content.includes('discord');
       * const collector = channel.createMessageCollector({ filter, time: 15_000 });
       * collector.on('collect', message => console.log(`Collected ${message.content}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageCollector(options = {}) {
        return new MessageCollector(this, options);
      }
      /**
       * An object containing the same properties as CollectorOptions, but a few more:
       * @typedef {MessageCollectorOptions} AwaitMessagesOptions
       * @property {string[]} [errors] Stop/end reasons that cause the promise to reject
       */
      /**
       * Similar to createMessageCollector but in promise form.
       * Resolves with a collection of messages that pass the specified filter.
       * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector
       * @returns {Promise<Collection<Snowflake, Message>>}
       * @example
       * // Await !vote messages
       * const filter = m => m.content.startsWith('!vote');
       * // Errors: ['time'] treats ending because of the time limit as an error
       * channel.awaitMessages({ filter, max: 4, time: 60_000, errors: ['time'] })
       *   .then(collected => console.log(collected.size))
       *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));
       */
      awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createMessageCollector(options);
          collector.once("end", (collection, reason) => {
            var _a;
            if ((_a = options.errors) == null ? void 0 : _a.includes(reason)) {
              reject(collection);
            } else {
              resolve(collection);
            }
          });
        });
      }
      /**
       * Creates a component interaction collector.
       * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector
       * @returns {InteractionCollector}
       * @example
       * // Create a button interaction collector
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * const collector = channel.createMessageComponentCollector({ filter, time: 15_000 });
       * collector.on('collect', interaction => console.log(`Collected ${interaction.customId}`));
       * collector.on('end', collected => console.log(`Collected ${collected.size} items`));
       */
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionType: InteractionType.MessageComponent,
          channel: this
        });
      }
      /**
       * Collects a single component interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector
       * @returns {Promise<MessageComponentInteraction>}
       * @example
       * // Collect a message component interaction
       * const filter = (interaction) => interaction.customId === 'button' && interaction.user.id === 'someId';
       * channel.awaitMessageComponent({ filter, time: 15_000 })
       *   .then(interaction => console.log(`${interaction.customId} was clicked!`))
       *   .catch(console.error);
       */
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      /**
       * Bulk deletes given messages that are newer than two weeks.
       * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages
       * Messages or number of messages to delete
       * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically
       * @returns {Promise<Collection<Snowflake, Message|undefined>>} Returns the deleted messages
       * @example
       * // Bulk delete messages
       * channel.bulkDelete(5)
       *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))
       *   .catch(console.error);
       */
      async bulkDelete(messages, filterOld = false) {
        if (Array.isArray(messages) || messages instanceof Collection2) {
          let messageIds = messages instanceof Collection2 ? [...messages.keys()] : messages.map((message) => message.id ?? message);
          if (filterOld) {
            messageIds = messageIds.filter(
              (id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge
            );
          }
          if (messageIds.length === 0)
            return new Collection2();
          if (messageIds.length === 1) {
            const message = this.client.actions.MessageDelete.getMessage(
              {
                message_id: messageIds[0]
              },
              this
            );
            await this.client.rest.delete(Routes2.channelMessage(this.id, messageIds[0]));
            return message ? new Collection2([[message.id, message]]) : new Collection2();
          }
          await this.client.rest.post(Routes2.channelBulkDelete(this.id), { body: { messages: messageIds } });
          return messageIds.reduce(
            (col, id) => col.set(
              id,
              this.client.actions.MessageDeleteBulk.getMessage(
                {
                  message_id: id
                },
                this
              )
            ),
            new Collection2()
          );
        }
        if (!isNaN(messages)) {
          const msgs = await this.messages.fetch({ limit: messages });
          return this.bulkDelete(msgs, filterOld);
        }
        throw new DiscordjsTypeError2(ErrorCodes2.MessageBulkDeleteType);
      }
      /**
       * Fetches all webhooks for the channel.
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * channel.fetchWebhooks()
       *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
       *   .catch(console.error);
       */
      fetchWebhooks() {
        return this.guild.channels.fetchWebhooks(this.id);
      }
      /**
       * Options used to create a {@link Webhook}.
       * @typedef {Object} ChannelWebhookCreateOptions
       * @property {string} name The name of the webhook
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] Avatar for the webhook
       * @property {string} [reason] Reason for creating the webhook
       */
      /**
       * Creates a webhook for the channel.
       * @param {ChannelWebhookCreateOptions} [options] Options for creating the webhook
       * @returns {Promise<Webhook>} Returns the created Webhook
       * @example
       * // Create a webhook for the current channel
       * channel.createWebhook({
       *   name: 'Snek',
       *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
       *   reason: 'Needed a cool new Webhook'
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      createWebhook(options) {
        return this.guild.channels.createWebhook({ channel: this.id, ...options });
      }
      /**
       * Sets the rate limit per user (slowmode) for this channel.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the channel's rate limit
       * @returns {Promise<this>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
      /**
       * Sets whether this channel is flagged as NSFW.
       * @param {boolean} [nsfw=true] Whether the channel should be considered NSFW
       * @param {string} [reason] Reason for changing the channel's NSFW flag
       * @returns {Promise<this>}
       */
      setNSFW(nsfw = true, reason) {
        return this.edit({ nsfw, reason });
      }
      static applyToClass(structure, full = false, ignore = []) {
        const props = ["send"];
        if (full) {
          props.push(
            "lastMessage",
            "lastPinAt",
            "bulkDelete",
            "sendTyping",
            "createMessageCollector",
            "awaitMessages",
            "createMessageComponentCollector",
            "awaitMessageComponent",
            "fetchWebhooks",
            "createWebhook",
            "setRateLimitPerUser",
            "setNSFW"
          );
        }
        for (const prop of props) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(_TextBasedChannel.prototype, prop)
          );
        }
      }
    };
    module2.exports = TextBasedChannel;
    var GuildMessageManager = require_GuildMessageManager();
  }
});

// node_modules/discord.js/src/managers/DMMessageManager.js
var require_DMMessageManager = __commonJS({
  "node_modules/discord.js/src/managers/DMMessageManager.js"(exports2, module2) {
    "use strict";
    var MessageManager = require_MessageManager();
    var DMMessageManager = class extends MessageManager {
      /**
       * The channel that the messages belong to
       * @name DMMessageManager#channel
       * @type {DMChannel}
       */
    };
    module2.exports = DMMessageManager;
  }
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS({
  "node_modules/discord.js/src/structures/DMChannel.js"(exports2, module2) {
    "use strict";
    var { userMention } = require_dist7();
    var { ChannelType } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var DMMessageManager = require_DMMessageManager();
    var Partials = require_Partials();
    var DMChannel = class extends BaseChannel {
      constructor(client, data) {
        super(client, data);
        this.type = ChannelType.DM;
        this.messages = new DMMessageManager(this);
      }
      _patch(data) {
        super._patch(data);
        if (data.recipients) {
          const recipient = data.recipients[0];
          this.recipientId = recipient.id;
          if ("username" in recipient || this.client.options.partials.includes(Partials.User)) {
            this.client.users._add(recipient);
          }
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
      }
      /**
       * Whether this DMChannel is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.lastMessageId === void 0;
      }
      /**
       * The recipient on the other end of the DM
       * @type {?User}
       * @readonly
       */
      get recipient() {
        return this.client.users.resolve(this.recipientId);
      }
      /**
       * Fetch this DMChannel.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<DMChannel>}
       */
      fetch(force = true) {
        return this.client.users.createDM(this.recipientId, { force });
      }
      /**
       * When concatenated with a string, this automatically returns the recipient's mention instead of the
       * DMChannel object.
       * @returns {string}
       * @example
       * // Logs: Hello from <@123456789012345678>!
       * console.log(`Hello from ${channel}!`);
       */
      toString() {
        return userMention(this.recipientId);
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      // Doesn't work on DM channels; bulkDelete() {}
      // Doesn't work on DM channels; fetchWebhooks() {}
      // Doesn't work on DM channels; createWebhook() {}
      // Doesn't work on DM channels; setRateLimitPerUser() {}
      // Doesn't work on DM channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(DMChannel, true, [
      "bulkDelete",
      "fetchWebhooks",
      "createWebhook",
      "setRateLimitPerUser",
      "setNSFW"
    ]);
    module2.exports = DMChannel;
  }
});

// node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildForumThreadManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var ThreadManager = require_ThreadManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var MessagePayload = require_MessagePayload();
    var GuildForumThreadManager = class extends ThreadManager {
      /**
       * The channel this Manager belongs to
       * @name GuildForumThreadManager#channel
       * @type {ForumChannel}
       */
      /**
       * @typedef {BaseMessageOptions} GuildForumThreadMessageCreateOptions
       * @property {StickerResolvable} [stickers] The stickers to send with the message
       * @property {BitFieldResolvable} [flags] The flags to send with the message
       * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.SuppressNotifications` can be set.</info>
       */
      /**
       * Options for creating a thread.
       * @typedef {StartThreadOptions} GuildForumThreadCreateOptions
       * @property {GuildForumThreadMessageCreateOptions|MessagePayload} message The message associated with the thread post
       * @property {Snowflake[]} [appliedTags] The tags to apply to the thread
       */
      /**
       * Creates a new thread in the channel.
       * @param {GuildForumThreadCreateOptions} [options] Options to create a new thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Create a new forum post
       * forum.threads
       *   .create({
       *     name: 'Food Talk',
       *     autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
       *     message: {
       *      content: 'Discuss your favorite food!',
       *     },
       *     reason: 'Needed a separate thread for food',
       *   })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       */
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        message,
        reason,
        rateLimitPerUser,
        appliedTags
      } = {}) {
        if (!message) {
          throw new DiscordjsTypeError2(ErrorCodes2.GuildForumMessageRequired);
        }
        const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
        const data = await this.client.rest.post(Routes2.threads(this.channel.id), {
          body: {
            name,
            auto_archive_duration: autoArchiveDuration,
            rate_limit_per_user: rateLimitPerUser,
            applied_tags: appliedTags,
            message: body
          },
          files,
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildForumThreadManager;
  }
});

// node_modules/discord.js/src/structures/ThreadOnlyChannel.js
var require_ThreadOnlyChannel = __commonJS({
  "node_modules/discord.js/src/structures/ThreadOnlyChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildForumThreadManager = require_GuildForumThreadManager();
    var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();
    var ThreadOnlyChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.threads = new GuildForumThreadManager(this);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("available_tags" in data) {
          this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
        } else {
          this.availableTags ?? (this.availableTags = []);
        }
        if ("default_reaction_emoji" in data) {
          this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
        } else {
          this.defaultReactionEmoji ?? (this.defaultReactionEmoji = null);
        }
        if ("default_thread_rate_limit_per_user" in data) {
          this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
        } else {
          this.defaultThreadRateLimitPerUser ?? (this.defaultThreadRateLimitPerUser = null);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        } else {
          this.rateLimitPerUser ?? (this.rateLimitPerUser = null);
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        } else {
          this.defaultAutoArchiveDuration ?? (this.defaultAutoArchiveDuration = null);
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        } else {
          this.nsfw ?? (this.nsfw = false);
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("default_sort_order" in data) {
          this.defaultSortOrder = data.default_sort_order;
        } else {
          this.defaultSortOrder ?? (this.defaultSortOrder = null);
        }
      }
      /**
       * Sets the available tags for this forum channel
       * @param {GuildForumTagData[]} availableTags The tags to set as available in this channel
       * @param {string} [reason] Reason for changing the available tags
       * @returns {Promise<this>}
       */
      setAvailableTags(availableTags, reason) {
        return this.edit({ availableTags, reason });
      }
      /**
       * Sets the default reaction emoji for this channel
       * @param {?DefaultReactionEmoji} defaultReactionEmoji The emoji to set as the default reaction emoji
       * @param {string} [reason] Reason for changing the default reaction emoji
       * @returns {Promise<this>}
       */
      setDefaultReactionEmoji(defaultReactionEmoji, reason) {
        return this.edit({ defaultReactionEmoji, reason });
      }
      /**
       * Sets the default rate limit per user (slowmode) for new threads in this channel
       * @param {number} defaultThreadRateLimitPerUser The rate limit to set on newly created threads in this channel
       * @param {string} [reason] Reason for changing the default rate limit
       * @returns {Promise<this>}
       */
      setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
        return this.edit({ defaultThreadRateLimitPerUser, reason });
      }
      /**
       * Creates an invite to this guild channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      /**
       * Sets the default auto archive duration for all newly created threads in this channel.
       * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration
       * @param {string} [reason] Reason for changing the channel's default auto archive duration
       * @returns {Promise<this>}
       */
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration, reason });
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<this>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
      /**
       * Sets the default sort order mode used to order posts
       * @param {?SortOrderType} defaultSortOrder The default sort order mode to set on this channel
       * @param {string} [reason] Reason for changing the default sort order
       * @returns {Promise<this>}
       */
      setDefaultSortOrder(defaultSortOrder, reason) {
        return this.edit({ defaultSortOrder, reason });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      createWebhook() {
      }
      fetchWebhooks() {
      }
      setNSFW() {
      }
      setRateLimitPerUser() {
      }
    };
    TextBasedChannel.applyToClass(ThreadOnlyChannel, true, [
      "send",
      "lastMessage",
      "lastPinAt",
      "bulkDelete",
      "sendTyping",
      "createMessageCollector",
      "awaitMessages",
      "createMessageComponentCollector",
      "awaitMessageComponent"
    ]);
    module2.exports = ThreadOnlyChannel;
  }
});

// node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ThreadMemberFlagsBitField = class extends BitField {
    };
    /**
     * Numeric thread member flags. There are currently no bitflags relevant to bots for this.
     * @type {Object<string, number>}
     * @memberof ThreadMemberFlagsBitField
     */
    __publicField(ThreadMemberFlagsBitField, "Flags", {});
    module2.exports = ThreadMemberFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS({
  "node_modules/discord.js/src/structures/ThreadMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
    var ThreadMember = class extends Base {
      constructor(thread, data, extra = {}) {
        super(thread.client);
        this.thread = thread;
        this.joinedTimestamp = null;
        this.flags = null;
        this.id = data.user_id;
        this._patch(data, extra);
      }
      _patch(data, extra = {}) {
        if ("join_timestamp" in data)
          this.joinedTimestamp = Date.parse(data.join_timestamp);
        if ("flags" in data)
          this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
        if ("member" in data) {
          this.member = this.thread.guild.members._add(data.member, extra.cache);
        } else {
          this.member ?? (this.member = null);
        }
      }
      /**
       * Whether this thread member is a partial
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return this.flags === null;
      }
      /**
       * The guild member associated with this thread member
       * @type {?GuildMember}
       * @readonly
       */
      get guildMember() {
        return this.member ?? this.thread.guild.members.resolve(this.id);
      }
      /**
       * The last time this member joined the thread
       * @type {?Date}
       * @readonly
       */
      get joinedAt() {
        return this.joinedTimestamp && new Date(this.joinedTimestamp);
      }
      /**
       * The user associated with this thread member
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.client.users.resolve(this.id);
      }
      /**
       * Whether the client user can manage this thread member
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        return !this.thread.archived && this.thread.editable;
      }
      /**
       * Removes this member from the thread.
       * @param {string} [reason] Reason for removing the member
       * @returns {ThreadMember}
       */
      async remove(reason) {
        await this.thread.members.remove(this.id, reason);
        return this;
      }
    };
    module2.exports = ThreadMember;
  }
});

// node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS({
  "node_modules/discord.js/src/managers/ThreadMemberManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ThreadMember = require_ThreadMember();
    var ThreadMemberManager = class extends CachedManager {
      constructor(thread, iterable) {
        super(thread.client, ThreadMember, iterable);
        this.thread = thread;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, ThreadMember>}
       * @name ThreadMemberManager#cache
       */
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (cache)
          existing == null ? void 0 : existing._patch(data, { cache });
        if (existing)
          return existing;
        const member = new ThreadMember(this.thread, data, { cache });
        if (cache)
          this.cache.set(data.user_id, member);
        return member;
      }
      /**
       * Fetches the client user as a ThreadMember of the thread.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<ThreadMember>}
       */
      fetchMe(options) {
        return this.fetch({ ...options, member: this.client.user.id });
      }
      /**
       * The client user as a ThreadMember of this ThreadChannel
       * @type {?ThreadMember}
       * @readonly
       */
      get me() {
        return this.resolve(this.client.user.id);
      }
      /**
       * Data that resolves to give a ThreadMember object. This can be:
       * * A ThreadMember object
       * * A User resolvable
       * @typedef {ThreadMember|UserResolvable} ThreadMemberResolvable
       */
      /**
       * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} object.
       * @param {ThreadMemberResolvable} member The user that is part of the thread
       * @returns {?GuildMember}
       */
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable)
          return super.resolve(userResolvable);
        return null;
      }
      /**
       * Resolves a {@link ThreadMemberResolvable} to a {@link ThreadMember} id string.
       * @param {ThreadMemberResolvable} member The user that is part of the guild
       * @returns {?Snowflake}
       */
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      /**
       * Adds a member to the thread.
       * @param {UserResolvable|'@me'} member The member to add
       * @param {string} [reason] The reason for adding this member
       * @returns {Promise<Snowflake>}
       */
      async add(member, reason) {
        const id = member === "@me" ? member : this.client.users.resolveId(member);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "member", "UserResolvable");
        await this.client.rest.put(Routes2.threadMembers(this.thread.id, id), { reason });
        return id;
      }
      /**
       * Remove a user from the thread.
       * @param {Snowflake|'@me'} id The id of the member to remove
       * @param {string} [reason] The reason for removing this member from the thread
       * @returns {Promise<Snowflake>}
       */
      async remove(id, reason) {
        await this.client.rest.delete(Routes2.threadMembers(this.thread.id, id), { reason });
        return id;
      }
      /**
       * Options used to fetch a thread member.
       * @typedef {BaseFetchOptions} FetchThreadMemberOptions
       * @property {ThreadMemberResolvable} member The thread member to fetch
       * @property {boolean} [withMember] Whether to also return the guild member associated with this thread member
       */
      /**
       * Options used to fetch multiple thread members with guild member data.
       * <info>With `withMember` set to `true`, pagination is enabled.</info>
       * @typedef {Object} FetchThreadMembersWithGuildMemberDataOptions
       * @property {true} withMember Whether to also return the guild member data
       * @property {Snowflake} [after] Consider only thread members after this id
       * @property {number} [limit] The maximum number of thread members to return
       * @property {boolean} [cache] Whether to cache the fetched thread members and guild members
       */
      /**
       * Options used to fetch multiple thread members without guild member data.
       * @typedef {Object} FetchThreadMembersWithoutGuildMemberDataOptions
       * @property {false} [withMember] Whether to also return the guild member data
       * @property {boolean} [cache] Whether to cache the fetched thread members
       */
      /**
       * Options used to fetch multiple thread members.
       * @typedef {FetchThreadMembersWithGuildMemberDataOptions|
       * FetchThreadMembersWithoutGuildMemberDataOptions} FetchThreadMembersOptions
       */
      /**
       * Fetches thread member(s) from Discord.
       * <info>This method requires the {@link GatewayIntentBits.GuildMembers} privileged gateway intent.</info>
       * @param {ThreadMemberResolvable|FetchThreadMemberOptions|FetchThreadMembersOptions} [options]
       * Options for fetching thread member(s)
       * @returns {Promise<ThreadMember|Collection<Snowflake, ThreadMember>>}
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { member, withMember, cache, force } = options;
        const resolvedMember = this.resolveId(member ?? options);
        if (resolvedMember)
          return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
        return this._fetchMany(options);
      }
      async _fetchSingle({ member, withMember, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(member);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.threadMembers(this.thread.id, member), {
          query: makeURLSearchParams2({ with_member: withMember })
        });
        return this._add(data, cache);
      }
      async _fetchMany({ withMember, after, limit, cache } = {}) {
        const data = await this.client.rest.get(Routes2.threadMembers(this.thread.id), {
          query: makeURLSearchParams2({ with_member: withMember, after, limit })
        });
        return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection2());
      }
    };
    module2.exports = ThreadMemberManager;
  }
});

// node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS({
  "node_modules/discord.js/src/structures/ThreadChannel.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist();
    var { ChannelType, PermissionFlagsBits, Routes: Routes2, ChannelFlags } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var getThreadOnlyChannel = lazy(() => require_ThreadOnlyChannel());
    var TextBasedChannel = require_TextBasedChannel();
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildMessageManager = require_GuildMessageManager();
    var ThreadMemberManager = require_ThreadMemberManager();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var ThreadChannel = class extends BaseChannel {
      constructor(guild, data, client) {
        super((guild == null ? void 0 : guild.client) ?? client, data, false);
        this.guild = guild;
        this.guildId = (guild == null ? void 0 : guild.id) ?? data.guild_id;
        this.messages = new GuildMessageManager(this);
        this.members = new ThreadMemberManager(this);
        if (data)
          this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("message" in data)
          this.messages._add(data.message);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        } else {
          this.parentId ?? (this.parentId = null);
        }
        if ("thread_metadata" in data) {
          this.locked = data.thread_metadata.locked ?? false;
          this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
          this.archived = data.thread_metadata.archived;
          this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
          this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
          if ("create_timestamp" in data.thread_metadata) {
            this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
          }
        } else {
          this.locked ?? (this.locked = null);
          this.archived ?? (this.archived = null);
          this.autoArchiveDuration ?? (this.autoArchiveDuration = null);
          this.archiveTimestamp ?? (this.archiveTimestamp = null);
          this.invitable ?? (this.invitable = null);
        }
        this._createdTimestamp ?? (this._createdTimestamp = this.type === ChannelType.PrivateThread ? super.createdTimestamp : null);
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        } else {
          this.ownerId ?? (this.ownerId = null);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        } else {
          this.lastMessageId ?? (this.lastMessageId = null);
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
        } else {
          this.rateLimitPerUser ?? (this.rateLimitPerUser = null);
        }
        if ("message_count" in data) {
          this.messageCount = data.message_count;
        } else {
          this.messageCount ?? (this.messageCount = null);
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        } else {
          this.memberCount ?? (this.memberCount = null);
        }
        if ("total_message_sent" in data) {
          this.totalMessageSent = data.total_message_sent;
        } else {
          this.totalMessageSent ?? (this.totalMessageSent = null);
        }
        if (data.member && this.client.user)
          this.members._add({ user_id: this.client.user.id, ...data.member });
        if (data.messages)
          for (const message of data.messages)
            this.messages._add(message);
        if ("applied_tags" in data) {
          this.appliedTags = data.applied_tags;
        } else {
          this.appliedTags ?? (this.appliedTags = []);
        }
      }
      /**
       * The timestamp when this thread was created. This isn't available for threads
       * created before 2022-01-09
       * @type {?number}
       * @readonly
       */
      get createdTimestamp() {
        return this._createdTimestamp;
      }
      /**
       * A collection of associated guild member objects of this thread's members
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get guildMembers() {
        return this.members.cache.mapValues((member) => member.guildMember);
      }
      /**
       * The time at which this thread's archive status was last changed
       * <info>If the thread was never archived or unarchived, this is the time at which the thread was created</info>
       * @type {?Date}
       * @readonly
       */
      get archivedAt() {
        return this.archiveTimestamp && new Date(this.archiveTimestamp);
      }
      /**
       * The time the thread was created at
       * @type {?Date}
       * @readonly
       */
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      /**
       * The parent channel of this thread
       * @type {?(NewsChannel|TextChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      /**
       * Makes the client user join the thread.
       * @returns {Promise<ThreadChannel>}
       */
      async join() {
        await this.members.add("@me");
        return this;
      }
      /**
       * Makes the client user leave the thread.
       * @returns {Promise<ThreadChannel>}
       */
      async leave() {
        await this.members.remove("@me");
        return this;
      }
      /**
       * Gets the overall set of permissions for a member or role in this thread's parent channel, taking overwrites into
       * account.
       * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for
       * @param {boolean} [checkAdmin=true] Whether having the {@link PermissionFlagsBits.Administrator} permission
       * will return all permissions
       * @returns {?Readonly<PermissionsBitField>}
       */
      permissionsFor(memberOrRole, checkAdmin) {
        var _a;
        return ((_a = this.parent) == null ? void 0 : _a.permissionsFor(memberOrRole, checkAdmin)) ?? null;
      }
      /**
       * Fetches the owner of this thread. If the thread member object isn't needed,
       * use {@link ThreadChannel#ownerId} instead.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<?ThreadMember>}
       */
      async fetchOwner({ cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.members.cache.get(this.ownerId);
          if (existing)
            return existing;
        }
        const members = await this.members.fetch({ cache });
        return members.get(this.ownerId) ?? null;
      }
      /**
       * Fetches the message that started this thread, if any.
       * <info>The `Promise` will reject if the original message in a forum post is deleted
       * or when the original message in the parent channel is deleted.
       * If you just need the id of that message, use {@link ThreadChannel#id} instead.</info>
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?Message<true>>}
       */
      // eslint-disable-next-line require-await
      async fetchStarterMessage(options) {
        const channel = this.parent instanceof getThreadOnlyChannel() ? this : this.parent;
        return (channel == null ? void 0 : channel.messages.fetch({ message: this.id, ...options })) ?? null;
      }
      /**
       * The options used to edit a thread channel
       * @typedef {Object} ThreadEditOptions
       * @property {string} [name] The new name for the thread
       * @property {boolean} [archived] Whether the thread is archived
       * @property {ThreadAutoArchiveDuration} [autoArchiveDuration] The amount of time after which the thread
       * should automatically archive in case of no recent activity
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the thread in seconds
       * @property {boolean} [locked] Whether the thread is locked
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to a thread
       * <info>Can only be edited on {@link ChannelType.PrivateThread}</info>
       * @property {Snowflake[]} [appliedTags] The tags to apply to the thread
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel
       * @property {string} [reason] Reason for editing the thread
       */
      /**
       * Edits this thread.
       * @param {ThreadEditOptions} options The options to provide
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Edit a thread
       * thread.edit({ name: 'new-thread' })
       *   .then(editedThread => console.log(editedThread))
       *   .catch(console.error);
       */
      async edit(options) {
        const newData = await this.client.rest.patch(Routes2.channel(this.id), {
          body: {
            name: (options.name ?? this.name).trim(),
            archived: options.archived,
            auto_archive_duration: options.autoArchiveDuration,
            rate_limit_per_user: options.rateLimitPerUser,
            locked: options.locked,
            invitable: this.type === ChannelType.PrivateThread ? options.invitable : void 0,
            applied_tags: options.appliedTags,
            flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : void 0
          },
          reason: options.reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Sets whether the thread is archived.
       * @param {boolean} [archived=true] Whether the thread is archived
       * @param {string} [reason] Reason for archiving or unarchiving
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Archive the thread
       * thread.setArchived(true)
       *   .then(newThread => console.log(`Thread is now ${newThread.archived ? 'archived' : 'active'}`))
       *   .catch(console.error);
       */
      setArchived(archived = true, reason) {
        return this.edit({ archived, reason });
      }
      /**
       * Sets the duration after which the thread will automatically archive in case of no recent activity.
       * @param {ThreadAutoArchiveDuration} autoArchiveDuration The amount of time after which the thread
       * should automatically archive in case of no recent activity
       * @param {string} [reason] Reason for changing the auto archive duration
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Set the thread's auto archive time to 1 hour
       * thread.setAutoArchiveDuration(ThreadAutoArchiveDuration.OneHour)
       *   .then(newThread => {
       *     console.log(`Thread will now archive after ${newThread.autoArchiveDuration} minutes of inactivity`);
       *    });
       *   .catch(console.error);
       */
      setAutoArchiveDuration(autoArchiveDuration, reason) {
        return this.edit({ autoArchiveDuration, reason });
      }
      /**
       * Sets whether members without the {@link PermissionFlagsBits.ManageThreads} permission
       * can invite other members to this thread.
       * @param {boolean} [invitable=true] Whether non-moderators can invite non-moderators to this thread
       * @param {string} [reason] Reason for changing invite
       * @returns {Promise<ThreadChannel>}
       */
      setInvitable(invitable = true, reason) {
        if (this.type !== ChannelType.PrivateThread) {
          return Promise.reject(new DiscordjsRangeError2(ErrorCodes2.ThreadInvitableType, this.type));
        }
        return this.edit({ invitable, reason });
      }
      /**
       * Sets whether the thread can be **unarchived** by anyone with the
       * {@link PermissionFlagsBits.SendMessages} permission. When a thread is locked, only members with the
       * {@link PermissionFlagsBits.ManageThreads} permission can unarchive it.
       * @param {boolean} [locked=true] Whether the thread is locked
       * @param {string} [reason] Reason for locking or unlocking the thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Set the thread to locked
       * thread.setLocked(true)
       *   .then(newThread => console.log(`Thread is now ${newThread.locked ? 'locked' : 'unlocked'}`))
       *   .catch(console.error);
       */
      setLocked(locked = true, reason) {
        return this.edit({ locked, reason });
      }
      /**
       * Sets a new name for this thread.
       * @param {string} name The new name for the thread
       * @param {string} [reason] Reason for changing the thread's name
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Change the thread's name
       * thread.setName('not_general')
       *   .then(newThread => console.log(`Thread's new name is ${newThread.name}`))
       *   .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets the rate limit per user (slowmode) for this thread.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the thread's rate limit
       * @returns {Promise<ThreadChannel>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
      /**
       * Set the applied tags for this channel (only applicable to forum threads)
       * @param {Snowflake[]} appliedTags The tags to set for this channel
       * @param {string} [reason] Reason for changing the thread's applied tags
       * @returns {Promise<ThreadChannel>}
       */
      setAppliedTags(appliedTags, reason) {
        return this.edit({ appliedTags, reason });
      }
      /**
       * Pins this thread from the forum channel (only applicable to forum threads).
       * @param {string} [reason] Reason for pinning
       * @returns {Promise<ThreadChannel>}
       */
      pin(reason) {
        return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
      }
      /**
       * Unpins this thread from the forum channel (only applicable to forum threads).
       * @param {string} [reason] Reason for unpinning
       * @returns {Promise<ThreadChannel>}
       */
      unpin(reason) {
        return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
      }
      /**
       * Whether the client user is a member of the thread.
       * @type {boolean}
       * @readonly
       */
      get joined() {
        var _a;
        return this.members.cache.has((_a = this.client.user) == null ? void 0 : _a.id);
      }
      /**
       * Whether the thread is editable by the client user (name, archived, autoArchiveDuration)
       * @type {boolean}
       * @readonly
       */
      get editable() {
        return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
      }
      /**
       * Whether the thread is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        var _a;
        return !this.archived && !this.joined && ((_a = this.permissionsFor(this.client.user)) == null ? void 0 : _a.has(
          this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel,
          false
        ));
      }
      /**
       * Whether the thread is manageable by the client user, for deleting or editing rateLimitPerUser or locked.
       * @type {boolean}
       * @readonly
       */
      get manageable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
      }
      /**
       * Whether the thread is viewable by the client user
       * @type {boolean}
       * @readonly
       */
      get viewable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        return permissions.has(PermissionFlagsBits.ViewChannel, false);
      }
      /**
       * Whether the client user can send messages in this thread
       * @type {boolean}
       * @readonly
       */
      get sendable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
      }
      /**
       * Whether the thread is unarchivable by the client user
       * @type {boolean}
       * @readonly
       */
      get unarchivable() {
        return this.archived && this.sendable && (!this.locked || this.manageable);
      }
      /**
       * Deletes this thread.
       * @param {string} [reason] Reason for deleting this thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Delete the thread
       * thread.delete('cleaning out old threads')
       *   .then(deletedThread => console.log(deletedThread))
       *   .catch(console.error);
       */
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      // Doesn't work on Thread channels; setRateLimitPerUser() {}
      // Doesn't work on Thread channels; setNSFW() {}
    };
    TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
    module2.exports = ThreadChannel;
  }
});

// node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS({
  "node_modules/discord.js/src/managers/ThreadManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ThreadChannel = require_ThreadChannel();
    var { MakeCacheOverrideSymbol } = require_Symbols();
    var _a;
    var _ThreadManager = class _ThreadManager extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, ThreadChannel, iterable);
        this.channel = channel;
      }
      /**
       * Data that can be resolved to a Thread Channel object. This can be:
       * * A ThreadChannel object
       * * A Snowflake
       * @typedef {ThreadChannel|Snowflake} ThreadChannelResolvable
       */
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, ThreadChannel>}
       * @name ThreadManager#cache
       */
      _add(thread) {
        const existing = this.cache.get(thread.id);
        if (existing)
          return existing;
        this.cache.set(thread.id, thread);
        return thread;
      }
      /**
       * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} object.
       * @method resolve
       * @memberof ThreadManager
       * @instance
       * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve
       * @returns {?ThreadChannel}
       */
      /**
       * Resolves a {@link ThreadChannelResolvable} to a {@link ThreadChannel} id.
       * @method resolveId
       * @memberof ThreadManager
       * @instance
       * @param {ThreadChannelResolvable} thread The ThreadChannel resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>
       * @typedef {StartThreadOptions} ThreadCreateOptions
       * @property {MessageResolvable} [startMessage] The message to start a thread from. <warn>If this is defined then type
       * of thread gets automatically defined and cannot be changed. The provided `type` field will be ignored</warn>
       * @property {ChannelType.AnnouncementThread|ChannelType.PublicThread|ChannelType.PrivateThread} [type]
       * The type of thread to create.
       * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}
       * <warn>When creating threads in a {@link NewsChannel} this is ignored and is always
       * {@link ChannelType.AnnouncementThread}</warn>
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread
       * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>
       */
      /**
       * Options for fetching multiple threads.
       * @typedef {Object} FetchThreadsOptions
       * @property {FetchArchivedThreadOptions} [archived] Options used to fetch archived threads
       */
      /**
       * Obtains a thread from Discord, or the channel cache if it's already available.
       * @param {ThreadChannelResolvable|FetchThreadsOptions} [options] The options to fetch threads. If it is a
       * ThreadChannelResolvable then the specified thread will be fetched. Fetches all active threads if `undefined`
       * @param {BaseFetchOptions} [cacheOptions] Additional options for this fetch. <warn>The `force` field gets ignored
       * if `options` is not a {@link ThreadChannelResolvable}</warn>
       * @returns {Promise<?(ThreadChannel|FetchedThreads|FetchedThreadsMore)>}
       * {@link FetchedThreads} if active & {@link FetchedThreadsMore} if archived.
       * @example
       * // Fetch a thread by its id
       * channel.threads.fetch('831955138126104859')
       *   .then(channel => console.log(channel.name))
       *   .catch(console.error);
       */
      fetch(options, { cache, force } = {}) {
        if (!options)
          return this.fetchActive(cache);
        const channel = this.client.channels.resolveId(options);
        if (channel)
          return this.client.channels.fetch(channel, { cache, force });
        if (options.archived) {
          return this.fetchArchived(options.archived, cache);
        }
        return this.fetchActive(cache);
      }
      /**
       * Data that can be resolved to a Date object. This can be:
       * * A Date object
       * * A number representing a timestamp
       * * An [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string
       * @typedef {Date|number|string} DateResolvable
       */
      /**
       * The options used to fetch archived threads.
       * @typedef {Object} FetchArchivedThreadOptions
       * @property {string} [type='public'] The type of threads to fetch (`public` or `private`)
       * @property {boolean} [fetchAll=false] Whether to fetch **all** archived threads when `type` is `private`
       * <info>This property requires the {@link PermissionFlagsBits.ManageThreads} permission if `true`.</info>
       * @property {DateResolvable|ThreadChannelResolvable} [before] Only return threads that were archived before this Date
       * or Snowflake
       * <warn>Must be a {@link ThreadChannelResolvable} when `type` is `private` and `fetchAll` is `false`.</warn>
       * @property {number} [limit] Maximum number of threads to return
       */
      /**
       * Data returned from fetching multiple threads.
       * @typedef {FetchedThreads} FetchedThreadsMore
       * @property {?boolean} hasMore Whether there are potentially additional threads that require a subsequent call
       */
      /**
       * Obtains a set of archived threads from Discord.
       * <info>This method requires the {@link PermissionFlagsBits.ReadMessageHistory} permission
       * in the parent channel.</info>
       * @param {FetchArchivedThreadOptions} [options] The options to fetch archived threads
       * @param {boolean} [cache=true] Whether to cache the new thread objects if they aren't already
       * @returns {Promise<FetchedThreadsMore>}
       */
      async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
        var _a2, _b;
        let path = Routes2.channelThreads(this.channel.id, type);
        if (type === "private" && !fetchAll) {
          path = Routes2.channelJoinedArchivedThreads(this.channel.id);
        }
        let timestamp;
        let id;
        const query = makeURLSearchParams2({ limit });
        if (before !== void 0) {
          if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
            id = this.resolveId(before);
            timestamp = (_b = (_a2 = this.resolve(before)) == null ? void 0 : _a2.archivedAt) == null ? void 0 : _b.toISOString();
            const toUse = type === "private" && !fetchAll ? id : timestamp;
            if (toUse) {
              query.set("before", toUse);
            }
          } else {
            try {
              timestamp = new Date(before).toISOString();
              if (type === "public" || fetchAll) {
                query.set("before", timestamp);
              }
            } catch {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
            }
          }
        }
        const raw = await this.client.rest.get(path, { query });
        return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
      }
      /**
       * Obtains all active threads in the channel.
       * @param {boolean} [cache=true] Whether to cache the fetched data
       * @returns {Promise<FetchedThreads>}
       */
      async fetchActive(cache = true) {
        const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();
        return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });
      }
      static _mapThreads(rawThreads, client, { parent, guild, cache }) {
        const threads = rawThreads.threads.reduce((coll, raw) => {
          const thread = client.channels._add(raw, guild ?? (parent == null ? void 0 : parent.guild), { cache });
          if (parent && thread.parentId !== parent.id)
            return coll;
          return coll.set(thread.id, thread);
        }, new Collection2());
        const threadMembers = rawThreads.members.reduce((coll, raw) => {
          const thread = threads.get(raw.id);
          return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;
        }, new Collection2());
        const response = { threads, members: threadMembers };
        if ("has_more" in rawThreads)
          response.hasMore = rawThreads.has_more;
        return response;
      }
    };
    _a = MakeCacheOverrideSymbol;
    __publicField(_ThreadManager, _a, _ThreadManager);
    var ThreadManager = _ThreadManager;
    module2.exports = ThreadManager;
  }
});

// node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildTextThreadManager.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes2 } = require_v106();
    var ThreadManager = require_ThreadManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildTextThreadManager = class extends ThreadManager {
      /**
       * The channel this Manager belongs to
       * @name GuildTextThreadManager#channel
       * @type {TextChannel|NewsChannel}
       */
      /**
       * Options for creating a thread. <warn>Only one of `startMessage` or `type` can be defined.</warn>
       * @typedef {StartThreadOptions} ThreadCreateOptions
       * @property {MessageResolvable} [startMessage] The message to start a thread from.
       * <warn>If this is defined, then the `type` of thread gets inferred automatically and cannot be changed.</warn>
       * @property {ThreadChannelTypes} [type] The type of thread to create.
       * Defaults to {@link ChannelType.PublicThread} if created in a {@link TextChannel}
       * <warn>When creating threads in a {@link NewsChannel}, this is ignored and is always
       * {@link ChannelType.AnnouncementThread}</warn>
       * @property {boolean} [invitable] Whether non-moderators can add other non-moderators to the thread
       * <info>Can only be set when type will be {@link ChannelType.PrivateThread}</info>
       */
      /**
       * Creates a new thread in the channel.
       * @param {ThreadCreateOptions} [options] Options to create a new thread
       * @returns {Promise<ThreadChannel>}
       * @example
       * // Create a new public thread
       * channel.threads
       *   .create({
       *     name: 'food-talk',
       *     autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
       *     reason: 'Needed a separate thread for food',
       *   })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       * @example
       * // Create a new private thread
       * channel.threads
       *   .create({
       *      name: 'mod-talk',
       *      autoArchiveDuration: ThreadAutoArchiveDuration.OneHour,
       *      type: ChannelType.PrivateThread,
       *      reason: 'Needed a separate thread for moderation',
       *    })
       *   .then(threadChannel => console.log(threadChannel))
       *   .catch(console.error);
       */
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        startMessage,
        type,
        invitable,
        reason,
        rateLimitPerUser
      } = {}) {
        let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
        let startMessageId;
        if (startMessage) {
          startMessageId = this.channel.messages.resolveId(startMessage);
          if (!startMessageId)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "startMessage", "MessageResolvable");
        } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
          resolvedType = type ?? resolvedType;
        }
        const data = await this.client.rest.post(Routes2.threads(this.channel.id, startMessageId), {
          body: {
            name,
            auto_archive_duration: autoArchiveDuration,
            type: resolvedType,
            invitable: resolvedType === ChannelType.PrivateThread ? invitable : void 0,
            rate_limit_per_user: rateLimitPerUser
          },
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildTextThreadManager;
  }
});

// node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuildTextChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildMessageManager = require_GuildMessageManager();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var BaseGuildTextChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new GuildMessageManager(this);
        this.threads = new GuildTextThreadManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("nsfw" in data) {
          this.nsfw = Boolean(data.nsfw);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        }
        if ("default_thread_rate_limit_per_user" in data) {
          this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
        } else {
          this.defaultThreadRateLimitPerUser ?? (this.defaultThreadRateLimitPerUser = null);
        }
        if ("messages" in data) {
          for (const message of data.messages)
            this.messages._add(message);
        }
      }
      /**
       * Sets the default auto archive duration for all newly created threads in this channel.
       * @param {ThreadAutoArchiveDuration} defaultAutoArchiveDuration The new default auto archive duration
       * @param {string} [reason] Reason for changing the channel's default auto archive duration
       * @returns {Promise<TextChannel>}
       */
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration, reason });
      }
      /**
       * Sets the type of this channel.
       * <info>Only conversion between {@link TextChannel} and {@link NewsChannel} is supported.</info>
       * @param {ChannelType.GuildText|ChannelType.GuildAnnouncement} type The new channel type
       * @param {string} [reason] Reason for changing the channel's type
       * @returns {Promise<GuildChannel>}
       */
      setType(type, reason) {
        return this.edit({ type, reason });
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel topic
       * channel.setTopic('needs more rate limiting')
       *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
      /**
       * Data that can be resolved to an Application. This can be:
       * * An Application
       * * An Activity with associated Application
       * * A Snowflake
       * @typedef {Application|Snowflake} ApplicationResolvable
       */
      /**
       * Options used to create an invite to a guild channel.
       * @typedef {Object} InviteCreateOptions
       * @property {boolean} [temporary] Whether members that joined via the invite should be automatically
       * kicked after 24 hours if they have not yet received a role
       * @property {number} [maxAge] How long the invite should last (in seconds, 0 for forever)
       * @property {number} [maxUses] Maximum number of uses
       * @property {boolean} [unique] Create a unique invite, or use an existing one with similar settings
       * @property {UserResolvable} [targetUser] The user whose stream to display for this invite,
       * required if `targetType` is {@link InviteTargetType.Stream}, the user must be streaming in the channel
       * @property {ApplicationResolvable} [targetApplication] The embedded application to open for this invite,
       * required if `targetType` is {@link InviteTargetType.Stream}, the application must have the
       * {@link InviteTargetType.EmbeddedApplication} flag
       * @property {InviteTargetType} [targetType] The type of the target for this voice channel invite
       * @property {string} [reason] The reason for creating the invite
       */
      /**
       * Creates an invite to this guild channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * Resolves with a collection mapping invites by their codes.
       * @param {boolean} [cache=true] Whether or not to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
    module2.exports = BaseGuildTextChannel;
  }
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS({
  "node_modules/discord.js/src/structures/NewsChannel.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var NewsChannel = class extends BaseGuildTextChannel {
      /**
       * Adds the target to this channel's followers.
       * @param {TextChannelResolvable} channel The channel where the webhook should be created
       * @param {string} [reason] Reason for creating the webhook
       * @returns {Promise<NewsChannel>}
       * @example
       * if (channel.type === ChannelType.GuildAnnouncement) {
       *   channel.addFollower('222197033908436994', 'Important announcements')
       *     .then(() => console.log('Added follower'))
       *     .catch(console.error);
       * }
       */
      async addFollower(channel, reason) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        await this.client.rest.post(Routes2.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
        return this;
      }
    };
    module2.exports = NewsChannel;
  }
});

// node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS({
  "node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { PermissionFlagsBits } = require_v106();
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildMessageManager = require_GuildMessageManager();
    var BaseGuildVoiceChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new GuildMessageManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("rtc_region" in data) {
          this.rtcRegion = data.rtc_region;
        }
        if ("bitrate" in data) {
          this.bitrate = data.bitrate;
        }
        if ("user_limit" in data) {
          this.userLimit = data.user_limit;
        }
        if ("video_quality_mode" in data) {
          this.videoQualityMode = data.video_quality_mode;
        } else {
          this.videoQualityMode ?? (this.videoQualityMode = null);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("messages" in data) {
          for (const message of data.messages)
            this.messages._add(message);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        }
      }
      /**
       * The members in this voice-based channel
       * @type {Collection<Snowflake, GuildMember>}
       * @readonly
       */
      get members() {
        const coll = new Collection2();
        for (const state of this.guild.voiceStates.cache.values()) {
          if (state.channelId === this.id && state.member) {
            coll.set(state.id, state.member);
          }
        }
        return coll;
      }
      /**
       * Checks if the voice-based channel is full
       * @type {boolean}
       * @readonly
       */
      get full() {
        return this.userLimit > 0 && this.members.size >= this.userLimit;
      }
      /**
       * Whether the channel is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        if (!this.viewable)
          return false;
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
      }
      /**
       * Creates an invite to this guild channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a channel
       * channel.createInvite()
       *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))
       *   .catch(console.error);
       */
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      /**
       * Fetches a collection of invites to this guild channel.
       * @param {boolean} [cache=true] Whether to cache the fetched invites
       * @returns {Promise<Collection<string, Invite>>}
       */
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      /**
       * Sets the bitrate of the channel.
       * @param {number} bitrate The new bitrate
       * @param {string} [reason] Reason for changing the channel's bitrate
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the bitrate of a voice channel
       * channel.setBitrate(48_000)
       *   .then(channel => console.log(`Set bitrate to ${channel.bitrate}bps for ${channel.name}`))
       *   .catch(console.error);
       */
      setBitrate(bitrate, reason) {
        return this.edit({ bitrate, reason });
      }
      /**
       * Sets the RTC region of the channel.
       * @param {?string} rtcRegion The new region of the channel. Set to `null` to remove a specific region for the channel
       * @param {string} [reason] The reason for modifying this region.
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the RTC region to sydney
       * channel.setRTCRegion('sydney');
       * @example
       * // Remove a fixed region for this channel - let Discord decide automatically
       * channel.setRTCRegion(null, 'We want to let Discord decide.');
       */
      setRTCRegion(rtcRegion, reason) {
        return this.edit({ rtcRegion, reason });
      }
      /**
       * Sets the user limit of the channel.
       * @param {number} userLimit The new user limit
       * @param {string} [reason] Reason for changing the user limit
       * @returns {Promise<BaseGuildVoiceChannel>}
       * @example
       * // Set the user limit of a voice channel
       * channel.setUserLimit(42)
       *   .then(channel => console.log(`Set user limit to ${channel.userLimit} for ${channel.name}`))
       *   .catch(console.error);
       */
      setUserLimit(userLimit, reason) {
        return this.edit({ userLimit, reason });
      }
      /**
       * Sets the camera video quality mode of the channel.
       * @param {VideoQualityMode} videoQualityMode The new camera video quality mode.
       * @param {string} [reason] Reason for changing the camera video quality mode.
       * @returns {Promise<BaseGuildVoiceChannel>}
       */
      setVideoQualityMode(videoQualityMode, reason) {
        return this.edit({ videoQualityMode, reason });
      }
      // These are here only for documentation purposes - they are implemented by TextBasedChannel
      /* eslint-disable no-empty-function */
      get lastMessage() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
    module2.exports = BaseGuildVoiceChannel;
  }
});

// node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS({
  "node_modules/discord.js/src/structures/StageChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var StageChannel = class extends BaseGuildVoiceChannel {
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
      }
      /**
       * The stage instance of this stage channel, if it exists
       * @type {?StageInstance}
       * @readonly
       */
      get stageInstance() {
        return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
      }
      /**
       * Creates a stage instance associated with this stage channel.
       * @param {StageInstanceCreateOptions} options The options to create the stage instance
       * @returns {Promise<StageInstance>}
       */
      createStageInstance(options) {
        return this.guild.stageInstances.create(this.id, options);
      }
      /**
       * Sets a new topic for the guild channel.
       * @param {?string} topic The new topic for the guild channel
       * @param {string} [reason] Reason for changing the guild channel's topic
       * @returns {Promise<StageChannel>}
       * @example
       * // Set a new channel topic
       * stageChannel.setTopic('needs more rate limiting')
       *   .then(channel => console.log(`Channel's new topic is ${channel.topic}`))
       *   .catch(console.error);
       */
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
    };
    module2.exports = StageChannel;
  }
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS({
  "node_modules/discord.js/src/structures/TextChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var TextChannel = class extends BaseGuildTextChannel {
      _patch(data) {
        super._patch(data);
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
      }
      /**
       * Sets the rate limit per user (slowmode) for this channel.
       * @param {number} rateLimitPerUser The new rate limit in seconds
       * @param {string} [reason] Reason for changing the channel's rate limit
       * @returns {Promise<TextChannel>}
       */
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
    };
    module2.exports = TextChannel;
  }
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS({
  "node_modules/discord.js/src/structures/VoiceChannel.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits } = require_v106();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var VoiceChannel = class extends BaseGuildVoiceChannel {
      /**
       * Whether the channel is joinable by the client user
       * @type {boolean}
       * @readonly
       */
      get joinable() {
        if (!super.joinable)
          return false;
        if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
          return false;
        return true;
      }
      /**
       * Checks if the client has permission to send audio to the voice channel
       * @type {boolean}
       * @readonly
       */
      get speakable() {
        const permissions = this.permissionsFor(this.client.user);
        if (!permissions)
          return false;
        if (permissions.has(PermissionFlagsBits.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
      }
    };
    module2.exports = VoiceChannel;
  }
});

// node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS({
  "node_modules/discord.js/src/structures/DirectoryChannel.js"(exports2, module2) {
    "use strict";
    var { BaseChannel } = require_BaseChannel();
    var DirectoryChannel = class extends BaseChannel {
      constructor(guild, data, client) {
        super(client, data);
        this.guild = guild;
        this.guildId = guild.id;
      }
      _patch(data) {
        super._patch(data);
        this.name = data.name;
      }
    };
    module2.exports = DirectoryChannel;
  }
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS({
  "node_modules/discord.js/src/structures/PartialGroupDMChannel.js"(exports2, module2) {
    "use strict";
    var { BaseChannel } = require_BaseChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var PartialGroupDMChannel = class extends BaseChannel {
      constructor(client, data) {
        super(client, data);
        this.flags = null;
        this.name = data.name;
        this.icon = data.icon;
        this.recipients = data.recipients;
      }
      /**
       * The URL to this channel's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
      }
      delete() {
        return Promise.reject(new DiscordjsError2(ErrorCodes2.DeleteGroupDMChannel));
      }
      fetch() {
        return Promise.reject(new DiscordjsError2(ErrorCodes2.FetchGroupDMChannel));
      }
    };
    module2.exports = PartialGroupDMChannel;
  }
});

// node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS({
  "node_modules/discord.js/src/structures/ForumChannel.js"(exports2, module2) {
    "use strict";
    var ThreadOnlyChannel = require_ThreadOnlyChannel();
    var ForumChannel = class extends ThreadOnlyChannel {
      _patch(data) {
        super._patch(data);
        this.defaultForumLayout = data.default_forum_layout;
      }
      /**
       * Sets the default forum layout type used to display posts
       * @param {ForumLayoutType} defaultForumLayout The default forum layout type to set on this channel
       * @param {string} [reason] Reason for changing the default forum layout
       * @returns {Promise<ForumChannel>}
       */
      setDefaultForumLayout(defaultForumLayout, reason) {
        return this.edit({ defaultForumLayout, reason });
      }
    };
    module2.exports = ForumChannel;
  }
});

// node_modules/discord.js/src/structures/MediaChannel.js
var require_MediaChannel = __commonJS({
  "node_modules/discord.js/src/structures/MediaChannel.js"(exports2, module2) {
    "use strict";
    var ThreadOnlyChannel = require_ThreadOnlyChannel();
    var MediaChannel = class extends ThreadOnlyChannel {
    };
    module2.exports = MediaChannel;
  }
});

// node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS({
  "node_modules/discord.js/src/util/Channels.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist();
    var { ChannelType } = require_v106();
    var getCategoryChannel = lazy(() => require_CategoryChannel());
    var getDMChannel = lazy(() => require_DMChannel());
    var getNewsChannel = lazy(() => require_NewsChannel());
    var getStageChannel = lazy(() => require_StageChannel());
    var getTextChannel = lazy(() => require_TextChannel());
    var getThreadChannel = lazy(() => require_ThreadChannel());
    var getVoiceChannel = lazy(() => require_VoiceChannel());
    var getDirectoryChannel = lazy(() => require_DirectoryChannel());
    var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
    var getForumChannel = lazy(() => require_ForumChannel());
    var getMediaChannel = lazy(() => require_MediaChannel());
    function createChannel(client, data, guild, { allowUnknownGuild } = {}) {
      var _a, _b;
      let channel;
      if (!data.guild_id && !guild) {
        if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
          channel = new (getDMChannel())(client, data);
        } else if (data.type === ChannelType.GroupDM) {
          channel = new (getPartialGroupDMChannel())(client, data);
        }
      } else {
        guild ?? (guild = client.guilds.cache.get(data.guild_id));
        if (guild || allowUnknownGuild) {
          switch (data.type) {
            case ChannelType.GuildText: {
              channel = new (getTextChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildVoice: {
              channel = new (getVoiceChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildCategory: {
              channel = new (getCategoryChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildAnnouncement: {
              channel = new (getNewsChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildStageVoice: {
              channel = new (getStageChannel())(guild, data, client);
              break;
            }
            case ChannelType.AnnouncementThread:
            case ChannelType.PublicThread:
            case ChannelType.PrivateThread: {
              channel = new (getThreadChannel())(guild, data, client);
              if (!allowUnknownGuild)
                (_a = channel.parent) == null ? void 0 : _a.threads.cache.set(channel.id, channel);
              break;
            }
            case ChannelType.GuildDirectory:
              channel = new (getDirectoryChannel())(guild, data, client);
              break;
            case ChannelType.GuildForum:
              channel = new (getForumChannel())(guild, data, client);
              break;
            case ChannelType.GuildMedia:
              channel = new (getMediaChannel())(guild, data, client);
              break;
          }
          if (channel && !allowUnknownGuild)
            (_b = guild.channels) == null ? void 0 : _b.cache.set(channel.id, channel);
        }
      }
      return channel;
    }
    function transformAPIGuildForumTag(tag) {
      return {
        id: tag.id,
        name: tag.name,
        moderated: tag.moderated,
        emoji: tag.emoji_id ?? tag.emoji_name ? {
          id: tag.emoji_id,
          name: tag.emoji_name
        } : null
      };
    }
    function transformGuildForumTag(tag) {
      var _a, _b;
      return {
        id: tag.id,
        name: tag.name,
        moderated: tag.moderated,
        emoji_id: ((_a = tag.emoji) == null ? void 0 : _a.id) ?? null,
        emoji_name: ((_b = tag.emoji) == null ? void 0 : _b.name) ?? null
      };
    }
    function transformAPIGuildDefaultReaction(defaultReaction) {
      return {
        id: defaultReaction.emoji_id,
        name: defaultReaction.emoji_name
      };
    }
    function transformGuildDefaultReaction(defaultReaction) {
      return {
        emoji_id: defaultReaction.id,
        emoji_name: defaultReaction.name
      };
    }
    module2.exports = {
      createChannel,
      transformAPIGuildForumTag,
      transformGuildForumTag,
      transformAPIGuildDefaultReaction,
      transformGuildDefaultReaction
    };
  }
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ChannelUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { createChannel } = require_Channels();
    var ChannelUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        let channel = client.channels.cache.get(data.id);
        if (channel) {
          const old = channel._update(data);
          if (channel.type !== data.type) {
            const newChannel = createChannel(this.client, data, channel.guild);
            if (!newChannel) {
              this.client.channels.cache.delete(channel.id);
              return {};
            }
            if (channel.isTextBased() && newChannel.isTextBased()) {
              for (const [id, message] of channel.messages.cache)
                newChannel.messages.cache.set(id, message);
            }
            channel = newChannel;
            this.client.channels.cache.set(channel.id, channel);
          }
          return {
            old,
            updated: channel
          };
        } else {
          client.channels._add(data);
        }
        return {};
      }
    };
    module2.exports = ChannelUpdateAction;
  }
});

// node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS({
  "node_modules/discord.js/src/structures/AutoModerationRule.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Base = require_Base();
    var { _transformAPIAutoModerationAction } = require_Transformers();
    var AutoModerationRule = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.id = data.id;
        this.guild = guild;
        this.creatorId = data.creator_id;
        this.triggerType = data.trigger_type;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        if ("event_type" in data) {
          this.eventType = data.event_type;
        }
        if ("trigger_metadata" in data) {
          this.triggerMetadata = {
            keywordFilter: data.trigger_metadata.keyword_filter ?? [],
            regexPatterns: data.trigger_metadata.regex_patterns ?? [],
            presets: data.trigger_metadata.presets ?? [],
            allowList: data.trigger_metadata.allow_list ?? [],
            mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
            mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
          };
        }
        if ("actions" in data) {
          this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
        }
        if ("enabled" in data) {
          this.enabled = data.enabled;
        }
        if ("exempt_roles" in data) {
          this.exemptRoles = new Collection2(
            data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)])
          );
        }
        if ("exempt_channels" in data) {
          this.exemptChannels = new Collection2(
            data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)])
          );
        }
      }
      /**
       * Edits this auto moderation rule.
       * @param {AutoModerationRuleEditOptions} options Options for editing this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      edit(options) {
        return this.guild.autoModerationRules.edit(this.id, options);
      }
      /**
       * Deletes this auto moderation rule.
       * @param {string} [reason] The reason for deleting this auto moderation rule
       * @returns {Promise<void>}
       */
      delete(reason) {
        return this.guild.autoModerationRules.delete(this.id, reason);
      }
      /**
       * Sets the name for this auto moderation rule.
       * @param {string} name The name of this auto moderation rule
       * @param {string} [reason] The reason for changing the name of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Sets the event type for this auto moderation rule.
       * @param {AutoModerationRuleEventType} eventType The event type of this auto moderation rule
       * @param {string} [reason] The reason for changing the event type of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setEventType(eventType, reason) {
        return this.edit({ eventType, reason });
      }
      /**
       * Sets the keyword filter for this auto moderation rule.
       * @param {string[]} keywordFilter The keyword filter of this auto moderation rule
       * @param {string} [reason] The reason for changing the keyword filter of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setKeywordFilter(keywordFilter, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
      }
      /**
       * Sets the regular expression patterns for this auto moderation rule.
       * @param {string[]} regexPatterns The regular expression patterns of this auto moderation rule
       * <info>Only Rust-flavored regular expressions are supported.</info>
       * @param {string} [reason] The reason for changing the regular expression patterns of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setRegexPatterns(regexPatterns, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
      }
      /**
       * Sets the presets for this auto moderation rule.
       * @param {AutoModerationRuleKeywordPresetType[]} presets The presets of this auto moderation rule
       * @param {string} [reason] The reason for changing the presets of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setPresets(presets, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
      }
      /**
       * Sets the allow list for this auto moderation rule.
       * @param {string[]} allowList The substrings that will be exempt from triggering
       * {@link AutoModerationRuleTriggerType.Keyword} and {@link AutoModerationRuleTriggerType.KeywordPreset}
       * @param {string} [reason] The reason for changing the allow list of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setAllowList(allowList, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
      }
      /**
       * Sets the mention total limit for this auto moderation rule.
       * @param {number} mentionTotalLimit The total number of unique role and user mentions allowed per message
       * @param {string} [reason] The reason for changing the mention total limit of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setMentionTotalLimit(mentionTotalLimit, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
      }
      /**
       * Sets whether to enable mention raid protection for this auto moderation rule.
       * @param {boolean} mentionRaidProtectionEnabled
       * Whether to enable mention raid protection for this auto moderation rule
       * @param {string} [reason] The reason for changing the mention raid protection of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
        return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
      }
      /**
       * Sets the actions for this auto moderation rule.
       * @param {AutoModerationActionOptions[]} actions The actions of this auto moderation rule
       * @param {string} [reason] The reason for changing the actions of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setActions(actions, reason) {
        return this.edit({ actions, reason });
      }
      /**
       * Sets whether this auto moderation rule should be enabled.
       * @param {boolean} [enabled=true] Whether to enable this auto moderation rule
       * @param {string} [reason] The reason for enabling or disabling this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setEnabled(enabled = true, reason) {
        return this.edit({ enabled, reason });
      }
      /**
       * Sets the exempt roles for this auto moderation rule.
       * @param {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @param {string} [reason] The reason for changing the exempt roles of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setExemptRoles(exemptRoles, reason) {
        return this.edit({ exemptRoles, reason });
      }
      /**
       * Sets the exempt channels for this auto moderation rule.
       * @param {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @param {string} [reason] The reason for changing the exempt channels of this auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      setExemptChannels(exemptChannels, reason) {
        return this.edit({ exemptChannels, reason });
      }
    };
    module2.exports = AutoModerationRule;
  }
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS({
  "node_modules/discord.js/src/structures/Integration.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var IntegrationApplication = require_IntegrationApplication();
    var Integration = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.id = data.id;
        this.name = data.name;
        this.type = data.type;
        this.enabled = data.enabled ?? null;
        if ("syncing" in data) {
          this.syncing = data.syncing;
        } else {
          this.syncing ?? (this.syncing = null);
        }
        this.role = this.guild.roles.resolve(data.role_id);
        if ("enable_emoticons" in data) {
          this.enableEmoticons = data.enable_emoticons;
        } else {
          this.enableEmoticons ?? (this.enableEmoticons = null);
        }
        if (data.user) {
          this.user = this.client.users._add(data.user);
        } else {
          this.user ?? (this.user = null);
        }
        this.account = data.account;
        if ("synced_at" in data) {
          this.syncedTimestamp = Date.parse(data.synced_at);
        } else {
          this.syncedTimestamp ?? (this.syncedTimestamp = null);
        }
        if ("subscriber_count" in data) {
          this.subscriberCount = data.subscriber_count;
        } else {
          this.subscriberCount ?? (this.subscriberCount = null);
        }
        if ("revoked" in data) {
          this.revoked = data.revoked;
        } else {
          this.revoked ?? (this.revoked = null);
        }
        this._patch(data);
      }
      /**
       * The date at which this integration was last synced at
       * @type {?Date}
       * @readonly
       */
      get syncedAt() {
        return this.syncedTimestamp && new Date(this.syncedTimestamp);
      }
      /**
       * All roles that are managed by this integration
       * @type {Collection<Snowflake, Role>}
       * @readonly
       */
      get roles() {
        const roles = this.guild.roles.cache;
        return roles.filter((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.integrationId) === this.id;
        });
      }
      _patch(data) {
        if ("expire_behavior" in data) {
          this.expireBehavior = data.expire_behavior;
        } else {
          this.expireBehavior ?? (this.expireBehavior = null);
        }
        if ("expire_grace_period" in data) {
          this.expireGracePeriod = data.expire_grace_period;
        } else {
          this.expireGracePeriod ?? (this.expireGracePeriod = null);
        }
        if ("application" in data) {
          if (this.application) {
            this.application._patch(data.application);
          } else {
            this.application = new IntegrationApplication(this.client, data.application);
          }
        } else {
          this.application ?? (this.application = null);
        }
        if ("scopes" in data) {
          this.scopes = data.scopes;
        } else {
          this.scopes ?? (this.scopes = []);
        }
      }
      /**
       * Deletes this integration.
       * @returns {Promise<Integration>}
       * @param {string} [reason] Reason for deleting this integration
       */
      async delete(reason) {
        await this.client.rest.delete(Routes2.guildIntegration(this.guild.id, this.id), { reason });
        return this;
      }
      toJSON() {
        return super.toJSON({
          role: "roleId",
          guild: "guildId",
          user: "userId"
        });
      }
    };
    module2.exports = Integration;
  }
});

// node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS({
  "node_modules/discord.js/src/structures/StageInstance.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var StageInstance = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this._patch(data);
      }
      _patch(data) {
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("privacy_level" in data) {
          this.privacyLevel = data.privacy_level;
        }
        if ("discoverable_disabled" in data) {
          this.discoverableDisabled = data.discoverable_disabled;
        } else {
          this.discoverableDisabled ?? (this.discoverableDisabled = null);
        }
        if ("guild_scheduled_event_id" in data) {
          this.guildScheduledEventId = data.guild_scheduled_event_id;
        } else {
          this.guildScheduledEventId ?? (this.guildScheduledEventId = null);
        }
      }
      /**
       * The stage channel associated with this stage instance
       * @type {?StageChannel}
       * @readonly
       */
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      /**
       * The guild this stage instance belongs to
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      /**
       * The associated guild scheduled event of this stage instance
       * @type {?GuildScheduledEvent}
       * @readonly
       */
      get guildScheduledEvent() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.scheduledEvents.resolve(this.guildScheduledEventId)) ?? null;
      }
      /**
       * Edits this stage instance.
       * @param {StageInstanceEditOptions} options The options to edit the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Edit a stage instance
       * stageInstance.edit({ topic: 'new topic' })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error)
       */
      edit(options) {
        return this.guild.stageInstances.edit(this.channelId, options);
      }
      /**
       * Deletes this stage instance.
       * @returns {Promise<StageInstance>}
       * @example
       * // Delete a stage instance
       * stageInstance.delete()
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async delete() {
        await this.guild.stageInstances.delete(this.channelId);
        const clone = this._clone();
        return clone;
      }
      /**
       * Sets the topic of this stage instance.
       * @param {string} topic The topic for the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Set topic of a stage instance
       * stageInstance.setTopic('new topic')
       *  .then(stageInstance => console.log(`Set the topic to: ${stageInstance.topic}`))
       *  .catch(console.error);
       */
      setTopic(topic) {
        return this.guild.stageInstances.edit(this.channelId, { topic });
      }
      /**
       * The timestamp this stage instances was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this stage instance was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
    };
    exports2.StageInstance = StageInstance;
  }
});

// node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS({
  "node_modules/discord.js/src/structures/GuildAuditLogsEntry.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { AuditLogOptionsType, AuditLogEvent } = require_v106();
    var AutoModerationRule = require_AutoModerationRule();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var Integration = require_Integration();
    var Invite2 = require_Invite();
    var { StageInstance } = require_StageInstance();
    var { Sticker: Sticker2 } = require_Sticker();
    var Webhook2 = require_Webhook();
    var Partials = require_Partials();
    var { flatten } = require_Util();
    var Targets = {
      All: "All",
      Guild: "Guild",
      GuildScheduledEvent: "GuildScheduledEvent",
      Channel: "Channel",
      User: "User",
      Role: "Role",
      Invite: "Invite",
      Webhook: "Webhook",
      Emoji: "Emoji",
      Message: "Message",
      Integration: "Integration",
      StageInstance: "StageInstance",
      Sticker: "Sticker",
      Thread: "Thread",
      ApplicationCommand: "ApplicationCommand",
      AutoModeration: "AutoModeration",
      Unknown: "Unknown"
    };
    function changesReduce(changes, initialData = {}) {
      return changes.reduce((accumulator, change) => {
        accumulator[change.key] = change.new ?? change.old;
        return accumulator;
      }, initialData);
    }
    var _GuildAuditLogsEntry = class _GuildAuditLogsEntry {
      constructor(guild, data, logs) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.targetType = _GuildAuditLogsEntry.targetType(data.action_type);
        const targetType = this.targetType;
        this.actionType = _GuildAuditLogsEntry.actionType(data.action_type);
        this.action = data.action_type;
        this.reason = data.reason ?? null;
        this.executorId = data.user_id;
        this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
        this.changes = ((_a = data.changes) == null ? void 0 : _a.map((change) => ({ key: change.key, old: change.old_value, new: change.new_value }))) ?? [];
        this.id = data.id;
        this.extra = null;
        switch (data.action_type) {
          case AuditLogEvent.MemberPrune:
            this.extra = {
              removed: Number(data.options.members_removed),
              days: Number(data.options.delete_member_days)
            };
            break;
          case AuditLogEvent.MemberMove:
          case AuditLogEvent.MessageDelete:
          case AuditLogEvent.MessageBulkDelete:
            this.extra = {
              channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              count: Number(data.options.count)
            };
            break;
          case AuditLogEvent.MessagePin:
          case AuditLogEvent.MessageUnpin:
            this.extra = {
              channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              messageId: data.options.message_id
            };
            break;
          case AuditLogEvent.MemberDisconnect:
            this.extra = {
              count: Number(data.options.count)
            };
            break;
          case AuditLogEvent.ChannelOverwriteCreate:
          case AuditLogEvent.ChannelOverwriteUpdate:
          case AuditLogEvent.ChannelOverwriteDelete:
            switch (data.options.type) {
              case AuditLogOptionsType.Role:
                this.extra = guild.roles.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  name: data.options.role_name,
                  type: AuditLogOptionsType.Role
                };
                break;
              case AuditLogOptionsType.Member:
                this.extra = guild.members.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  type: AuditLogOptionsType.Member
                };
                break;
              default:
                break;
            }
            break;
          case AuditLogEvent.StageInstanceCreate:
          case AuditLogEvent.StageInstanceDelete:
          case AuditLogEvent.StageInstanceUpdate:
            this.extra = {
              channel: guild.client.channels.cache.get((_b = data.options) == null ? void 0 : _b.channel_id) ?? { id: (_c = data.options) == null ? void 0 : _c.channel_id }
            };
            break;
          case AuditLogEvent.ApplicationCommandPermissionUpdate:
            this.extra = {
              applicationId: data.options.application_id
            };
            break;
          case AuditLogEvent.AutoModerationBlockMessage:
          case AuditLogEvent.AutoModerationFlagToChannel:
          case AuditLogEvent.AutoModerationUserCommunicationDisabled:
            this.extra = {
              autoModerationRuleName: data.options.auto_moderation_rule_name,
              autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type,
              channel: guild.client.channels.cache.get((_d = data.options) == null ? void 0 : _d.channel_id) ?? { id: (_e = data.options) == null ? void 0 : _e.channel_id }
            };
            break;
          case AuditLogEvent.MemberKick:
          case AuditLogEvent.MemberRoleUpdate: {
            if (data.integration_type) {
              this.extra = {
                integrationType: data.integration_type
              };
            }
            break;
          }
          default:
            break;
        }
        this.targetId = data.target_id;
        this.target = null;
        if (targetType === Targets.Unknown) {
          this.target = changesReduce(this.changes);
          this.target.id = data.target_id;
        } else if (targetType === Targets.User && data.target_id) {
          this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
        } else if (targetType === Targets.Guild) {
          this.target = guild.client.guilds.cache.get(data.target_id);
        } else if (targetType === Targets.Webhook) {
          this.target = (logs == null ? void 0 : logs.webhooks.get(data.target_id)) ?? new Webhook2(
            guild.client,
            changesReduce(this.changes, {
              id: data.target_id,
              guild_id: guild.id
            })
          );
        } else if (targetType === Targets.Invite) {
          const inviteChange = this.changes.find(({ key }) => key === "code");
          this.target = guild.invites.cache.get(inviteChange.new ?? inviteChange.old) ?? new Invite2(guild.client, changesReduce(this.changes, { guild }));
        } else if (targetType === Targets.Message) {
          this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
        } else if (targetType === Targets.Integration) {
          this.target = (logs == null ? void 0 : logs.integrations.get(data.target_id)) ?? new Integration(guild.client, changesReduce(this.changes, { id: data.target_id }), guild);
        } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
          this.target = guild.channels.cache.get(data.target_id) ?? changesReduce(this.changes, { id: data.target_id });
        } else if (targetType === Targets.StageInstance) {
          this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(
            guild.client,
            changesReduce(this.changes, {
              id: data.target_id,
              channel_id: (_f = data.options) == null ? void 0 : _f.channel_id,
              guild_id: guild.id
            })
          );
        } else if (targetType === Targets.Sticker) {
          this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker2(guild.client, changesReduce(this.changes, { id: data.target_id }));
        } else if (targetType === Targets.GuildScheduledEvent) {
          this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }));
        } else if (targetType === Targets.ApplicationCommand) {
          this.target = (logs == null ? void 0 : logs.applicationCommands.get(data.target_id)) ?? { id: data.target_id };
        } else if (targetType === Targets.AutoModeration) {
          this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(
            guild.client,
            changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }),
            guild
          );
        } else if (data.target_id) {
          this.target = ((_g = guild[`${targetType.toLowerCase()}s`]) == null ? void 0 : _g.cache.get(data.target_id)) ?? { id: data.target_id };
        }
      }
      /**
       * Finds the target type of a guild audit log entry.
       * @param {AuditLogEvent} target The action target
       * @returns {AuditLogTargetType}
       */
      static targetType(target) {
        if (target < 10)
          return Targets.Guild;
        if (target < 20)
          return Targets.Channel;
        if (target < 30)
          return Targets.User;
        if (target < 40)
          return Targets.Role;
        if (target < 50)
          return Targets.Invite;
        if (target < 60)
          return Targets.Webhook;
        if (target < 70)
          return Targets.Emoji;
        if (target < 80)
          return Targets.Message;
        if (target < 83)
          return Targets.Integration;
        if (target < 86)
          return Targets.StageInstance;
        if (target < 100)
          return Targets.Sticker;
        if (target < 110)
          return Targets.GuildScheduledEvent;
        if (target < 120)
          return Targets.Thread;
        if (target < 130)
          return Targets.ApplicationCommand;
        if (target >= 140 && target < 150)
          return Targets.AutoModeration;
        return Targets.Unknown;
      }
      /**
       * Finds the action type from the guild audit log entry action.
       * @param {AuditLogEvent} action The action target
       * @returns {AuditLogActionType}
       */
      static actionType(action) {
        if ([
          AuditLogEvent.ChannelCreate,
          AuditLogEvent.ChannelOverwriteCreate,
          AuditLogEvent.MemberBanRemove,
          AuditLogEvent.BotAdd,
          AuditLogEvent.RoleCreate,
          AuditLogEvent.InviteCreate,
          AuditLogEvent.WebhookCreate,
          AuditLogEvent.EmojiCreate,
          AuditLogEvent.MessagePin,
          AuditLogEvent.IntegrationCreate,
          AuditLogEvent.StageInstanceCreate,
          AuditLogEvent.StickerCreate,
          AuditLogEvent.GuildScheduledEventCreate,
          AuditLogEvent.ThreadCreate,
          AuditLogEvent.AutoModerationRuleCreate,
          AuditLogEvent.AutoModerationBlockMessage
        ].includes(action)) {
          return "Create";
        }
        if ([
          AuditLogEvent.ChannelDelete,
          AuditLogEvent.ChannelOverwriteDelete,
          AuditLogEvent.MemberKick,
          AuditLogEvent.MemberPrune,
          AuditLogEvent.MemberBanAdd,
          AuditLogEvent.MemberDisconnect,
          AuditLogEvent.RoleDelete,
          AuditLogEvent.InviteDelete,
          AuditLogEvent.WebhookDelete,
          AuditLogEvent.EmojiDelete,
          AuditLogEvent.MessageDelete,
          AuditLogEvent.MessageBulkDelete,
          AuditLogEvent.MessageUnpin,
          AuditLogEvent.IntegrationDelete,
          AuditLogEvent.StageInstanceDelete,
          AuditLogEvent.StickerDelete,
          AuditLogEvent.GuildScheduledEventDelete,
          AuditLogEvent.ThreadDelete,
          AuditLogEvent.AutoModerationRuleDelete
        ].includes(action)) {
          return "Delete";
        }
        if ([
          AuditLogEvent.GuildUpdate,
          AuditLogEvent.ChannelUpdate,
          AuditLogEvent.ChannelOverwriteUpdate,
          AuditLogEvent.MemberUpdate,
          AuditLogEvent.MemberRoleUpdate,
          AuditLogEvent.MemberMove,
          AuditLogEvent.RoleUpdate,
          AuditLogEvent.InviteUpdate,
          AuditLogEvent.WebhookUpdate,
          AuditLogEvent.EmojiUpdate,
          AuditLogEvent.IntegrationUpdate,
          AuditLogEvent.StageInstanceUpdate,
          AuditLogEvent.StickerUpdate,
          AuditLogEvent.GuildScheduledEventUpdate,
          AuditLogEvent.ThreadUpdate,
          AuditLogEvent.ApplicationCommandPermissionUpdate,
          AuditLogEvent.AutoModerationRuleUpdate
        ].includes(action)) {
          return "Update";
        }
        return "All";
      }
      /**
       * The timestamp this entry was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this entry was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      toJSON() {
        return flatten(this, { createdTimestamp: true });
      }
    };
    /**
     * Key mirror of all available audit log targets.
     * @type {Object<string, string>}
     * @memberof GuildAuditLogsEntry
     */
    __publicField(_GuildAuditLogsEntry, "Targets", Targets);
    var GuildAuditLogsEntry = _GuildAuditLogsEntry;
    module2.exports = GuildAuditLogsEntry;
  }
});

// node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    var Events2 = require_Events();
    var GuildAuditLogEntryCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let auditLogEntry;
        if (guild) {
          auditLogEntry = new GuildAuditLogsEntry(guild, data);
          client.emit(Events2.GuildAuditLogEntryCreate, auditLogEntry, guild);
        }
        return { auditLogEntry };
      }
    };
    module2.exports = GuildAuditLogEntryCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildBanAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildBanAdd = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild)
          client.emit(Events2.GuildBanAdd, guild.bans._add(data));
      }
    };
    module2.exports = GuildBanAdd;
  }
});

// node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS({
  "node_modules/discord.js/src/structures/GuildBan.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var GuildBan = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("reason" in data) {
          this.reason = data.reason;
        }
      }
      /**
       * Whether this GuildBan is partial. If the reason is not provided the value is null
       * @type {boolean}
       * @readonly
       */
      get partial() {
        return !("reason" in this);
      }
      /**
       * Fetches this GuildBan.
       * @param {boolean} [force=true] Whether to skip the cache check and request the API
       * @returns {Promise<GuildBan>}
       */
      fetch(force = true) {
        return this.guild.bans.fetch({ user: this.user, cache: true, force });
      }
    };
    module2.exports = GuildBan;
  }
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildBanRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildBan = require_GuildBan();
    var Events2 = require_Events();
    var GuildBanRemove = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
          guild.bans.cache.delete(ban.user.id);
          client.emit(Events2.GuildBanRemove, ban);
        }
      }
    };
    module2.exports = GuildBanRemove;
  }
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildChannelsPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialChannel of data.channels) {
            const channel = guild.channels.cache.get(partialChannel.id);
            if (channel)
              channel.rawPosition = partialChannel.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildChannelsPositionUpdate;
  }
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildDeleteAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        let guild = client.guilds.cache.get(data.id);
        if (guild) {
          if (data.unavailable) {
            guild.available = false;
            client.emit(Events2.GuildUnavailable, guild);
            return;
          }
          for (const channel of guild.channels.cache.values())
            this.client.channels._remove(channel.id);
          (_a = client.voice.adapters.get(data.id)) == null ? void 0 : _a.destroy();
          client.guilds.cache.delete(guild.id);
          client.emit(Events2.GuildDelete, guild);
        }
      }
    };
    module2.exports = GuildDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojiCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildEmojiCreateAction = class extends Action {
      handle(guild, createdEmoji) {
        const already = guild.emojis.cache.has(createdEmoji.id);
        const emoji = guild.emojis._add(createdEmoji);
        if (!already)
          this.client.emit(Events2.GuildEmojiCreate, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojiDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildEmojiDeleteAction = class extends Action {
      handle(emoji) {
        emoji.guild.emojis.cache.delete(emoji.id);
        this.client.emit(Events2.GuildEmojiDelete, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildEmojiUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events2.GuildEmojiUpdate, old, current);
        return { emoji: current };
      }
    };
    module2.exports = GuildEmojiUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildEmojisUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!(guild == null ? void 0 : guild.emojis))
          return;
        const deletions = new Map(guild.emojis.cache);
        for (const emoji of data.emojis) {
          const cachedEmoji = guild.emojis.cache.get(emoji.id);
          if (cachedEmoji) {
            deletions.delete(emoji.id);
            if (!cachedEmoji.equals(emoji)) {
              this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
            }
          } else {
            this.client.actions.GuildEmojiCreate.handle(guild, emoji);
          }
        }
        for (const emoji of deletions.values()) {
          this.client.actions.GuildEmojiDelete.handle(emoji);
        }
      }
    };
    module2.exports = GuildEmojisUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildIntegrationsUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild)
          client.emit(Events2.GuildIntegrationsUpdate, guild);
      }
    };
    module2.exports = GuildIntegrationsUpdate;
  }
});

// node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS({
  "node_modules/discord.js/src/util/Status.js"(exports2, module2) {
    "use strict";
    var { createEnum } = require_Enums();
    module2.exports = createEnum([
      "Ready",
      "Connecting",
      "Reconnecting",
      "Idle",
      "Nearly",
      "Disconnected",
      "WaitingForGuilds",
      "Identifying",
      "Resuming"
    ]);
  }
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildMemberRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var Status2 = require_Status();
    var GuildMemberRemoveAction = class extends Action {
      handle(data, shard) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let member = null;
        if (guild) {
          member = this.getMember({ user: data.user }, guild);
          guild.memberCount--;
          if (member) {
            guild.members.cache.delete(member.id);
            if (shard.status === Status2.Ready)
              client.emit(Events2.GuildMemberRemove, member);
          }
          guild.presences.cache.delete(data.user.id);
          guild.voiceStates.cache.delete(data.user.id);
        }
        return { guild, member };
      }
    };
    module2.exports = GuildMemberRemoveAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var Status2 = require_Status();
    var GuildMemberUpdateAction = class extends Action {
      handle(data, shard) {
        const { client } = this;
        if (data.user.username) {
          const user = client.users.cache.get(data.user.id);
          if (!user) {
            client.users._add(data.user);
          } else if (!user._equals(data.user)) {
            client.actions.UserUpdate.handle(data.user);
          }
        }
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const member = this.getMember({ user: data.user }, guild);
          if (member) {
            const old = member._update(data);
            if (shard.status === Status2.Ready && !member.equals(old))
              client.emit(Events2.GuildMemberUpdate, old, member);
          } else {
            const newMember = guild.members._add(data);
            this.client.emit(Events2.GuildMemberAvailable, newMember);
          }
        }
      }
    };
    module2.exports = GuildMemberUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRoleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildRoleCreate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          const already = guild.roles.cache.has(data.role.id);
          role = guild.roles._add(data.role);
          if (!already)
            client.emit(Events2.GuildRoleCreate, role);
        }
        return { role };
      }
    };
    module2.exports = GuildRoleCreate;
  }
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRoleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildRoleDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          role = guild.roles.cache.get(data.role_id);
          if (role) {
            guild.roles.cache.delete(data.role_id);
            client.emit(Events2.GuildRoleDelete, role);
          }
        }
        return { role };
      }
    };
    module2.exports = GuildRoleDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRoleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildRoleUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          let old = null;
          const role = guild.roles.cache.get(data.role.id);
          if (role) {
            old = role._update(data.role);
            client.emit(Events2.GuildRoleUpdate, old, role);
          }
          return {
            old,
            updated: role
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildRoleUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildRolesPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialRole of data.roles) {
            const role = guild.roles.cache.get(partialRole.id);
            if (role)
              role.rawPosition = partialRole.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildRolesPositionUpdate;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildScheduledEventCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events2.GuildScheduledEventCreate, guildScheduledEvent);
          return { guildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildScheduledEventDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          if (guildScheduledEvent) {
            guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
            client.emit(Events2.GuildScheduledEventDelete, guildScheduledEvent);
            return { guildScheduledEvent };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildScheduledEventUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldGuildScheduledEvent = ((_a = guild.scheduledEvents.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newGuildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events2.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
          return { oldGuildScheduledEvent, newGuildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildScheduledEventUserAddAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events2.GuildScheduledEventUserAdd, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserAddAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildScheduledEventUserRemoveAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events2.GuildScheduledEventUserRemove, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserRemoveAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickerCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildStickerCreateAction = class extends Action {
      handle(guild, createdSticker) {
        const already = guild.stickers.cache.has(createdSticker.id);
        const sticker = guild.stickers._add(createdSticker);
        if (!already)
          this.client.emit(Events2.GuildStickerCreate, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickerDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildStickerDeleteAction = class extends Action {
      handle(sticker) {
        sticker.guild.stickers.cache.delete(sticker.id);
        this.client.emit(Events2.GuildStickerDelete, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickerUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildStickerUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events2.GuildStickerUpdate, old, current);
        return { sticker: current };
      }
    };
    module2.exports = GuildStickerUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildStickersUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildStickersUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!(guild == null ? void 0 : guild.stickers))
          return;
        const deletions = new Map(guild.stickers.cache);
        for (const sticker of data.stickers) {
          const cachedSticker = guild.stickers.cache.get(sticker.id);
          if (cachedSticker) {
            deletions.delete(sticker.id);
            if (!cachedSticker.equals(sticker)) {
              this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
            }
          } else {
            this.client.actions.GuildStickerCreate.handle(guild, sticker);
          }
        }
        for (const sticker of deletions.values()) {
          this.client.actions.GuildStickerDelete.handle(sticker);
        }
      }
    };
    module2.exports = GuildStickersUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/GuildUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var GuildUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.id);
        if (guild) {
          const old = guild._update(data);
          client.emit(Events2.GuildUpdate, old, guild);
          return {
            old,
            updated: guild
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildUpdateAction;
  }
});

// node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS({
  "node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js"(exports2, module2) {
    "use strict";
    var { ApplicationCommandOptionType } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var CommandInteractionOptionResolver = class {
      constructor(client, options, resolved) {
        var _a, _b;
        Object.defineProperty(this, "client", { value: client });
        this._group = null;
        this._subcommand = null;
        this._hoistedOptions = options;
        if (((_a = this._hoistedOptions[0]) == null ? void 0 : _a.type) === ApplicationCommandOptionType.SubcommandGroup) {
          this._group = this._hoistedOptions[0].name;
          this._hoistedOptions = this._hoistedOptions[0].options ?? [];
        }
        if (((_b = this._hoistedOptions[0]) == null ? void 0 : _b.type) === ApplicationCommandOptionType.Subcommand) {
          this._subcommand = this._hoistedOptions[0].name;
          this._hoistedOptions = this._hoistedOptions[0].options ?? [];
        }
        Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
        Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
      }
      /**
       * Gets an option by its name.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?CommandInteractionOption} The option, if found.
       */
      get(name, required = false) {
        const option = this._hoistedOptions.find((opt) => opt.name === name);
        if (!option) {
          if (required) {
            throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNotFound, name);
          }
          return null;
        }
        return option;
      }
      /**
       * Gets an option by name and property and checks its type.
       * @param {string} name The name of the option.
       * @param {ApplicationCommandOptionType[]} allowedTypes The allowed types of the option.
       * @param {string[]} properties The properties to check for for `required`.
       * @param {boolean} required Whether to throw an error if the option is not found.
       * @returns {?CommandInteractionOption} The option, if found.
       * @private
       */
      _getTypedOption(name, allowedTypes, properties, required) {
        const option = this.get(name, required);
        if (!option) {
          return null;
        } else if (!allowedTypes.includes(option.type)) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
        } else if (required && properties.every((prop) => option[prop] === null || option[prop] === void 0)) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionEmpty, name, option.type);
        }
        return option;
      }
      /**
       * Gets the selected subcommand.
       * @param {boolean} [required=true] Whether to throw an error if there is no subcommand.
       * @returns {?string} The name of the selected subcommand, or null if not set and not required.
       */
      getSubcommand(required = true) {
        if (required && !this._subcommand) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNoSubcommand);
        }
        return this._subcommand;
      }
      /**
       * Gets the selected subcommand group.
       * @param {boolean} [required=false] Whether to throw an error if there is no subcommand group.
       * @returns {?string} The name of the selected subcommand group, or null if not set and not required.
       */
      getSubcommandGroup(required = false) {
        if (required && !this._group) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNoSubcommandGroup);
        }
        return this._group;
      }
      /**
       * Gets a boolean option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?boolean} The value of the option, or null if not set and not required.
       */
      getBoolean(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      /**
       * Gets a channel option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @param {ChannelType[]} [channelTypes=[]] The allowed types of channels. If empty, all channel types are allowed.
       * @returns {?(GuildChannel|ThreadChannel|APIChannel)}
       * The value of the option, or null if not set and not required.
       */
      getChannel(name, required = false, channelTypes = []) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
        const channel = (option == null ? void 0 : option.channel) ?? null;
        if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.CommandInteractionOptionInvalidChannelType,
            name,
            channel.type,
            channelTypes.join(", ")
          );
        }
        return channel;
      }
      /**
       * Gets a string option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?string} The value of the option, or null if not set and not required.
       */
      getString(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      /**
       * Gets an integer option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?number} The value of the option, or null if not set and not required.
       */
      getInteger(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      /**
       * Gets a number option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?number} The value of the option, or null if not set and not required.
       */
      getNumber(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      /**
       * Gets a user option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?User} The value of the option, or null if not set and not required.
       */
      getUser(name, required = false) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable],
          ["user"],
          required
        );
        return (option == null ? void 0 : option.user) ?? null;
      }
      /**
       * Gets a member option.
       * @param {string} name The name of the option.
       * @returns {?(GuildMember|APIGuildMember)}
       * The value of the option, or null if the user is not present in the guild or the option is not set.
       */
      getMember(name) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable],
          ["member"],
          false
        );
        return (option == null ? void 0 : option.member) ?? null;
      }
      /**
       * Gets a role option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?(Role|APIRole)} The value of the option, or null if not set and not required.
       */
      getRole(name, required = false) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable],
          ["role"],
          required
        );
        return (option == null ? void 0 : option.role) ?? null;
      }
      /**
       * Gets an attachment option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?Attachment} The value of the option, or null if not set and not required.
       */
      getAttachment(name, required = false) {
        const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
        return (option == null ? void 0 : option.attachment) ?? null;
      }
      /**
       * Gets a mentionable option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?(User|GuildMember|APIGuildMember|Role|APIRole)}
       * The value of the option, or null if not set and not required.
       */
      getMentionable(name, required = false) {
        const option = this._getTypedOption(
          name,
          [ApplicationCommandOptionType.Mentionable],
          ["user", "member", "role"],
          required
        );
        return (option == null ? void 0 : option.member) ?? (option == null ? void 0 : option.user) ?? (option == null ? void 0 : option.role) ?? null;
      }
      /**
       * Gets a message option.
       * @param {string} name The name of the option.
       * @param {boolean} [required=false] Whether to throw an error if the option is not found.
       * @returns {?Message}
       * The value of the option, or null if not set and not required.
       */
      getMessage(name, required = false) {
        const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
        return (option == null ? void 0 : option.message) ?? null;
      }
      /**
       * The full autocomplete option object.
       * @typedef {Object} AutocompleteFocusedOption
       * @property {string} name The name of the option
       * @property {ApplicationCommandOptionType} type The type of the application command option
       * @property {string} value The value of the option
       * @property {boolean} focused Whether this option is currently in focus for autocomplete
       */
      /**
       * Gets the focused option.
       * @param {boolean} [getFull=false] Whether to get the full option object
       * @returns {string|AutocompleteFocusedOption}
       * The value of the option, or the whole option if getFull is true
       */
      getFocused(getFull = false) {
        const focusedOption = this._hoistedOptions.find((option) => option.focused);
        if (!focusedOption)
          throw new DiscordjsTypeError2(ErrorCodes2.AutocompleteInteractionOptionNoFocusedOption);
        return getFull ? focusedOption : focusedOption.value;
      }
    };
    module2.exports = CommandInteractionOptionResolver;
  }
});

// node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS({
  "node_modules/discord.js/src/structures/AutocompleteInteraction.js"(exports2, module2) {
    "use strict";
    var { InteractionResponseType, Routes: Routes2 } = require_v106();
    var BaseInteraction = require_BaseInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var AutocompleteInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.commandId = data.data.id;
        this.commandName = data.data.name;
        this.commandType = data.data.type;
        this.commandGuildId = data.data.guild_id ?? null;
        this.responded = false;
        this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
      }
      /**
       * The invoked application command, if it was fetched before
       * @type {?ApplicationCommand}
       */
      get command() {
        var _a;
        const id = this.commandId;
        return ((_a = this.guild) == null ? void 0 : _a.commands.cache.get(id)) ?? this.client.application.commands.cache.get(id) ?? null;
      }
      /**
       * Sends results for the autocomplete of this interaction.
       * @param {ApplicationCommandOptionChoiceData[]} options The options for the autocomplete
       * @returns {Promise<void>}
       * @example
       * // respond to autocomplete interaction
       * interaction.respond([
       *  {
       *    name: 'Option 1',
       *    value: 'option1',
       *  },
       * ])
       *  .then(() => console.log('Successfully responded to the autocomplete interaction'))
       *  .catch(console.error);
       */
      async respond(options) {
        if (this.responded)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.ApplicationCommandAutocompleteResult,
            data: {
              choices: options.map(({ nameLocalizations, ...option }) => ({
                ...this.client.options.jsonTransformer(option),
                name_localizations: nameLocalizations
              }))
            }
          },
          auth: false
        });
        this.responded = true;
      }
    };
    module2.exports = AutocompleteInteraction;
  }
});

// node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS({
  "node_modules/discord.js/src/structures/InteractionResponse.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType } = require_v106();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var InteractionResponse = class {
      constructor(interaction, id) {
        this.interaction = interaction;
        this.id = id ?? interaction.id;
        this.client = interaction.client;
      }
      /**
       * The timestamp the interaction response was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the interaction response was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * Collects a single component interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitMessageComponentOptions} [options={}] Options to pass to the internal collector
       * @returns {Promise<MessageComponentInteraction>}
       */
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      /**
       * Creates a message component interaction collector
       * @param {MessageComponentCollectorOptions} [options={}] Options to send to the collector
       * @returns {InteractionCollector}
       */
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionResponse: this,
          interactionType: InteractionType.MessageComponent
        });
      }
      /**
       * Fetches the response as a {@link Message} object.
       * @returns {Promise<Message>}
       */
      fetch() {
        return this.interaction.fetchReply();
      }
      /**
       * Deletes the response.
       * @returns {Promise<void>}
       */
      delete() {
        return this.interaction.deleteReply();
      }
      /**
       * Edits the response.
       * @param {string|MessagePayload|WebhookMessageEditOptions} options The new options for the response.
       * @returns {Promise<Message>}
       */
      edit(options) {
        return this.interaction.editReply(options);
      }
    };
    var InteractionCollector = require_InteractionCollector();
    module2.exports = InteractionResponse;
  }
});

// node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS({
  "node_modules/discord.js/src/structures/interfaces/InteractionResponses.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist();
    var { InteractionResponseType, MessageFlags, Routes: Routes2, InteractionType } = require_v106();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var InteractionCollector = require_InteractionCollector();
    var InteractionResponse = require_InteractionResponse();
    var MessagePayload = require_MessagePayload();
    var InteractionResponses = class _InteractionResponses {
      /**
       * Options for deferring the reply to an {@link BaseInteraction}.
       * @typedef {Object} InteractionDeferReplyOptions
       * @property {boolean} [ephemeral] Whether the reply should be ephemeral
       * @property {boolean} [fetchReply] Whether to fetch the reply
       */
      /**
       * Options for deferring and updating the reply to a {@link MessageComponentInteraction}.
       * @typedef {Object} InteractionDeferUpdateOptions
       * @property {boolean} [fetchReply] Whether to fetch the reply
       */
      /**
       * Options for a reply to a {@link BaseInteraction}.
       * @typedef {BaseMessageOptions} InteractionReplyOptions
       * @property {boolean} [tts=false] Whether the message should be spoken aloud
       * @property {boolean} [ephemeral] Whether the reply should be ephemeral
       * @property {boolean} [fetchReply] Whether to fetch the reply
       * @property {MessageFlags} [flags] Which flags to set for the message.
       * <info>Only `MessageFlags.SuppressEmbeds` and `MessageFlags.Ephemeral` can be set.</info>
       */
      /**
       * Options for updating the message received from a {@link MessageComponentInteraction}.
       * @typedef {MessageEditOptions} InteractionUpdateOptions
       * @property {boolean} [fetchReply] Whether to fetch the reply
       */
      /**
       * Defers the reply to this interaction.
       * @param {InteractionDeferReplyOptions} [options] Options for deferring the reply to this interaction
       * @returns {Promise<Message|InteractionResponse>}
       * @example
       * // Defer the reply to this interaction
       * interaction.deferReply()
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Defer to send an ephemeral reply later
       * interaction.deferReply({ ephemeral: true })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async deferReply(options = {}) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        this.ephemeral = options.ephemeral ?? false;
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.DeferredChannelMessageWithSource,
            data: {
              flags: options.ephemeral ? MessageFlags.Ephemeral : void 0
            }
          },
          auth: false
        });
        this.deferred = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
      }
      /**
       * Creates a reply to this interaction.
       * <info>Use the `fetchReply` option to get the bot's reply message.</info>
       * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply
       * @returns {Promise<Message|InteractionResponse>}
       * @example
       * // Reply to the interaction and fetch the response
       * interaction.reply({ content: 'Pong!', fetchReply: true })
       *   .then((message) => console.log(`Reply sent with content ${message.content}`))
       *   .catch(console.error);
       * @example
       * // Create an ephemeral reply with an embed
       * const embed = new EmbedBuilder().setDescription('Pong!');
       *
       * interaction.reply({ embeds: [embed], ephemeral: true })
       *   .then(() => console.log('Reply sent.'))
       *   .catch(console.error);
       */
      async reply(options) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        this.ephemeral = options.ephemeral ?? false;
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.ChannelMessageWithSource,
            data
          },
          files,
          auth: false
        });
        this.replied = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
      }
      /**
       * Fetches a reply to this interaction.
       * @see Webhook#fetchMessage
       * @param {Snowflake|'@original'} [message='@original'] The response to fetch
       * @returns {Promise<Message>}
       * @example
       * // Fetch the initial reply to this interaction
       * interaction.fetchReply()
       *   .then(reply => console.log(`Replied with ${reply.content}`))
       *   .catch(console.error);
       */
      fetchReply(message = "@original") {
        return this.webhook.fetchMessage(message);
      }
      /**
       * Options that can be passed into {@link InteractionResponses#editReply}.
       * @typedef {WebhookMessageEditOptions} InteractionEditReplyOptions
       * @property {MessageResolvable|'@original'} [message='@original'] The response to edit
       */
      /**
       * Edits a reply to this interaction.
       * @see Webhook#editMessage
       * @param {string|MessagePayload|InteractionEditReplyOptions} options The new options for the message
       * @returns {Promise<Message>}
       * @example
       * // Edit the initial reply to this interaction
       * interaction.editReply('New content')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async editReply(options) {
        if (!this.deferred && !this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionNotReplied);
        const msg = await this.webhook.editMessage(options.message ?? "@original", options);
        this.replied = true;
        return msg;
      }
      /**
       * Deletes a reply to this interaction.
       * @see Webhook#deleteMessage
       * @param {MessageResolvable|'@original'} [message='@original'] The response to delete
       * @returns {Promise<void>}
       * @example
       * // Delete the initial reply to this interaction
       * interaction.deleteReply()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async deleteReply(message = "@original") {
        await this.webhook.deleteMessage(message);
      }
      /**
       * Send a follow-up message to this interaction.
       * @param {string|MessagePayload|InteractionReplyOptions} options The options for the reply
       * @returns {Promise<Message>}
       */
      followUp(options) {
        if (!this.deferred && !this.replied)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.InteractionNotReplied));
        return this.webhook.send(options);
      }
      /**
       * Defers an update to the message to which the component was attached.
       * @param {InteractionDeferUpdateOptions} [options] Options for deferring the update to this interaction
       * @returns {Promise<Message|InteractionResponse>}
       * @example
       * // Defer updating and reset the component's loading state
       * interaction.deferUpdate()
       *   .then(console.log)
       *   .catch(console.error);
       */
      async deferUpdate(options = {}) {
        var _a, _b;
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.DeferredMessageUpdate
          },
          auth: false
        });
        this.deferred = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, (_b = (_a = this.message) == null ? void 0 : _a.interaction) == null ? void 0 : _b.id);
      }
      /**
       * Updates the original message of the component on which the interaction was received on.
       * @param {string|MessagePayload|InteractionUpdateOptions} options The options for the updated message
       * @returns {Promise<Message|void>}
       * @example
       * // Remove the components from the message
       * interaction.update({
       *   content: "A component interaction was received",
       *   components: []
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async update(options) {
        var _a;
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.UpdateMessage,
            data
          },
          files,
          auth: false
        });
        this.replied = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, (_a = this.message.interaction) == null ? void 0 : _a.id);
      }
      /**
       * Shows a modal component
       * @param {ModalBuilder|ModalComponentData|APIModalInteractionResponseCallbackData} modal The modal to show
       * @returns {Promise<void>}
       */
      async showModal(modal) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes2.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.Modal,
            data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
          },
          auth: false
        });
        this.replied = true;
      }
      /**
       * An object containing the same properties as {@link CollectorOptions}, but a few less:
       * @typedef {Object} AwaitModalSubmitOptions
       * @property {CollectorFilter} [filter] The filter applied to this collector
       * @property {number} time Time in milliseconds to wait for an interaction before rejecting
       */
      /**
       * Collects a single modal submit interaction that passes the filter.
       * The Promise will reject if the time expires.
       * @param {AwaitModalSubmitOptions} options Options to pass to the internal collector
       * @returns {Promise<ModalSubmitInteraction>}
       * @example
       * // Collect a modal submit interaction
       * const filter = (interaction) => interaction.customId === 'modal';
       * interaction.awaitModalSubmit({ filter, time: 15_000 })
       *   .then(interaction => console.log(`${interaction.customId} was submitted!`))
       *   .catch(console.error);
       */
      awaitModalSubmit(options) {
        if (typeof options.time !== "number")
          throw new DiscordjsError2(ErrorCodes2.InvalidType, "time", "number");
        const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
        return new Promise((resolve, reject) => {
          const collector = new InteractionCollector(this.client, _options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      static applyToClass(structure, ignore = []) {
        const props = [
          "deferReply",
          "reply",
          "fetchReply",
          "editReply",
          "deleteReply",
          "followUp",
          "deferUpdate",
          "update",
          "showModal",
          "awaitModalSubmit"
        ];
        for (const prop of props) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(_InteractionResponses.prototype, prop)
          );
        }
      }
    };
    module2.exports = InteractionResponses;
  }
});

// node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS({
  "node_modules/discord.js/src/structures/MessageComponentInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var InteractionResponses = require_InteractionResponses();
    var getMessage = lazy(() => require_Message().Message);
    var MessageComponentInteraction = class extends BaseInteraction {
      constructor(client, data) {
        var _a;
        super(client, data);
        this.message = ((_a = this.channel) == null ? void 0 : _a.messages._add(data.message)) ?? new (getMessage())(client, data.message);
        this.customId = data.data.custom_id;
        this.componentType = data.data.component_type;
        this.deferred = false;
        this.ephemeral = null;
        this.replied = false;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      /**
       * Components that can be placed in an action row for messages.
       * * ButtonComponent
       * * StringSelectMenuComponent
       * * UserSelectMenuComponent
       * * RoleSelectMenuComponent
       * * MentionableSelectMenuComponent
       * * ChannelSelectMenuComponent
       * @typedef {ButtonComponent|StringSelectMenuComponent|UserSelectMenuComponent|
       * RoleSelectMenuComponent|MentionableSelectMenuComponent|ChannelSelectMenuComponent} MessageActionRowComponent
       */
      /**
       * The component which was interacted with
       * @type {MessageActionRowComponent|APIMessageActionRowComponent}
       * @readonly
       */
      get component() {
        return this.message.components.flatMap((row) => row.components).find((component) => (component.customId ?? component.custom_id) === this.customId);
      }
      // These are here only for documentation purposes - they are implemented by InteractionResponses
      /* eslint-disable no-empty-function */
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      deferUpdate() {
      }
      update() {
      }
      showModal() {
      }
      awaitModalSubmit() {
      }
    };
    InteractionResponses.applyToClass(MessageComponentInteraction);
    module2.exports = MessageComponentInteraction;
  }
});

// node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ButtonInteraction.js"(exports2, module2) {
    "use strict";
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var ButtonInteraction = class extends MessageComponentInteraction {
    };
    module2.exports = ButtonInteraction;
  }
});

// node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var ChannelSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        const { resolved, values } = data.data;
        this.values = values ?? [];
        this.channels = new Collection2();
        for (const channel of Object.values((resolved == null ? void 0 : resolved.channels) ?? {})) {
          this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
        }
      }
    };
    module2.exports = ChannelSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/CommandInteraction.js"(exports2, module2) {
    "use strict";
    var Attachment = require_Attachment();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var InteractionResponses = require_InteractionResponses();
    var CommandInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.commandId = data.data.id;
        this.commandName = data.data.name;
        this.commandType = data.data.type;
        this.commandGuildId = data.data.guild_id ?? null;
        this.deferred = false;
        this.replied = false;
        this.ephemeral = null;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      /**
       * The invoked application command, if it was fetched before
       * @type {?ApplicationCommand}
       */
      get command() {
        var _a;
        const id = this.commandId;
        return ((_a = this.guild) == null ? void 0 : _a.commands.cache.get(id)) ?? this.client.application.commands.cache.get(id) ?? null;
      }
      /**
       * Represents the resolved data of a received command interaction.
       * @typedef {Object} CommandInteractionResolvedData
       * @property {Collection<Snowflake, User>} [users] The resolved users
       * @property {Collection<Snowflake, GuildMember|APIGuildMember>} [members] The resolved guild members
       * @property {Collection<Snowflake, Role|APIRole>} [roles] The resolved roles
       * @property {Collection<Snowflake, BaseChannel|APIChannel>} [channels] The resolved channels
       * @property {Collection<Snowflake, Message|APIMessage>} [messages] The resolved messages
       * @property {Collection<Snowflake, Attachment>} [attachments] The resolved attachments
       */
      /**
       * Represents an option of a received command interaction.
       * @typedef {Object} CommandInteractionOption
       * @property {string} name The name of the option
       * @property {ApplicationCommandOptionType} type The type of the option
       * @property {boolean} [autocomplete] Whether the autocomplete interaction is enabled for a
       * {@link ApplicationCommandOptionType.String}, {@link ApplicationCommandOptionType.Integer} or
       * {@link ApplicationCommandOptionType.Number} option
       * @property {string|number|boolean} [value] The value of the option
       * @property {CommandInteractionOption[]} [options] Additional options if this option is a
       * subcommand (group)
       * @property {User} [user] The resolved user
       * @property {GuildMember|APIGuildMember} [member] The resolved member
       * @property {GuildChannel|ThreadChannel|APIChannel} [channel] The resolved channel
       * @property {Role|APIRole} [role] The resolved role
       * @property {Attachment} [attachment] The resolved attachment
       */
      /**
       * Transforms an option received from the API.
       * @param {APIApplicationCommandOption} option The received option
       * @param {APIInteractionDataResolved} resolved The resolved interaction data
       * @returns {CommandInteractionOption}
       * @private
       */
      transformOption(option, resolved) {
        var _a, _b, _c, _d, _e, _f, _g;
        const result = {
          name: option.name,
          type: option.type
        };
        if ("value" in option)
          result.value = option.value;
        if ("options" in option)
          result.options = option.options.map((opt) => this.transformOption(opt, resolved));
        if (resolved) {
          const user = (_a = resolved.users) == null ? void 0 : _a[option.value];
          if (user)
            result.user = this.client.users._add(user);
          const member = (_b = resolved.members) == null ? void 0 : _b[option.value];
          if (member)
            result.member = ((_c = this.guild) == null ? void 0 : _c.members._add({ user, ...member })) ?? member;
          const channel = (_d = resolved.channels) == null ? void 0 : _d[option.value];
          if (channel)
            result.channel = this.client.channels._add(channel, this.guild) ?? channel;
          const role = (_e = resolved.roles) == null ? void 0 : _e[option.value];
          if (role)
            result.role = ((_f = this.guild) == null ? void 0 : _f.roles._add(role)) ?? role;
          const attachment = (_g = resolved.attachments) == null ? void 0 : _g[option.value];
          if (attachment)
            result.attachment = new Attachment(attachment);
        }
        return result;
      }
      // These are here only for documentation purposes - they are implemented by InteractionResponses
      /* eslint-disable no-empty-function */
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      showModal() {
      }
      awaitModalSubmit() {
      }
    };
    InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
    module2.exports = CommandInteraction;
  }
});

// node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ChatInputCommandInteraction.js"(exports2, module2) {
    "use strict";
    var CommandInteraction = require_CommandInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var { transformResolved } = require_Util();
    var ChatInputCommandInteraction = class extends CommandInteraction {
      constructor(client, data) {
        var _a;
        super(client, data);
        this.options = new CommandInteractionOptionResolver(
          this.client,
          ((_a = data.data.options) == null ? void 0 : _a.map((option) => this.transformOption(option, data.data.resolved))) ?? [],
          transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved)
        );
      }
      /**
       * Returns a string representation of the command interaction.
       * This can then be copied by a user and executed again in a new command while keeping the option order.
       * @returns {string}
       */
      toString() {
        const properties = [
          this.commandName,
          this.options._group,
          this.options._subcommand,
          ...this.options._hoistedOptions.map((option) => `${option.name}:${option.value}`)
        ];
        return `/${properties.filter(Boolean).join(" ")}`;
      }
    };
    module2.exports = ChatInputCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var Events2 = require_Events();
    var MentionableSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        var _a, _b;
        super(client, data);
        const { resolved, values } = data.data;
        const { members, users, roles } = resolved ?? {};
        this.values = values ?? [];
        this.users = new Collection2();
        this.members = new Collection2();
        this.roles = new Collection2();
        if (members) {
          for (const [id, member] of Object.entries(members)) {
            const user = users[id];
            if (!user) {
              this.client.emit(
                Events2.Debug,
                `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`
              );
              continue;
            }
            this.members.set(id, ((_a = this.guild) == null ? void 0 : _a.members._add({ user, ...member })) ?? { user, ...member });
          }
        }
        if (users) {
          for (const user of Object.values(users)) {
            this.users.set(user.id, this.client.users._add(user));
          }
        }
        if (roles) {
          for (const role of Object.values(roles)) {
            this.roles.set(role.id, ((_b = this.guild) == null ? void 0 : _b.roles._add(role)) ?? role);
          }
        }
      }
    };
    module2.exports = MentionableSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist();
    var { ApplicationCommandOptionType } = require_v106();
    var CommandInteraction = require_CommandInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var { transformResolved } = require_Util();
    var getMessage = lazy(() => require_Message().Message);
    var ContextMenuCommandInteraction = class extends CommandInteraction {
      constructor(client, data) {
        super(client, data);
        this.options = new CommandInteractionOptionResolver(
          this.client,
          this.resolveContextMenuOptions(data.data),
          transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved)
        );
        this.targetId = data.data.target_id;
      }
      /**
       * Resolves and transforms options received from the API for a context menu interaction.
       * @param {APIApplicationCommandInteractionData} data The interaction data
       * @returns {CommandInteractionOption[]}
       * @private
       */
      resolveContextMenuOptions({ target_id, resolved }) {
        var _a, _b, _c;
        const result = [];
        if ((_a = resolved.users) == null ? void 0 : _a[target_id]) {
          result.push(
            this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved)
          );
        }
        if ((_b = resolved.messages) == null ? void 0 : _b[target_id]) {
          result.push({
            name: "message",
            type: "_MESSAGE",
            value: target_id,
            message: ((_c = this.channel) == null ? void 0 : _c.messages._add(resolved.messages[target_id])) ?? new (getMessage())(this.client, resolved.messages[target_id])
          });
        }
        return result;
      }
    };
    module2.exports = ContextMenuCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    var MessageContextMenuCommandInteraction = class extends ContextMenuCommandInteraction {
      /**
       * The message this interaction was sent from
       * @type {Message|APIMessage}
       * @readonly
       */
      get targetMessage() {
        return this.options.getMessage("message");
      }
    };
    module2.exports = MessageContextMenuCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS({
  "node_modules/discord.js/src/structures/ModalSubmitFields.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { ComponentType } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ModalSubmitFields = class {
      constructor(components) {
        this.components = components;
        this.fields = components.reduce((accumulator, next) => {
          next.components.forEach((component) => accumulator.set(component.customId, component));
          return accumulator;
        }, new Collection2());
      }
      /**
       * Gets a field given a custom id from a component
       * @param {string} customId The custom id of the component
       * @param {ComponentType} [type] The type of the component
       * @returns {ModalData}
       */
      getField(customId, type) {
        const field = this.fields.get(customId);
        if (!field)
          throw new DiscordjsTypeError2(ErrorCodes2.ModalSubmitInteractionFieldNotFound, customId);
        if (type !== void 0 && type !== field.type) {
          throw new DiscordjsTypeError2(ErrorCodes2.ModalSubmitInteractionFieldType, customId, field.type, type);
        }
        return field;
      }
      /**
       * Gets the value of a text input component given a custom id
       * @param {string} customId The custom id of the text input component
       * @returns {string}
       */
      getTextInputValue(customId) {
        return this.getField(customId, ComponentType.TextInput).value;
      }
    };
    module2.exports = ModalSubmitFields;
  }
});

// node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS({
  "node_modules/discord.js/src/structures/ModalSubmitInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var ModalSubmitFields = require_ModalSubmitFields();
    var InteractionResponses = require_InteractionResponses();
    var getMessage = lazy(() => require_Message().Message);
    var ModalSubmitInteraction = class _ModalSubmitInteraction extends BaseInteraction {
      constructor(client, data) {
        var _a, _b;
        super(client, data);
        this.customId = data.data.custom_id;
        if ("message" in data) {
          this.message = ((_a = this.channel) == null ? void 0 : _a.messages._add(data.message)) ?? new (getMessage())(this.client, data.message);
        } else {
          this.message = null;
        }
        this.components = (_b = data.data.components) == null ? void 0 : _b.map((component) => _ModalSubmitInteraction.transformComponent(component));
        this.fields = new ModalSubmitFields(this.components);
        this.deferred = false;
        this.replied = false;
        this.ephemeral = null;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      /**
       * Transforms component data to discord.js-compatible data
       * @param {*} rawComponent The data to transform
       * @returns {ModalData[]}
       */
      static transformComponent(rawComponent) {
        return rawComponent.components ? {
          type: rawComponent.type,
          components: rawComponent.components.map((component) => this.transformComponent(component))
        } : {
          value: rawComponent.value,
          type: rawComponent.type,
          customId: rawComponent.custom_id
        };
      }
      /**
       * Whether this is from a {@link MessageComponentInteraction}.
       * @returns {boolean}
       */
      isFromMessage() {
        return Boolean(this.message);
      }
      // These are here only for documentation purposes - they are implemented by InteractionResponses
      /* eslint-disable no-empty-function */
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      deferUpdate() {
      }
      update() {
      }
    };
    InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
    module2.exports = ModalSubmitInteraction;
  }
});

// node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var RoleSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        var _a;
        super(client, data);
        const { resolved, values } = data.data;
        this.values = values ?? [];
        this.roles = new Collection2();
        for (const role of Object.values((resolved == null ? void 0 : resolved.roles) ?? {})) {
          this.roles.set(role.id, ((_a = this.guild) == null ? void 0 : _a.roles._add(role)) ?? role);
        }
      }
    };
    module2.exports = RoleSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var StringSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        this.values = data.data.values ?? [];
      }
    };
    module2.exports = StringSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS({
  "node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    var UserContextMenuCommandInteraction = class extends ContextMenuCommandInteraction {
      /**
       * The target user from this interaction
       * @type {User}
       * @readonly
       */
      get targetUser() {
        return this.options.getUser("user");
      }
      /**
       * The target member from this interaction
       * @type {?(GuildMember|APIGuildMember)}
       * @readonly
       */
      get targetMember() {
        return this.options.getMember("user");
      }
    };
    module2.exports = UserContextMenuCommandInteraction;
  }
});

// node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/UserSelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var Events2 = require_Events();
    var UserSelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        var _a;
        super(client, data);
        const { resolved, values } = data.data;
        this.values = values ?? [];
        this.users = new Collection2();
        this.members = new Collection2();
        for (const user of Object.values((resolved == null ? void 0 : resolved.users) ?? {})) {
          this.users.set(user.id, this.client.users._add(user));
        }
        for (const [id, member] of Object.entries((resolved == null ? void 0 : resolved.members) ?? {})) {
          const user = resolved.users[id];
          if (!user) {
            this.client.emit(Events2.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, ((_a = this.guild) == null ? void 0 : _a.members._add({ user, ...member })) ?? { user, ...member });
        }
      }
    };
    module2.exports = UserSelectMenuInteraction;
  }
});

// node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/InteractionCreate.js"(exports2, module2) {
    "use strict";
    var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
    var Action = require_Action();
    var AutocompleteInteraction = require_AutocompleteInteraction();
    var ButtonInteraction = require_ButtonInteraction();
    var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
    var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
    var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
    var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
    var ModalSubmitInteraction = require_ModalSubmitInteraction();
    var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
    var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
    var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
    var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
    var Events2 = require_Events();
    var InteractionCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = data.channel && this.getChannel(data.channel);
        let InteractionClass;
        switch (data.type) {
          case InteractionType.ApplicationCommand:
            switch (data.data.type) {
              case ApplicationCommandType.ChatInput:
                InteractionClass = ChatInputCommandInteraction;
                break;
              case ApplicationCommandType.User:
                InteractionClass = UserContextMenuCommandInteraction;
                break;
              case ApplicationCommandType.Message:
                if (channel && !channel.isTextBased())
                  return;
                InteractionClass = MessageContextMenuCommandInteraction;
                break;
              default:
                client.emit(
                  Events2.Debug,
                  `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`
                );
                return;
            }
            break;
          case InteractionType.MessageComponent:
            if (channel && !channel.isTextBased())
              return;
            switch (data.data.component_type) {
              case ComponentType.Button:
                InteractionClass = ButtonInteraction;
                break;
              case ComponentType.StringSelect:
                InteractionClass = StringSelectMenuInteraction;
                break;
              case ComponentType.UserSelect:
                InteractionClass = UserSelectMenuInteraction;
                break;
              case ComponentType.RoleSelect:
                InteractionClass = RoleSelectMenuInteraction;
                break;
              case ComponentType.MentionableSelect:
                InteractionClass = MentionableSelectMenuInteraction;
                break;
              case ComponentType.ChannelSelect:
                InteractionClass = ChannelSelectMenuInteraction;
                break;
              default:
                client.emit(
                  Events2.Debug,
                  `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`
                );
                return;
            }
            break;
          case InteractionType.ApplicationCommandAutocomplete:
            InteractionClass = AutocompleteInteraction;
            break;
          case InteractionType.ModalSubmit:
            InteractionClass = ModalSubmitInteraction;
            break;
          default:
            client.emit(Events2.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
            return;
        }
        const interaction = new InteractionClass(client, data);
        client.emit(Events2.InteractionCreate, interaction);
      }
    };
    module2.exports = InteractionCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/InviteCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var InviteCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel)
          return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = guild.invites._add(inviteData);
        client.emit(Events2.InviteCreate, invite);
        return { invite };
      }
    };
    module2.exports = InviteCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/InviteDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Invite2 = require_Invite();
    var Events2 = require_Events();
    var InviteDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel)
          return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = new Invite2(client, inviteData);
        guild.invites.cache.delete(invite.code);
        client.emit(Events2.InviteDelete, invite);
        return { invite };
      }
    };
    module2.exports = InviteDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var MessageCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread()) {
            channel.messageCount++;
            channel.totalMessageSent++;
          }
          const existing = channel.messages.cache.get(data.id);
          if (existing)
            return { message: existing };
          const message = channel.messages._add(data);
          channel.lastMessageId = data.id;
          client.emit(Events2.MessageCreate, message);
          return { message };
        }
        return {};
      }
    };
    module2.exports = MessageCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var MessageDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        let message;
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread())
            channel.messageCount--;
          message = this.getMessage(data, channel);
          if (message) {
            channel.messages.cache.delete(message.id);
            client.emit(Events2.MessageDelete, message);
          }
        }
        return { message };
      }
    };
    module2.exports = MessageDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageDeleteBulk.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Action = require_Action();
    var Events2 = require_Events();
    var MessageDeleteBulkAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread())
            channel.messageCount -= data.ids.length;
          const ids = data.ids;
          const messages = new Collection2();
          for (const id of ids) {
            const message = this.getMessage(
              {
                id,
                guild_id: data.guild_id
              },
              channel,
              false
            );
            if (message) {
              messages.set(message.id, message);
              channel.messages.cache.delete(id);
            }
          }
          if (messages.size > 0)
            client.emit(Events2.MessageBulkDelete, messages, channel);
          return { messages };
        }
        return {};
      }
    };
    module2.exports = MessageDeleteBulkAction;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var Partials = require_Partials();
    var MessageReactionAdd = class extends Action {
      handle(data, fromStructure = false) {
        if (!data.emoji)
          return false;
        const user = this.getUserFromMember(data);
        if (!user)
          return false;
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const includePartial = this.client.options.partials.includes(Partials.Reaction);
        if (message.partial && !includePartial)
          return false;
        const reaction = message.reactions._add({
          emoji: data.emoji,
          count: message.partial ? null : 0,
          me: user.id === this.client.user.id
        });
        if (!reaction)
          return false;
        reaction._add(user);
        if (fromStructure)
          return { message, reaction, user };
        this.client.emit(Events2.MessageReactionAdd, reaction, user);
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionAdd;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var MessageReactionRemove = class extends Action {
      handle(data) {
        if (!data.emoji)
          return false;
        const user = this.getUser(data);
        if (!user)
          return false;
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const reaction = this.getReaction(data, message, user);
        if (!reaction)
          return false;
        reaction._remove(user);
        this.client.emit(Events2.MessageReactionRemove, reaction, user);
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionRemove;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var MessageReactionRemoveAll = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const removed = message.reactions.cache.clone();
        message.reactions.cache.clear();
        this.client.emit(Events2.MessageReactionRemoveAll, message, removed);
        return { message };
      }
    };
    module2.exports = MessageReactionRemoveAll;
  }
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var MessageReactionRemoveEmoji = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const reaction = this.getReaction(data, message);
        if (!reaction)
          return false;
        if (!message.partial)
          message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
        this.client.emit(Events2.MessageReactionRemoveEmoji, reaction);
        return { reaction };
      }
    };
    module2.exports = MessageReactionRemoveEmoji;
  }
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/MessageUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var MessageUpdateAction = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          const { id, channel_id, guild_id, author, timestamp, type } = data;
          const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
          if (message) {
            const old = message._update(data);
            return {
              old,
              updated: message
            };
          }
        }
        return {};
      }
    };
    module2.exports = MessageUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/PresenceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var PresenceUpdateAction = class extends Action {
      handle(data) {
        var _a;
        let user = this.client.users.cache.get(data.user.id);
        if (!user && data.user.username)
          user = this.client.users._add(data.user);
        if (!user)
          return;
        if (data.user.username) {
          if (!user._equals(data.user))
            this.client.actions.UserUpdate.handle(data.user);
        }
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!guild)
          return;
        const oldPresence = ((_a = guild.presences.cache.get(user.id)) == null ? void 0 : _a._clone()) ?? null;
        let member = guild.members.cache.get(user.id);
        if (!member && data.status !== "offline") {
          member = guild.members._add({
            user,
            deaf: false,
            mute: false
          });
          this.client.emit(Events2.GuildMemberAvailable, member);
        }
        const newPresence = guild.presences._add(Object.assign(data, { guild }));
        if (this.client.listenerCount(Events2.PresenceUpdate) && !newPresence.equals(oldPresence)) {
          this.client.emit(Events2.PresenceUpdate, oldPresence, newPresence);
        }
      }
    };
    module2.exports = PresenceUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/StageInstanceCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var StageInstanceCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events2.StageInstanceCreate, stageInstance);
          return { stageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/StageInstanceDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var StageInstanceDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          if (stageInstance) {
            channel.guild.stageInstances.cache.delete(stageInstance.id);
            client.emit(Events2.StageInstanceDelete, stageInstance);
            return { stageInstance };
          }
        }
        return {};
      }
    };
    module2.exports = StageInstanceDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/StageInstanceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var StageInstanceUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const oldStageInstance = ((_a = channel.guild.stageInstances.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newStageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events2.StageInstanceUpdate, oldStageInstance, newStageInstance);
          return { oldStageInstance, newStageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var ThreadCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const thread = client.channels._add(data);
        if (!existing && thread) {
          client.emit(Events2.ThreadCreate, thread, data.newly_created ?? false);
        }
        return { thread };
      }
    };
    module2.exports = ThreadCreateAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var ThreadDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          client.channels._remove(thread.id);
          client.emit(Events2.ThreadDelete, thread);
        }
        return { thread };
      }
    };
    module2.exports = ThreadDeleteAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadListSync.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Action = require_Action();
    var Events2 = require_Events();
    var ThreadListSyncAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (!guild)
          return {};
        if (data.channel_ids) {
          for (const id of data.channel_ids) {
            const channel = client.channels.resolve(id);
            if (channel)
              this.removeStale(channel);
          }
        } else {
          for (const channel of guild.channels.cache.values()) {
            this.removeStale(channel);
          }
        }
        const syncedThreads = data.threads.reduce((coll, rawThread) => {
          const thread = client.channels._add(rawThread);
          return coll.set(thread.id, thread);
        }, new Collection2());
        for (const rawMember of Object.values(data.members)) {
          const thread = client.channels.cache.get(rawMember.id);
          if (thread) {
            thread.members._add(rawMember);
          }
        }
        client.emit(Events2.ThreadListSync, syncedThreads, guild);
        return {
          syncedThreads
        };
      }
      removeStale(channel) {
        var _a;
        (_a = channel.threads) == null ? void 0 : _a.cache.forEach((thread) => {
          if (!thread.archived) {
            this.client.channels._remove(thread.id);
          }
        });
      }
    };
    module2.exports = ThreadListSyncAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var ThreadMemberUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          const member = thread.members.cache.get(data.user_id);
          if (!member) {
            const newMember = thread.members._add(data);
            return { newMember };
          }
          const old = member._update(data);
          client.emit(Events2.ThreadMemberUpdate, old, member);
        }
        return {};
      }
    };
    module2.exports = ThreadMemberUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Action = require_Action();
    var Events2 = require_Events();
    var ThreadMembersUpdateAction = class extends Action {
      handle(data) {
        var _a, _b;
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          thread.memberCount = data.member_count;
          const addedMembers = new Collection2();
          const removedMembers = new Collection2();
          (_a = data.added_members) == null ? void 0 : _a.reduce(
            (_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)),
            addedMembers
          );
          (_b = data.removed_member_ids) == null ? void 0 : _b.reduce((removedMembersIds, removedMembersId) => {
            const threadMember = this.getThreadMember(removedMembersId, thread.members);
            if (threadMember)
              removedMembersIds.set(threadMember.id, threadMember);
            thread.members.cache.delete(removedMembersId);
            return removedMembersIds;
          }, removedMembers);
          if (addedMembers.size === 0 && removedMembers.size === 0) {
            return {};
          }
          client.emit(Events2.ThreadMembersUpdate, addedMembers, removedMembers, thread);
        }
        return {};
      }
    };
    module2.exports = ThreadMembersUpdateAction;
  }
});

// node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS({
  "node_modules/discord.js/src/structures/Typing.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var Typing = class extends Base {
      constructor(channel, user, data) {
        super(channel.client);
        this.channel = channel;
        this.user = user;
        this._patch(data);
      }
      _patch(data) {
        if ("timestamp" in data) {
          this.startedTimestamp = data.timestamp * 1e3;
        }
      }
      /**
       * Indicates whether the status is received from a guild.
       * @returns {boolean}
       */
      inGuild() {
        return this.guild !== null;
      }
      /**
       * The time the user started typing at
       * @type {Date}
       * @readonly
       */
      get startedAt() {
        return new Date(this.startedTimestamp);
      }
      /**
       * The guild the status is from
       * @type {?Guild}
       * @readonly
       */
      get guild() {
        return this.channel.guild ?? null;
      }
      /**
       * The member who is typing
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.members.resolve(this.user)) ?? null;
      }
    };
    module2.exports = Typing;
  }
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS({
  "node_modules/discord.js/src/client/actions/TypingStart.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Typing = require_Typing();
    var Events2 = require_Events();
    var TypingStart = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!channel)
          return;
        if (!channel.isTextBased()) {
          this.client.emit(Events2.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
          return;
        }
        const user = this.getUserFromMember(data);
        if (user) {
          this.client.emit(Events2.TypingStart, new Typing(channel, user, data));
        }
      }
    };
    module2.exports = TypingStart;
  }
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/UserUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events2 = require_Events();
    var UserUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
        const oldUser = newUser._update(data);
        if (!oldUser.equals(newUser)) {
          client.emit(Events2.UserUpdate, oldUser, newUser);
          return {
            old: oldUser,
            updated: newUser
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = UserUpdateAction;
  }
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/VoiceStateUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var VoiceState = require_VoiceState();
    var Events2 = require_Events();
    var VoiceStateUpdate = class extends Action {
      handle(data) {
        var _a, _b;
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldState = ((_a = guild.voiceStates.cache.get(data.user_id)) == null ? void 0 : _a._clone()) ?? new VoiceState(guild, { user_id: data.user_id });
          const newState = guild.voiceStates._add(data);
          let member = guild.members.cache.get(data.user_id);
          if (member && data.member) {
            member._patch(data.member);
          } else if (((_b = data.member) == null ? void 0 : _b.user) && data.member.joined_at) {
            member = guild.members._add(data.member);
          }
          if ((member == null ? void 0 : member.user.id) === client.user.id) {
            client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
            client.voice.onVoiceStateUpdate(data);
          }
          client.emit(Events2.VoiceStateUpdate, oldState, newState);
        }
      }
    };
    module2.exports = VoiceStateUpdate;
  }
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS({
  "node_modules/discord.js/src/client/actions/WebhooksUpdate.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var Action = require_Action();
    var deprecationEmitted = false;
    var WebhooksUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (!channel)
          return;
        client.emit("webhooksUpdate", channel);
        if (client.emit("webhookUpdate", channel) && !deprecationEmitted) {
          deprecationEmitted = true;
          process2.emitWarning("The webhookUpdate event is deprecated. Use webhooksUpdate instead.", "DeprecationWarning");
        }
      }
    };
    module2.exports = WebhooksUpdate;
  }
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS({
  "node_modules/discord.js/src/client/actions/ActionsManager.js"(exports2, module2) {
    "use strict";
    var ActionsManager2 = class {
      constructor(client) {
        // These symbols represent fully built data that we inject at times when calling actions manually.
        // Action#getUser, for example, will return the injected data (which is assumed to be a built structure)
        // instead of trying to make it from provided data
        __publicField(this, "injectedUser", Symbol("djs.actions.injectedUser"));
        __publicField(this, "injectedChannel", Symbol("djs.actions.injectedChannel"));
        __publicField(this, "injectedMessage", Symbol("djs.actions.injectedMessage"));
        this.client = client;
        this.register(require_ApplicationCommandPermissionsUpdate());
        this.register(require_AutoModerationActionExecution2());
        this.register(require_AutoModerationRuleCreate());
        this.register(require_AutoModerationRuleDelete());
        this.register(require_AutoModerationRuleUpdate());
        this.register(require_ChannelCreate());
        this.register(require_ChannelDelete());
        this.register(require_ChannelUpdate());
        this.register(require_GuildAuditLogEntryCreate());
        this.register(require_GuildBanAdd());
        this.register(require_GuildBanRemove());
        this.register(require_GuildChannelsPositionUpdate());
        this.register(require_GuildDelete());
        this.register(require_GuildEmojiCreate());
        this.register(require_GuildEmojiDelete());
        this.register(require_GuildEmojiUpdate());
        this.register(require_GuildEmojisUpdate());
        this.register(require_GuildIntegrationsUpdate());
        this.register(require_GuildMemberRemove());
        this.register(require_GuildMemberUpdate());
        this.register(require_GuildRoleCreate());
        this.register(require_GuildRoleDelete());
        this.register(require_GuildRoleUpdate());
        this.register(require_GuildRolesPositionUpdate());
        this.register(require_GuildScheduledEventCreate());
        this.register(require_GuildScheduledEventDelete());
        this.register(require_GuildScheduledEventUpdate());
        this.register(require_GuildScheduledEventUserAdd());
        this.register(require_GuildScheduledEventUserRemove());
        this.register(require_GuildStickerCreate());
        this.register(require_GuildStickerDelete());
        this.register(require_GuildStickerUpdate());
        this.register(require_GuildStickersUpdate());
        this.register(require_GuildUpdate());
        this.register(require_InteractionCreate());
        this.register(require_InviteCreate());
        this.register(require_InviteDelete());
        this.register(require_MessageCreate());
        this.register(require_MessageDelete());
        this.register(require_MessageDeleteBulk());
        this.register(require_MessageReactionAdd());
        this.register(require_MessageReactionRemove());
        this.register(require_MessageReactionRemoveAll());
        this.register(require_MessageReactionRemoveEmoji());
        this.register(require_MessageUpdate());
        this.register(require_PresenceUpdate());
        this.register(require_StageInstanceCreate());
        this.register(require_StageInstanceDelete());
        this.register(require_StageInstanceUpdate());
        this.register(require_ThreadCreate());
        this.register(require_ThreadDelete());
        this.register(require_ThreadListSync());
        this.register(require_ThreadMemberUpdate());
        this.register(require_ThreadMembersUpdate());
        this.register(require_TypingStart());
        this.register(require_UserUpdate());
        this.register(require_VoiceStateUpdate());
        this.register(require_WebhooksUpdate());
      }
      register(Action) {
        this[Action.name.replace(/Action$/, "")] = new Action(this.client);
      }
    };
    module2.exports = ActionsManager2;
  }
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS({
  "node_modules/discord.js/src/client/voice/ClientVoiceManager.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    var ClientVoiceManager2 = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
        this.adapters = /* @__PURE__ */ new Map();
        client.on(Events2.ShardDisconnect, (_, shardId) => {
          var _a;
          for (const [guildId, adapter] of this.adapters.entries()) {
            if (((_a = client.guilds.cache.get(guildId)) == null ? void 0 : _a.shardId) === shardId) {
              adapter.destroy();
            }
          }
        });
      }
      onVoiceServer(payload) {
        var _a;
        (_a = this.adapters.get(payload.guild_id)) == null ? void 0 : _a.onVoiceServerUpdate(payload);
      }
      onVoiceStateUpdate(payload) {
        var _a, _b;
        if (payload.guild_id && payload.session_id && payload.user_id === ((_a = this.client.user) == null ? void 0 : _a.id)) {
          (_b = this.adapters.get(payload.guild_id)) == null ? void 0 : _b.onVoiceStateUpdate(payload);
        }
      }
    };
    module2.exports = ClientVoiceManager2;
  }
});

// node_modules/@discordjs/ws/node_modules/@discordjs/collection/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@discordjs/ws/node_modules/@discordjs/collection/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      Collection: () => Collection2,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    var _a;
    var Collection2 = (_a = class extends Map {
      /**
       * Obtains the value of the given key if it exists, otherwise sets and returns the value provided by the default value generator.
       *
       * @param key - The key to get if it exists, or set otherwise
       * @param defaultValueGenerator - A function that generates the default value
       * @example
       * ```ts
       * collection.ensure(guildId, () => defaultGuildConfig);
       * ```
       */
      ensure(key, defaultValueGenerator) {
        if (this.has(key))
          return this.get(key);
        if (typeof defaultValueGenerator !== "function")
          throw new TypeError(`${defaultValueGenerator} is not a function`);
        const defaultValue = defaultValueGenerator(key, this);
        this.set(key, defaultValue);
        return defaultValue;
      }
      /**
       * Checks if all of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if all of the elements exist, `false` if at least one does not exist.
       */
      hasAll(...keys) {
        return keys.every((key) => super.has(key));
      }
      /**
       * Checks if any of the elements exist in the collection.
       *
       * @param keys - The keys of the elements to check for
       * @returns `true` if any of the elements exist, `false` if none exist.
       */
      hasAny(...keys) {
        return keys.some((key) => super.has(key));
      }
      first(amount) {
        if (amount === void 0)
          return this.values().next().value;
        if (amount < 0)
          return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      firstKey(amount) {
        if (amount === void 0)
          return this.keys().next().value;
        if (amount < 0)
          return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      last(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.first(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      lastKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[arr.length - 1];
        if (amount < 0)
          return this.firstKey(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the item at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the element to obtain
       */
      at(index) {
        index = Math.floor(index);
        const arr = [...this.values()];
        return arr.at(index);
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
       * Returns the key at a given index, allowing for positive and negative integers.
       * Negative integers count back from the last item in the collection.
       *
       * @param index - The index of the key to obtain
       */
      keyAt(index) {
        index = Math.floor(index);
        const arr = [...this.keys()];
        return arr.at(index);
      }
      random(amount) {
        const arr = [...this.values()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      randomKey(amount) {
        const arr = [...this.keys()];
        if (amount === void 0)
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse | Array.reverse()}
       * but returns a Collection instead of an Array.
       */
      reverse() {
        const entries = [...this.entries()].reverse();
        this.clear();
        for (const [key, value] of entries)
          this.set(key, value);
        return this;
      }
      find(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      findLast(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const entries = [...this.entries()];
        for (let index = entries.length - 1; index >= 0; index--) {
          const val = entries[index][1];
          const key = entries[index][0];
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findLastKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const entries = [...this.entries()];
        for (let index = entries.length - 1; index >= 0; index--) {
          const key = entries[index][0];
          const val = entries[index][1];
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      sweep(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this) {
          if (fn(val, key, this))
            this.delete(key);
        }
        return previousSize - this.size;
      }
      filter(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this) {
          if (fn(val, key, this))
            results.set(key, val);
        }
        return results;
      }
      partition(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const results = [
          new this.constructor[Symbol.species](),
          new this.constructor[Symbol.species]()
        ];
        for (const [key, val] of this) {
          if (fn(val, key, this)) {
            results[0].set(key, val);
          } else {
            results[1].set(key, val);
          }
        }
        return results;
      }
      flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
      }
      map(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({ length: this.size }, () => {
          const [key, value] = iter.next().value;
          return fn(value, key, this);
        });
      }
      mapValues(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
          coll.set(key, fn(val, key, this));
        return coll;
      }
      some(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return true;
        }
        return false;
      }
      every(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (!fn(val, key, this))
            return false;
        }
        return true;
      }
      /**
       * Applies a function to produce a single value. Identical in behavior to
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce | Array.reduce()}.
       *
       * @param fn - Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,
       * and `collection`
       * @param initialValue - Starting value for the accumulator
       * @example
       * ```ts
       * collection.reduce((acc, guild) => acc + guild.memberCount, 0);
       * ```
       */
      reduce(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        let accumulator;
        const iterator = this.entries();
        if (initialValue === void 0) {
          if (this.size === 0)
            throw new TypeError("Reduce of empty collection with no initial value");
          accumulator = iterator.next().value[1];
        } else {
          accumulator = initialValue;
        }
        for (const [key, value] of iterator) {
          accumulator = fn(accumulator, value, key, this);
        }
        return accumulator;
      }
      /**
       * Applies a function to produce a single value. Identical in behavior to
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight | Array.reduceRight()}.
       *
       * @param fn - Function used to reduce, taking four arguments; `accumulator`, `value`, `key`, and `collection`
       * @param initialValue - Starting value for the accumulator
       */
      reduceRight(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        const entries = [...this.entries()];
        let accumulator;
        let index;
        if (initialValue === void 0) {
          if (entries.length === 0)
            throw new TypeError("Reduce of empty collection with no initial value");
          accumulator = entries[entries.length - 1][1];
          index = entries.length - 1;
        } else {
          accumulator = initialValue;
          index = entries.length;
        }
        while (--index >= 0) {
          const key = entries[index][0];
          const val = entries[index][1];
          accumulator = fn(accumulator, val, key, this);
        }
        return accumulator;
      }
      each(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        for (const [key, value] of this) {
          fn(value, key, this);
        }
        return this;
      }
      tap(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0)
          fn = fn.bind(thisArg);
        fn(this);
        return this;
      }
      /**
       * Creates an identical shallow copy of this collection.
       *
       * @example
       * ```ts
       * const newColl = someColl.clone();
       * ```
       */
      clone() {
        return new this.constructor[Symbol.species](this);
      }
      /**
       * Combines this collection with others into a new collection. None of the source collections are modified.
       *
       * @param collections - Collections to merge
       * @example
       * ```ts
       * const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);
       * ```
       */
      concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections) {
          for (const [key, val] of coll)
            newColl.set(key, val);
        }
        return newColl;
      }
      /**
       * Checks if this collection shares identical items with another.
       * This is different to checking for equality using equal-signs, because
       * the collections may be different objects, but contain the same data.
       *
       * @param collection - Collection to compare with
       * @returns Whether the collections have identical contents
       */
      equals(collection) {
        if (!collection)
          return false;
        if (this === collection)
          return true;
        if (this.size !== collection.size)
          return false;
        for (const [key, value] of this) {
          if (!collection.has(key) || value !== collection.get(key)) {
            return false;
          }
        }
        return true;
      }
      /**
       * The sort method sorts the items of a collection in place and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value, according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      sort(compareFunction = _a.defaultSort) {
        const entries = [...this.entries()];
        entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
        super.clear();
        for (const [key, value] of entries) {
          super.set(key, value);
        }
        return this;
      }
      /**
       * The intersection method returns a new collection containing the items where the key is present in both collections.
       *
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['c', 3]]);
       * const intersection = col1.intersection(col2);
       * console.log(col1.intersection(col2));
       * // => Collection { 'a' => 1 }
       * ```
       */
      intersection(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (other.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Returns a new collection containing the items where the key is present in either of the collections.
       *
       * @remarks
       *
       * If the collections have any items with the same key, the value from the first collection will be used.
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['b', 3], ['c', 3]]);
       * const union = col1.union(col2);
       * console.log(union);
       * // => Collection { 'a' => 1, 'b' => 2, 'c' => 3 }
       * ```
       */
      union(other) {
        const coll = new this.constructor[Symbol.species](this);
        for (const [key, value] of other) {
          if (!coll.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Returns a new collection containing the items where the key is present in this collection but not the other.
       *
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['c', 3]]);
       * console.log(col1.difference(col2));
       * // => Collection { 'b' => 2 }
       * console.log(col2.difference(col1));
       * // => Collection { 'c' => 3 }
       * ```
       */
      difference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (!other.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Returns a new collection containing only the items where the keys are present in either collection, but not both.
       *
       * @param other - The other Collection to filter against
       * @example
       * ```ts
       * const col1 = new Collection([['a', 1], ['b', 2]]);
       * const col2 = new Collection([['a', 1], ['c', 3]]);
       * const symmetricDifference = col1.symmetricDifference(col2);
       * console.log(col1.symmetricDifference(col2));
       * // => Collection { 'b' => 2, 'c' => 3 }
       * ```
       */
      symmetricDifference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this) {
          if (!other.has(key))
            coll.set(key, value);
        }
        for (const [key, value] of other) {
          if (!this.has(key))
            coll.set(key, value);
        }
        return coll;
      }
      /**
       * Merges two Collections together into a new Collection.
       *
       * @param other - The other Collection to merge with
       * @param whenInSelf - Function getting the result if the entry only exists in this Collection
       * @param whenInOther - Function getting the result if the entry only exists in the other Collection
       * @param whenInBoth - Function getting the result if the entry exists in both Collections
       * @example
       * ```ts
       * // Sums up the entries in two collections.
       * coll.merge(
       *  other,
       *  x => ({ keep: true, value: x }),
       *  y => ({ keep: true, value: y }),
       *  (x, y) => ({ keep: true, value: x + y }),
       * );
       * ```
       * @example
       * ```ts
       * // Intersects two collections in a left-biased manner.
       * coll.merge(
       *  other,
       *  x => ({ keep: false }),
       *  y => ({ keep: false }),
       *  (x, _) => ({ keep: true, value: x }),
       * );
       * ```
       */
      merge(other, whenInSelf, whenInOther, whenInBoth) {
        const coll = new this.constructor[Symbol.species]();
        const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
        for (const key of keys) {
          const hasInSelf = this.has(key);
          const hasInOther = other.has(key);
          if (hasInSelf && hasInOther) {
            const result = whenInBoth(this.get(key), other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInSelf) {
            const result = whenInSelf(this.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          } else if (hasInOther) {
            const result = whenInOther(other.get(key), key);
            if (result.keep)
              coll.set(key, result.value);
          }
        }
        return coll;
      }
      /**
       * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed | Array.toReversed()}
       * but returns a Collection instead of an Array.
       */
      toReversed() {
        return new this.constructor[Symbol.species](this).reverse();
      }
      /**
       * The sorted method sorts the items of a collection and returns it.
       * The sort is not necessarily stable in Node 10 or older.
       * The default sort order is according to string Unicode code points.
       *
       * @param compareFunction - Specifies a function that defines the sort order.
       * If omitted, the collection is sorted according to each character's Unicode code point value,
       * according to the string conversion of each element.
       * @example
       * ```ts
       * collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
       * ```
       */
      toSorted(compareFunction = _a.defaultSort) {
        return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
      }
      toJSON() {
        return [...this.entries()];
      }
      static defaultSort(firstValue, secondValue) {
        return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
      }
      /**
       * Creates a Collection from a list of entries.
       *
       * @param entries - The list of entries
       * @param combine - Function to combine an existing entry with a new one
       * @example
       * ```ts
       * Collection.combineEntries([["a", 1], ["b", 2], ["a", 2]], (x, y) => x + y);
       * // returns Collection { "a" => 3, "b" => 2 }
       * ```
       */
      static combineEntries(entries, combine) {
        const coll = new _a();
        for (const [key, value] of entries) {
          if (coll.has(key)) {
            coll.set(key, combine(coll.get(key), value, key));
          } else {
            coll.set(key, value);
          }
        }
        return coll;
      }
    }, __name(_a, "Collection"), _a);
    var version = "2.0.0";
  }
});

// browser-external:timers/promises
var require_promises2 = __commonJS({
  "browser-external:timers/promises"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "timers/promises" has been externalized for browser compatibility. Cannot access "timers/promises.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@discordjs/ws/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@discordjs/ws/dist/index.js"(exports2, module2) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      CloseCodes: () => CloseCodes,
      CompressionMethod: () => CompressionMethod,
      DefaultDeviceProperty: () => DefaultDeviceProperty,
      DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
      Encoding: () => Encoding,
      ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
      SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
      SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,
      SimpleShardingStrategy: () => SimpleShardingStrategy,
      WebSocketManager: () => WebSocketManager2,
      WebSocketShard: () => WebSocketShard,
      WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
      WebSocketShardEvents: () => WebSocketShardEvents,
      WebSocketShardStatus: () => WebSocketShardStatus,
      WorkerBootstrapper: () => WorkerBootstrapper,
      WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
      WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,
      WorkerSendPayloadOp: () => WorkerSendPayloadOp,
      WorkerShardingStrategy: () => WorkerShardingStrategy,
      getInitialSendRateLimitState: () => getInitialSendRateLimitState,
      managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
      version: () => version
    });
    module2.exports = __toCommonJS2(src_exports);
    async function managerToFetchingStrategyOptions(manager) {
      const {
        buildIdentifyThrottler,
        buildStrategy,
        retrieveSessionInfo,
        updateSessionInfo,
        shardCount,
        shardIds,
        rest,
        ...managerOptions
      } = manager.options;
      return {
        ...managerOptions,
        gatewayInformation: await manager.fetchGatewayInformation(),
        shardCount: await manager.getShardCount()
      };
    }
    __name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");
    var _a;
    var SimpleContextFetchingStrategy = (_a = class {
      constructor(manager, options) {
        this.manager = manager;
        this.options = options;
      }
      static async ensureThrottler(manager) {
        const throttler = _a.throttlerCache.get(manager);
        if (throttler) {
          return throttler;
        }
        const newThrottler = await manager.options.buildIdentifyThrottler(manager);
        _a.throttlerCache.set(manager, newThrottler);
        return newThrottler;
      }
      async retrieveSessionInfo(shardId) {
        return this.manager.options.retrieveSessionInfo(shardId);
      }
      updateSessionInfo(shardId, sessionInfo) {
        return this.manager.options.updateSessionInfo(shardId, sessionInfo);
      }
      async waitForIdentify(shardId, signal) {
        const throttler = await _a.ensureThrottler(this.manager);
        await throttler.waitForIdentify(shardId, signal);
      }
    }, __name(_a, "SimpleContextFetchingStrategy"), // This strategy assumes every shard is running under the same process - therefore we need a single
    // IdentifyThrottler per manager.
    __publicField(_a, "throttlerCache", /* @__PURE__ */ new WeakMap()), _a);
    var import_node_worker_threads2 = require_worker_threads();
    var import_collection2 = require_dist9();
    var import_node_events = require_events();
    var import_node_path = require_path();
    var import_node_worker_threads = require_worker_threads();
    var import_collection = require_dist9();
    var WorkerSendPayloadOp = ((WorkerSendPayloadOp2) => {
      WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
      WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
      WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
      WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
      WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardIdentifyResponse"] = 4] = "ShardIdentifyResponse";
      WorkerSendPayloadOp2[WorkerSendPayloadOp2["FetchStatus"] = 5] = "FetchStatus";
      return WorkerSendPayloadOp2;
    })(WorkerSendPayloadOp || {});
    var WorkerReceivePayloadOp = ((WorkerReceivePayloadOp2) => {
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Connected"] = 0] = "Connected";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Destroyed"] = 1] = "Destroyed";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Event"] = 2] = "Event";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["FetchStatusResponse"] = 6] = "FetchStatusResponse";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WorkerReady"] = 7] = "WorkerReady";
      WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["CancelIdentify"] = 8] = "CancelIdentify";
      return WorkerReceivePayloadOp2;
    })(WorkerReceivePayloadOp || {});
    var _workers, _workerByShardId, _a2;
    var WorkerShardingStrategy = (_a2 = class {
      constructor(manager, options) {
        __publicField(this, "manager");
        __publicField(this, "options");
        __privateAdd(this, _workers, []);
        __privateAdd(this, _workerByShardId, new import_collection.Collection());
        __publicField(this, "connectPromises", new import_collection.Collection());
        __publicField(this, "destroyPromises", new import_collection.Collection());
        __publicField(this, "fetchStatusPromises", new import_collection.Collection());
        __publicField(this, "waitForIdentifyControllers", new import_collection.Collection());
        __publicField(this, "throttler");
        this.manager = manager;
        this.options = options;
      }
      /**
       * {@inheritDoc IShardingStrategy.spawn}
       */
      async spawn(shardIds) {
        const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
        const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
        const loops = Math.ceil(shardIds.length / shardsPerWorker);
        const promises = [];
        for (let idx = 0; idx < loops; idx++) {
          const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);
          const workerData2 = {
            ...strategyOptions,
            shardIds: slice
          };
          promises.push(this.setupWorker(workerData2));
        }
        await Promise.all(promises);
      }
      /**
       * {@inheritDoc IShardingStrategy.connect}
       */
      async connect() {
        const promises = [];
        for (const [shardId, worker] of __privateGet(this, _workerByShardId).entries()) {
          const payload = {
            op: 0,
            shardId
          };
          const promise = new Promise((resolve2) => this.connectPromises.set(shardId, resolve2));
          worker.postMessage(payload);
          promises.push(promise);
        }
        await Promise.all(promises);
      }
      /**
       * {@inheritDoc IShardingStrategy.destroy}
       */
      async destroy(options = {}) {
        const promises = [];
        for (const [shardId, worker] of __privateGet(this, _workerByShardId).entries()) {
          const payload = {
            op: 1,
            shardId,
            options
          };
          promises.push(
            // eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then
            new Promise((resolve2) => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate())
          );
          worker.postMessage(payload);
        }
        __privateSet(this, _workers, []);
        __privateGet(this, _workerByShardId).clear();
        await Promise.all(promises);
      }
      /**
       * {@inheritDoc IShardingStrategy.send}
       */
      send(shardId, data) {
        const worker = __privateGet(this, _workerByShardId).get(shardId);
        if (!worker) {
          throw new Error(`No worker found for shard ${shardId}`);
        }
        const payload = {
          op: 2,
          shardId,
          payload: data
        };
        worker.postMessage(payload);
      }
      /**
       * {@inheritDoc IShardingStrategy.fetchStatus}
       */
      async fetchStatus() {
        const statuses = new import_collection.Collection();
        for (const [shardId, worker] of __privateGet(this, _workerByShardId).entries()) {
          const nonce = Math.random();
          const payload = {
            op: 5,
            shardId,
            nonce
          };
          const promise = new Promise((resolve2) => this.fetchStatusPromises.set(nonce, resolve2));
          worker.postMessage(payload);
          const status = await promise;
          statuses.set(shardId, status);
        }
        return statuses;
      }
      async setupWorker(workerData2) {
        const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), { workerData: workerData2 });
        await (0, import_node_events.once)(worker, "online");
        await this.waitForWorkerReady(worker);
        worker.on("error", (err) => {
          throw err;
        }).on("messageerror", (err) => {
          throw err;
        }).on("message", async (payload) => this.onMessage(worker, payload));
        __privateGet(this, _workers).push(worker);
        for (const shardId of workerData2.shardIds) {
          __privateGet(this, _workerByShardId).set(shardId, worker);
        }
      }
      resolveWorkerPath() {
        const path = this.options.workerPath;
        if (!path) {
          return (0, import_node_path.join)(__dirname, "defaultWorker.js");
        }
        if ((0, import_node_path.isAbsolute)(path)) {
          return path;
        }
        if (/^\.\.?[/\\]/.test(path)) {
          return (0, import_node_path.resolve)(path);
        }
        try {
          return __require.resolve(path);
        } catch {
          return (0, import_node_path.resolve)(path);
        }
      }
      async waitForWorkerReady(worker) {
        return new Promise((resolve2) => {
          const handler = __name((payload) => {
            if (payload.op === 7) {
              resolve2();
              worker.off("message", handler);
            }
          }, "handler");
          worker.on("message", handler);
        });
      }
      async onMessage(worker, payload) {
        var _a9, _b, _c, _d;
        switch (payload.op) {
          case 0: {
            (_a9 = this.connectPromises.get(payload.shardId)) == null ? void 0 : _a9();
            this.connectPromises.delete(payload.shardId);
            break;
          }
          case 1: {
            (_b = this.destroyPromises.get(payload.shardId)) == null ? void 0 : _b();
            this.destroyPromises.delete(payload.shardId);
            break;
          }
          case 2: {
            this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
            break;
          }
          case 3: {
            const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
            const response = {
              op: 3,
              nonce: payload.nonce,
              session
            };
            worker.postMessage(response);
            break;
          }
          case 4: {
            await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
            break;
          }
          case 5: {
            const throttler = await this.ensureThrottler();
            try {
              const controller = new AbortController();
              this.waitForIdentifyControllers.set(payload.nonce, controller);
              await throttler.waitForIdentify(payload.shardId, controller.signal);
            } catch {
              return;
            }
            const response = {
              op: 4,
              nonce: payload.nonce,
              ok: true
            };
            worker.postMessage(response);
            break;
          }
          case 6: {
            (_c = this.fetchStatusPromises.get(payload.nonce)) == null ? void 0 : _c(payload.status);
            this.fetchStatusPromises.delete(payload.nonce);
            break;
          }
          case 7: {
            break;
          }
          case 8: {
            (_d = this.waitForIdentifyControllers.get(payload.nonce)) == null ? void 0 : _d.abort();
            this.waitForIdentifyControllers.delete(payload.nonce);
            const response = {
              op: 4,
              nonce: payload.nonce,
              ok: false
            };
            worker.postMessage(response);
            break;
          }
        }
      }
      async ensureThrottler() {
        this.throttler ?? (this.throttler = await this.manager.options.buildIdentifyThrottler(this.manager));
        return this.throttler;
      }
    }, _workers = new WeakMap(), _workerByShardId = new WeakMap(), __name(_a2, "WorkerShardingStrategy"), _a2);
    var _a3;
    var WorkerContextFetchingStrategy = (_a3 = class {
      constructor(options) {
        __publicField(this, "sessionPromises", new import_collection2.Collection());
        __publicField(this, "waitForIdentifyPromises", new import_collection2.Collection());
        this.options = options;
        if (import_node_worker_threads2.isMainThread) {
          throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
        }
        import_node_worker_threads2.parentPort.on("message", (payload) => {
          var _a9;
          if (payload.op === 3) {
            (_a9 = this.sessionPromises.get(payload.nonce)) == null ? void 0 : _a9(payload.session);
            this.sessionPromises.delete(payload.nonce);
          }
          if (payload.op === 4) {
            const promise = this.waitForIdentifyPromises.get(payload.nonce);
            if (payload.ok) {
              promise == null ? void 0 : promise.resolve();
            } else {
              promise == null ? void 0 : promise.reject(promise.signal.reason);
            }
            this.waitForIdentifyPromises.delete(payload.nonce);
          }
        });
      }
      async retrieveSessionInfo(shardId) {
        const nonce = Math.random();
        const payload = {
          op: 3,
          shardId,
          nonce
        };
        const promise = new Promise((resolve2) => this.sessionPromises.set(nonce, resolve2));
        import_node_worker_threads2.parentPort.postMessage(payload);
        return promise;
      }
      updateSessionInfo(shardId, sessionInfo) {
        const payload = {
          op: 4,
          shardId,
          session: sessionInfo
        };
        import_node_worker_threads2.parentPort.postMessage(payload);
      }
      async waitForIdentify(shardId, signal) {
        const nonce = Math.random();
        const payload = {
          op: 5,
          nonce,
          shardId
        };
        const promise = new Promise(
          (resolve2, reject) => (
            // eslint-disable-next-line no-promise-executor-return
            this.waitForIdentifyPromises.set(nonce, { signal, resolve: resolve2, reject })
          )
        );
        import_node_worker_threads2.parentPort.postMessage(payload);
        const listener = __name(() => {
          const payload2 = {
            op: 8,
            nonce
          };
          import_node_worker_threads2.parentPort.postMessage(payload2);
        }, "listener");
        signal.addEventListener("abort", listener);
        try {
          await promise;
        } finally {
          signal.removeEventListener("abort", listener);
        }
      }
    }, __name(_a3, "WorkerContextFetchingStrategy"), _a3);
    var import_collection6 = require_dist9();
    var import_node_buffer = require_buffer();
    var import_node_events2 = require_events();
    var import_node_timers = require_timers();
    var import_promises2 = require_promises2();
    var import_node_url = require_url();
    var import_node_util = require_util();
    var import_node_zlib = require_zlib();
    var import_collection5 = require_dist9();
    var import_util2 = require_dist();
    var import_async_queue2 = require_cjs();
    var import_async_event_emitter = require_dist4();
    var import_v102 = require_v106();
    var import_ws = require_browser();
    var import_node_process = __toESM(require_process());
    var import_collection4 = require_dist9();
    var import_util = require_dist();
    var import_v10 = require_v106();
    var import_promises = require_promises2();
    var import_collection3 = require_dist9();
    var import_async_queue = require_cjs();
    var _a4;
    var SimpleIdentifyThrottler = (_a4 = class {
      constructor(maxConcurrency) {
        __publicField(this, "states", new import_collection3.Collection());
        this.maxConcurrency = maxConcurrency;
      }
      /**
       * {@inheritDoc IIdentifyThrottler.waitForIdentify}
       */
      async waitForIdentify(shardId, signal) {
        const key = shardId % this.maxConcurrency;
        const state = this.states.ensure(key, () => {
          return {
            queue: new import_async_queue.AsyncQueue(),
            resetsAt: Number.POSITIVE_INFINITY
          };
        });
        await state.queue.wait({ signal });
        try {
          const diff = state.resetsAt - Date.now();
          if (diff <= 5e3) {
            const time = diff + Math.random() * 1500;
            await (0, import_promises.setTimeout)(time);
          }
          state.resetsAt = Date.now() + 5e3;
        } finally {
          state.queue.shift();
        }
      }
    }, __name(_a4, "SimpleIdentifyThrottler"), _a4);
    var Encoding = ((Encoding2) => {
      Encoding2["JSON"] = "json";
      return Encoding2;
    })(Encoding || {});
    var CompressionMethod = ((CompressionMethod2) => {
      CompressionMethod2["ZlibStream"] = "zlib-stream";
      return CompressionMethod2;
    })(CompressionMethod || {});
    var DefaultDeviceProperty = `@discordjs/ws 1.0.2`;
    var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection());
    var DefaultWebSocketManagerOptions = {
      async buildIdentifyThrottler(manager) {
        const info = await manager.fetchGatewayInformation();
        return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);
      },
      buildStrategy: (manager) => new SimpleShardingStrategy(manager),
      shardCount: null,
      shardIds: null,
      largeThreshold: null,
      initialPresence: null,
      identifyProperties: {
        browser: DefaultDeviceProperty,
        device: DefaultDeviceProperty,
        os: import_node_process.default.platform
      },
      version: import_v10.APIVersion,
      encoding: "json",
      compression: null,
      retrieveSessionInfo(shardId) {
        const store = getDefaultSessionStore();
        return store.get(shardId) ?? null;
      },
      updateSessionInfo(shardId, info) {
        const store = getDefaultSessionStore();
        if (info) {
          store.set(shardId, info);
        } else {
          store.delete(shardId);
        }
      },
      handshakeTimeout: 3e4,
      helloTimeout: 6e4,
      readyTimeout: 15e3
    };
    var ImportantGatewayOpcodes = /* @__PURE__ */ new Set([
      import_v10.GatewayOpcodes.Heartbeat,
      import_v10.GatewayOpcodes.Identify,
      import_v10.GatewayOpcodes.Resume
    ]);
    function getInitialSendRateLimitState() {
      return {
        remaining: 120,
        resetAt: Date.now() + 6e4
      };
    }
    __name(getInitialSendRateLimitState, "getInitialSendRateLimitState");
    var getZlibSync = (0, import_util2.lazy)(async () => import("zlib-sync").then((mod) => mod.default).catch(() => null));
    var WebSocketShardEvents = ((WebSocketShardEvents2) => {
      WebSocketShardEvents2["Closed"] = "closed";
      WebSocketShardEvents2["Debug"] = "debug";
      WebSocketShardEvents2["Dispatch"] = "dispatch";
      WebSocketShardEvents2["Error"] = "error";
      WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
      WebSocketShardEvents2["Hello"] = "hello";
      WebSocketShardEvents2["Ready"] = "ready";
      WebSocketShardEvents2["Resumed"] = "resumed";
      return WebSocketShardEvents2;
    })(WebSocketShardEvents || {});
    var WebSocketShardStatus = ((WebSocketShardStatus2) => {
      WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
      WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
      WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
      WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
      return WebSocketShardStatus2;
    })(WebSocketShardStatus || {});
    var WebSocketShardDestroyRecovery = ((WebSocketShardDestroyRecovery2) => {
      WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
      WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
      return WebSocketShardDestroyRecovery2;
    })(WebSocketShardDestroyRecovery || {});
    var CloseCodes = ((CloseCodes2) => {
      CloseCodes2[CloseCodes2["Normal"] = 1e3] = "Normal";
      CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
      return CloseCodes2;
    })(CloseCodes || {});
    var WebSocketConstructor = import_ws.WebSocket;
    var _status, _a5;
    var WebSocketShard = (_a5 = class extends import_async_event_emitter.AsyncEventEmitter {
      constructor(strategy, id) {
        super();
        __publicField(this, "connection", null);
        __publicField(this, "useIdentifyCompress", false);
        __publicField(this, "inflate", null);
        __publicField(this, "textDecoder", new import_node_util.TextDecoder());
        __publicField(this, "replayedEvents", 0);
        __publicField(this, "isAck", true);
        __publicField(this, "sendRateLimitState", getInitialSendRateLimitState());
        __publicField(this, "initialHeartbeatTimeoutController", null);
        __publicField(this, "heartbeatInterval", null);
        __publicField(this, "lastHeartbeatAt", -1);
        // Indicates whether the shard has already resolved its original connect() call
        __publicField(this, "initialConnectResolved", false);
        // Indicates if we failed to connect to the ws url (ECONNREFUSED/ECONNRESET)
        __publicField(this, "failedToConnectDueToNetworkError", false);
        __publicField(this, "sendQueue", new import_async_queue2.AsyncQueue());
        __publicField(this, "timeoutAbortControllers", new import_collection5.Collection());
        __publicField(this, "strategy");
        __publicField(this, "id");
        __privateAdd(this, _status, 0);
        this.strategy = strategy;
        this.id = id;
      }
      get status() {
        return __privateGet(this, _status);
      }
      async connect() {
        const controller = new AbortController();
        let promise;
        if (!this.initialConnectResolved) {
          promise = Promise.race([
            (0, import_node_events2.once)(this, "ready", { signal: controller.signal }),
            (0, import_node_events2.once)(this, "resumed", { signal: controller.signal })
          ]);
        }
        void this.internalConnect();
        try {
          await promise;
        } catch ({ error }) {
          throw error;
        } finally {
          controller.abort();
        }
        this.initialConnectResolved = true;
      }
      async internalConnect() {
        if (__privateGet(this, _status) !== 0) {
          throw new Error("Tried to connect a shard that wasn't idle");
        }
        const { version: version2, encoding, compression } = this.strategy.options;
        const params = new import_node_url.URLSearchParams({ v: version2, encoding });
        if (compression) {
          const zlib = await getZlibSync();
          if (zlib) {
            params.append("compress", compression);
            this.inflate = new zlib.Inflate({
              chunkSize: 65535,
              to: "string"
            });
          } else if (!this.useIdentifyCompress) {
            this.useIdentifyCompress = true;
            console.warn(
              "WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress"
            );
          }
        }
        const session = await this.strategy.retrieveSessionInfo(this.id);
        const url = `${(session == null ? void 0 : session.resumeURL) ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
        this.debug([`Connecting to ${url}`]);
        const connection = new WebSocketConstructor(url, {
          handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0
        });
        connection.binaryType = "arraybuffer";
        connection.onmessage = (event) => {
          void this.onMessage(event.data, event.data instanceof ArrayBuffer);
        };
        connection.onerror = (event) => {
          this.onError(event.error);
        };
        connection.onclose = (event) => {
          void this.onClose(event.code);
        };
        this.connection = connection;
        __privateSet(this, _status, 1);
        this.sendRateLimitState = getInitialSendRateLimitState();
        const { ok } = await this.waitForEvent("hello", this.strategy.options.helloTimeout);
        if (!ok) {
          return;
        }
        if ((session == null ? void 0 : session.shardCount) === this.strategy.options.shardCount) {
          await this.resume(session);
        } else {
          await this.identify();
        }
      }
      async destroy(options = {}) {
        if (__privateGet(this, _status) === 0) {
          this.debug(["Tried to destroy a shard that was idle"]);
          return;
        }
        if (!options.code) {
          options.code = options.recover === 1 ? 4200 : 1e3;
        }
        this.debug([
          "Destroying shard",
          `Reason: ${options.reason ?? "none"}`,
          `Code: ${options.code}`,
          `Recover: ${options.recover === void 0 ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
        ]);
        this.isAck = true;
        if (this.heartbeatInterval) {
          (0, import_node_timers.clearInterval)(this.heartbeatInterval);
        }
        if (this.initialHeartbeatTimeoutController) {
          this.initialHeartbeatTimeoutController.abort();
          this.initialHeartbeatTimeoutController = null;
        }
        this.lastHeartbeatAt = -1;
        for (const controller of this.timeoutAbortControllers.values()) {
          controller.abort();
        }
        this.timeoutAbortControllers.clear();
        this.failedToConnectDueToNetworkError = false;
        if (options.recover !== 1) {
          await this.strategy.updateSessionInfo(this.id, null);
        }
        if (this.connection) {
          this.connection.onmessage = null;
          this.connection.onclose = null;
          const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;
          this.debug([
            "Connection status during destroy",
            `Needs closing: ${shouldClose}`,
            `Ready state: ${this.connection.readyState}`
          ]);
          if (shouldClose) {
            let outerResolve;
            const promise = new Promise((resolve2) => {
              outerResolve = resolve2;
            });
            this.connection.onclose = outerResolve;
            this.connection.close(options.code, options.reason);
            await promise;
            this.emit("closed", { code: options.code });
          }
          this.connection.onerror = null;
        } else {
          this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
        }
        __privateSet(this, _status, 0);
        if (options.recover !== void 0) {
          await (0, import_promises2.setTimeout)(500);
          return this.internalConnect();
        }
      }
      async waitForEvent(event, timeoutDuration) {
        this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
        const timeoutController = new AbortController();
        const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
        this.timeoutAbortControllers.set(event, timeoutController);
        const closeController = new AbortController();
        try {
          const closed = await Promise.race([
            (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
            (0, import_node_events2.once)(this, "closed", { signal: closeController.signal }).then(() => true)
          ]);
          return { ok: !closed };
        } catch {
          void this.destroy({
            code: 1e3,
            reason: "Something timed out or went wrong while waiting for an event",
            recover: 0
            /* Reconnect */
          });
          return { ok: false };
        } finally {
          if (timeout) {
            (0, import_node_timers.clearTimeout)(timeout);
          }
          this.timeoutAbortControllers.delete(event);
          if (!closeController.signal.aborted) {
            closeController.abort();
          }
        }
      }
      async send(payload) {
        if (!this.connection) {
          throw new Error("WebSocketShard wasn't connected");
        }
        if (__privateGet(this, _status) !== 3 && !ImportantGatewayOpcodes.has(payload.op)) {
          this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
          try {
            await (0, import_node_events2.once)(
              this,
              "ready"
              /* Ready */
            );
          } catch {
            return this.send(payload);
          }
        }
        await this.sendQueue.wait();
        if (--this.sendRateLimitState.remaining <= 0) {
          const now = Date.now();
          if (this.sendRateLimitState.resetAt > now) {
            const sleepFor = this.sendRateLimitState.resetAt - now;
            this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
            const controller = new AbortController();
            const interrupted = await Promise.race([
              (0, import_promises2.setTimeout)(sleepFor).then(() => false),
              (0, import_node_events2.once)(this, "closed", { signal: controller.signal }).then(() => true)
            ]);
            if (interrupted) {
              this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
              this.sendQueue.shift();
              return this.send(payload);
            }
            controller.abort();
          }
          this.sendRateLimitState = getInitialSendRateLimitState();
        }
        this.sendQueue.shift();
        this.connection.send(JSON.stringify(payload));
      }
      async identify() {
        this.debug(["Waiting for identify throttle"]);
        const controller = new AbortController();
        const closeHandler = __name(() => {
          controller.abort();
        }, "closeHandler");
        this.on("closed", closeHandler);
        try {
          await this.strategy.waitForIdentify(this.id, controller.signal);
        } catch {
          if (controller.signal.aborted) {
            this.debug(["Was waiting for an identify, but the shard closed in the meantime"]);
            return;
          }
          this.debug([
            "IContextFetchingStrategy#waitForIdentify threw an unknown error.",
            "If you're using a custom strategy, this is probably nothing to worry about.",
            "If you're not, please open an issue on GitHub."
          ]);
          await this.destroy({
            reason: "Identify throttling logic failed",
            recover: 1
            /* Resume */
          });
        } finally {
          this.off("closed", closeHandler);
        }
        this.debug([
          "Identifying",
          `shard id: ${this.id.toString()}`,
          `shard count: ${this.strategy.options.shardCount}`,
          `intents: ${this.strategy.options.intents}`,
          `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
        ]);
        const d = {
          token: this.strategy.options.token,
          properties: this.strategy.options.identifyProperties,
          intents: this.strategy.options.intents,
          compress: this.useIdentifyCompress,
          shard: [this.id, this.strategy.options.shardCount]
        };
        if (this.strategy.options.largeThreshold) {
          d.large_threshold = this.strategy.options.largeThreshold;
        }
        if (this.strategy.options.initialPresence) {
          d.presence = this.strategy.options.initialPresence;
        }
        await this.send({
          op: import_v102.GatewayOpcodes.Identify,
          d
        });
        await this.waitForEvent("ready", this.strategy.options.readyTimeout);
      }
      async resume(session) {
        this.debug([
          "Resuming session",
          `resume url: ${session.resumeURL}`,
          `sequence: ${session.sequence}`,
          `shard id: ${this.id.toString()}`
        ]);
        __privateSet(this, _status, 2);
        this.replayedEvents = 0;
        return this.send({
          op: import_v102.GatewayOpcodes.Resume,
          d: {
            token: this.strategy.options.token,
            seq: session.sequence,
            session_id: session.sessionId
          }
        });
      }
      async heartbeat(requested = false) {
        if (!this.isAck && !requested) {
          return this.destroy({
            reason: "Zombie connection",
            recover: 1
            /* Resume */
          });
        }
        const session = await this.strategy.retrieveSessionInfo(this.id);
        await this.send({
          op: import_v102.GatewayOpcodes.Heartbeat,
          d: (session == null ? void 0 : session.sequence) ?? null
        });
        this.lastHeartbeatAt = Date.now();
        this.isAck = false;
      }
      async unpackMessage(data, isBinary) {
        if (!isBinary) {
          try {
            return JSON.parse(data);
          } catch {
            return null;
          }
        }
        const decompressable = new Uint8Array(data);
        if (this.useIdentifyCompress) {
          return new Promise((resolve2, reject) => {
            (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
              if (err) {
                reject(err);
                return;
              }
              resolve2(JSON.parse(this.textDecoder.decode(result)));
            });
          });
        }
        if (this.inflate) {
          const l = decompressable.length;
          const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
          const zlib = await getZlibSync();
          this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
          if (this.inflate.err) {
            this.emit("error", {
              error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
            });
          }
          if (!flush) {
            return null;
          }
          const { result } = this.inflate;
          if (!result) {
            return null;
          }
          return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
        }
        this.debug([
          "Received a message we were unable to decompress",
          `isBinary: ${isBinary.toString()}`,
          `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
          `inflate: ${Boolean(this.inflate).toString()}`
        ]);
        return null;
      }
      async onMessage(data, isBinary) {
        const payload = await this.unpackMessage(data, isBinary);
        if (!payload) {
          return;
        }
        switch (payload.op) {
          case import_v102.GatewayOpcodes.Dispatch: {
            if (__privateGet(this, _status) === 2) {
              this.replayedEvents++;
            }
            switch (payload.t) {
              case import_v102.GatewayDispatchEvents.Ready: {
                __privateSet(this, _status, 3);
                const session2 = {
                  sequence: payload.s,
                  sessionId: payload.d.session_id,
                  shardId: this.id,
                  shardCount: this.strategy.options.shardCount,
                  resumeURL: payload.d.resume_gateway_url
                };
                await this.strategy.updateSessionInfo(this.id, session2);
                this.emit("ready", { data: payload.d });
                break;
              }
              case import_v102.GatewayDispatchEvents.Resumed: {
                __privateSet(this, _status, 3);
                this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
                this.emit(
                  "resumed"
                  /* Resumed */
                );
                break;
              }
              default: {
                break;
              }
            }
            const session = await this.strategy.retrieveSessionInfo(this.id);
            if (session) {
              if (payload.s > session.sequence) {
                await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
              }
            } else {
              this.debug([
                `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
              ]);
            }
            this.emit("dispatch", { data: payload });
            break;
          }
          case import_v102.GatewayOpcodes.Heartbeat: {
            await this.heartbeat(true);
            break;
          }
          case import_v102.GatewayOpcodes.Reconnect: {
            await this.destroy({
              reason: "Told to reconnect by Discord",
              recover: 1
              /* Resume */
            });
            break;
          }
          case import_v102.GatewayOpcodes.InvalidSession: {
            this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
            const session = await this.strategy.retrieveSessionInfo(this.id);
            if (payload.d && session) {
              await this.resume(session);
            } else {
              await this.destroy({
                reason: "Invalid session",
                recover: 0
                /* Reconnect */
              });
            }
            break;
          }
          case import_v102.GatewayOpcodes.Hello: {
            this.emit(
              "hello"
              /* Hello */
            );
            const jitter = Math.random();
            const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);
            this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);
            try {
              const controller = new AbortController();
              this.initialHeartbeatTimeoutController = controller;
              await (0, import_promises2.setTimeout)(firstWait, void 0, { signal: controller.signal });
            } catch {
              this.debug(["Cancelled initial heartbeat due to #destroy being called"]);
              return;
            } finally {
              this.initialHeartbeatTimeoutController = null;
            }
            await this.heartbeat();
            this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);
            this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
            break;
          }
          case import_v102.GatewayOpcodes.HeartbeatAck: {
            this.isAck = true;
            const ackAt = Date.now();
            this.emit("heartbeat", {
              ackAt,
              heartbeatAt: this.lastHeartbeatAt,
              latency: ackAt - this.lastHeartbeatAt
            });
            break;
          }
        }
      }
      onError(error) {
        if ("code" in error && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
          this.debug(["Failed to connect to the gateway URL specified due to a network error"]);
          this.failedToConnectDueToNetworkError = true;
          return;
        }
        this.emit("error", { error });
      }
      async onClose(code) {
        this.emit("closed", { code });
        switch (code) {
          case 1e3: {
            return this.destroy({
              code,
              reason: "Got disconnected by Discord",
              recover: 0
              /* Reconnect */
            });
          }
          case 4200: {
            break;
          }
          case import_v102.GatewayCloseCodes.UnknownError: {
            this.debug([`An unknown error occurred: ${code}`]);
            return this.destroy({
              code,
              recover: 1
              /* Resume */
            });
          }
          case import_v102.GatewayCloseCodes.UnknownOpcode: {
            this.debug(["An invalid opcode was sent to Discord."]);
            return this.destroy({
              code,
              recover: 1
              /* Resume */
            });
          }
          case import_v102.GatewayCloseCodes.DecodeError: {
            this.debug(["An invalid payload was sent to Discord."]);
            return this.destroy({
              code,
              recover: 1
              /* Resume */
            });
          }
          case import_v102.GatewayCloseCodes.NotAuthenticated: {
            this.debug(["A request was somehow sent before the identify/resume payload."]);
            return this.destroy({
              code,
              recover: 0
              /* Reconnect */
            });
          }
          case import_v102.GatewayCloseCodes.AuthenticationFailed: {
            this.emit("error", {
              error: new Error("Authentication failed")
            });
            return this.destroy({ code });
          }
          case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
            this.debug(["More than one auth payload was sent."]);
            return this.destroy({
              code,
              recover: 0
              /* Reconnect */
            });
          }
          case import_v102.GatewayCloseCodes.InvalidSeq: {
            this.debug(["An invalid sequence was sent."]);
            return this.destroy({
              code,
              recover: 0
              /* Reconnect */
            });
          }
          case import_v102.GatewayCloseCodes.RateLimited: {
            this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
            return this.destroy({
              code,
              recover: 0
              /* Reconnect */
            });
          }
          case import_v102.GatewayCloseCodes.SessionTimedOut: {
            this.debug(["Session timed out."]);
            return this.destroy({
              code,
              recover: 1
              /* Resume */
            });
          }
          case import_v102.GatewayCloseCodes.InvalidShard: {
            this.emit("error", {
              error: new Error("Invalid shard")
            });
            return this.destroy({ code });
          }
          case import_v102.GatewayCloseCodes.ShardingRequired: {
            this.emit("error", {
              error: new Error("Sharding is required")
            });
            return this.destroy({ code });
          }
          case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
            this.emit("error", {
              error: new Error("Used an invalid API version")
            });
            return this.destroy({ code });
          }
          case import_v102.GatewayCloseCodes.InvalidIntents: {
            this.emit("error", {
              error: new Error("Used invalid intents")
            });
            return this.destroy({ code });
          }
          case import_v102.GatewayCloseCodes.DisallowedIntents: {
            this.emit("error", {
              error: new Error("Used disallowed intents")
            });
            return this.destroy({ code });
          }
          default: {
            this.debug([
              `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
            ]);
            return this.destroy({
              code,
              recover: this.failedToConnectDueToNetworkError ? 0 : 1
              /* Resume */
            });
          }
        }
      }
      debug(messages) {
        const message = `${messages[0]}${messages.length > 1 ? `
${messages.slice(1).map((m) => `	${m}`).join("\n")}` : ""}`;
        this.emit("debug", { message });
      }
    }, _status = new WeakMap(), __name(_a5, "WebSocketShard"), _a5);
    var _a6;
    var SimpleShardingStrategy = (_a6 = class {
      constructor(manager) {
        __publicField(this, "manager");
        __publicField(this, "shards", new import_collection6.Collection());
        this.manager = manager;
      }
      /**
       * {@inheritDoc IShardingStrategy.spawn}
       */
      async spawn(shardIds) {
        const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
        for (const shardId of shardIds) {
          const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
          const shard = new WebSocketShard(strategy, shardId);
          for (const event of Object.values(WebSocketShardEvents)) {
            shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
          }
          this.shards.set(shardId, shard);
        }
      }
      /**
       * {@inheritDoc IShardingStrategy.connect}
       */
      async connect() {
        const promises = [];
        for (const shard of this.shards.values()) {
          promises.push(shard.connect());
        }
        await Promise.all(promises);
      }
      /**
       * {@inheritDoc IShardingStrategy.destroy}
       */
      async destroy(options) {
        const promises = [];
        for (const shard of this.shards.values()) {
          promises.push(shard.destroy(options));
        }
        await Promise.all(promises);
        this.shards.clear();
      }
      /**
       * {@inheritDoc IShardingStrategy.send}
       */
      async send(shardId, payload) {
        const shard = this.shards.get(shardId);
        if (!shard) {
          throw new RangeError(`Shard ${shardId} not found`);
        }
        return shard.send(payload);
      }
      /**
       * {@inheritDoc IShardingStrategy.fetchStatus}
       */
      async fetchStatus() {
        return this.shards.mapValues((shard) => shard.status);
      }
    }, __name(_a6, "SimpleShardingStrategy"), _a6);
    var import_node_worker_threads3 = require_worker_threads();
    var import_collection7 = require_dist9();
    var _a7;
    var WorkerBootstrapper = (_a7 = class {
      constructor() {
        /**
         * The data passed to the worker thread
         */
        __publicField(this, "data", import_node_worker_threads3.workerData);
        /**
         * The shards that are managed by this worker
         */
        __publicField(this, "shards", new import_collection7.Collection());
        if (import_node_worker_threads3.isMainThread) {
          throw new Error("Expected WorkerBootstrap to not be used within the main thread");
        }
      }
      /**
       * Helper method to initiate a shard's connection process
       */
      async connect(shardId) {
        const shard = this.shards.get(shardId);
        if (!shard) {
          throw new RangeError(`Shard ${shardId} does not exist`);
        }
        await shard.connect();
      }
      /**
       * Helper method to destroy a shard
       */
      async destroy(shardId, options) {
        const shard = this.shards.get(shardId);
        if (!shard) {
          throw new RangeError(`Shard ${shardId} does not exist`);
        }
        await shard.destroy(options);
      }
      /**
       * Helper method to attach event listeners to the parentPort
       */
      setupThreadEvents() {
        import_node_worker_threads3.parentPort.on("messageerror", (err) => {
          throw err;
        }).on("message", async (payload) => {
          switch (payload.op) {
            case 0: {
              await this.connect(payload.shardId);
              const response = {
                op: 0,
                shardId: payload.shardId
              };
              import_node_worker_threads3.parentPort.postMessage(response);
              break;
            }
            case 1: {
              await this.destroy(payload.shardId, payload.options);
              const response = {
                op: 1,
                shardId: payload.shardId
              };
              import_node_worker_threads3.parentPort.postMessage(response);
              break;
            }
            case 2: {
              const shard = this.shards.get(payload.shardId);
              if (!shard) {
                throw new RangeError(`Shard ${payload.shardId} does not exist`);
              }
              await shard.send(payload.payload);
              break;
            }
            case 3: {
              break;
            }
            case 4: {
              break;
            }
            case 5: {
              const shard = this.shards.get(payload.shardId);
              if (!shard) {
                throw new Error(`Shard ${payload.shardId} does not exist`);
              }
              const response = {
                op: 6,
                status: shard.status,
                nonce: payload.nonce
              };
              import_node_worker_threads3.parentPort.postMessage(response);
              break;
            }
          }
        });
      }
      /**
       * Bootstraps the worker thread with the provided options
       */
      async bootstrap(options = {}) {
        var _a9;
        for (const shardId of this.data.shardIds) {
          const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);
          for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {
            shard.on(event, (data) => {
              const payload = {
                op: 2,
                event,
                data,
                shardId
              };
              import_node_worker_threads3.parentPort.postMessage(payload);
            });
          }
          await ((_a9 = options.shardCallback) == null ? void 0 : _a9.call(options, shard));
          this.shards.set(shardId, shard);
        }
        this.setupThreadEvents();
        const message = {
          op: 7
          /* WorkerReady */
        };
        import_node_worker_threads3.parentPort.postMessage(message);
      }
    }, __name(_a7, "WorkerBootstrapper"), _a7);
    var import_util3 = require_dist();
    var import_async_event_emitter2 = require_dist4();
    var import_v103 = require_v106();
    var _a8;
    var WebSocketManager2 = (_a8 = class extends import_async_event_emitter2.AsyncEventEmitter {
      constructor(options) {
        super();
        /**
         * The options being used by this manager
         */
        __publicField(this, "options");
        /**
         * Internal cache for a GET /gateway/bot result
         */
        __publicField(this, "gatewayInformation", null);
        /**
         * Internal cache for the shard ids
         */
        __publicField(this, "shardIds", null);
        /**
         * Strategy used to manage shards
         *
         * @defaultValue `SimpleShardingStrategy`
         */
        __publicField(this, "strategy");
        this.options = { ...DefaultWebSocketManagerOptions, ...options };
        this.strategy = this.options.buildStrategy(this);
      }
      /**
       * Fetches the gateway information from Discord - or returns it from cache if available
       *
       * @param force - Whether to ignore the cache and force a fresh fetch
       */
      async fetchGatewayInformation(force = false) {
        if (this.gatewayInformation) {
          if (this.gatewayInformation.expiresAt <= Date.now()) {
            this.gatewayInformation = null;
          } else if (!force) {
            return this.gatewayInformation.data;
          }
        }
        const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
        this.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5e3) };
        return this.gatewayInformation.data;
      }
      /**
       * Updates your total shard count on-the-fly, spawning shards as needed
       *
       * @param shardCount - The new shard count to use
       */
      async updateShardCount(shardCount) {
        await this.strategy.destroy({ reason: "User is adjusting their shards" });
        this.options.shardCount = shardCount;
        const shardIds = await this.getShardIds(true);
        await this.strategy.spawn(shardIds);
        return this;
      }
      /**
       * Yields the total number of shards across for your bot, accounting for Discord recommendations
       */
      async getShardCount() {
        if (this.options.shardCount) {
          return this.options.shardCount;
        }
        const shardIds = await this.getShardIds();
        return Math.max(...shardIds) + 1;
      }
      /**
       * Yields the ids of the shards this manager should manage
       */
      async getShardIds(force = false) {
        if (this.shardIds && !force) {
          return this.shardIds;
        }
        let shardIds;
        if (this.options.shardIds) {
          if (Array.isArray(this.options.shardIds)) {
            shardIds = this.options.shardIds;
          } else {
            const { start, end } = this.options.shardIds;
            shardIds = [...(0, import_util3.range)({ start, end: end + 1 })];
          }
        } else {
          const data = await this.fetchGatewayInformation();
          shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];
        }
        this.shardIds = shardIds;
        return shardIds;
      }
      async connect() {
        const shardCount = await this.getShardCount();
        await this.updateShardCount(shardCount);
        const shardIds = await this.getShardIds();
        const data = await this.fetchGatewayInformation();
        if (data.session_start_limit.remaining < shardIds.length) {
          throw new Error(
            `Not enough sessions remaining to spawn ${shardIds.length} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`
          );
        }
        await this.strategy.connect();
      }
      destroy(options) {
        return this.strategy.destroy(options);
      }
      send(shardId, payload) {
        return this.strategy.send(shardId, payload);
      }
      fetchStatus() {
        return this.strategy.fetchStatus();
      }
    }, __name(_a8, "WebSocketManager"), _a8);
    var version = "1.0.2";
  }
});

// node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS({
  "node_modules/discord.js/src/util/WebSocketShardEvents.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Close: "close",
      Destroyed: "destroyed",
      InvalidSession: "invalidSession",
      Ready: "ready",
      Resumed: "resumed",
      AllReady: "allReady"
    };
  }
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS({
  "node_modules/discord.js/src/client/websocket/WebSocketShard.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var process2 = require_node_process();
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require_node_timers();
    var { GatewayIntentBits } = require_v106();
    var Status2 = require_Status();
    var WebSocketShardEvents = require_WebSocketShardEvents();
    var deprecationEmittedForImportant = false;
    var WebSocketShard = class extends EventEmitter {
      constructor(manager, id) {
        super();
        this.manager = manager;
        this.id = id;
        this.status = Status2.Idle;
        this.closeSequence = 0;
        this.ping = -1;
        this.lastPingTimestamp = -1;
        Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
        Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
        Object.defineProperty(this, "sessionInfo", { value: null, writable: true });
      }
      /**
       * Emits a debug event.
       * @param {string} message The debug message
       * @private
       */
      debug(message) {
        this.manager.debug(message, this.id);
      }
      /**
       * @external CloseEvent
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}
       */
      /**
       * This method is responsible to emit close event for this shard.
       * This method helps the shard reconnect.
       * @param {CloseEvent} [event] Close event that was received
       * @deprecated
       */
      emitClose(event = {
        code: 1011,
        reason: "INTERNAL_ERROR",
        wasClean: false
      }) {
        this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason ?? "No reason received"}`);
        this.emit(WebSocketShardEvents.Close, event);
      }
      /**
       * Called when the shard receives the READY payload.
       * @param {Object} packet The received packet
       * @private
       */
      onReadyPacket(packet) {
        if (!packet) {
          this.debug(`Received broken packet: '${packet}'.`);
          return;
        }
        this.emit(WebSocketShardEvents.Ready);
        this.expectedGuilds = new Set(packet.guilds.map((guild) => guild.id));
        this.status = Status2.WaitingForGuilds;
      }
      /**
       * Called when a GuildCreate or GuildDelete for this shard was sent after READY payload was received,
       * but before we emitted the READY event.
       * @param {Snowflake} guildId the id of the Guild sent in the payload
       * @private
       */
      gotGuild(guildId) {
        this.expectedGuilds.delete(guildId);
        this.checkReady();
      }
      /**
       * Checks if the shard can be marked as ready
       * @private
       */
      checkReady() {
        if (this.readyTimeout) {
          clearTimeout2(this.readyTimeout);
          this.readyTimeout = null;
        }
        if (!this.expectedGuilds.size) {
          this.debug("Shard received all its guilds. Marking as fully ready.");
          this.status = Status2.Ready;
          this.emit(WebSocketShardEvents.AllReady);
          return;
        }
        const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
        const { waitGuildTimeout } = this.manager.client.options;
        this.readyTimeout = setTimeout2(
          () => {
            this.debug(
              `Shard ${hasGuildsIntent ? "did" : "will"} not receive any more guild packets${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ""}.
Unavailable guild count: ${this.expectedGuilds.size}`
            );
            this.readyTimeout = null;
            this.status = Status2.Ready;
            this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
          },
          hasGuildsIntent ? waitGuildTimeout : 0
        ).unref();
      }
      /**
       * Adds a packet to the queue to be sent to the gateway.
       * <warn>If you use this method, make sure you understand that you need to provide
       * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).
       * Do not use this method if you don't know what you're doing.</warn>
       * @param {Object} data The full packet to send
       * @param {boolean} [important=false] If this packet should be added first in queue
       * <warn>This parameter is **deprecated**. Important payloads are determined by their opcode instead.</warn>
       */
      send(data, important = false) {
        if (important && !deprecationEmittedForImportant) {
          process2.emitWarning(
            "Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.",
            "DeprecationWarning"
          );
          deprecationEmittedForImportant = true;
        }
        this.manager._ws.send(this.id, data);
      }
    };
    module2.exports = WebSocketShard;
  }
});

// node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationActionExecution.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.AutoModerationRuleUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    module2.exports = (client, { d: data }) => {
      const channel = client.channels.cache.get(data.channel_id);
      const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      if (channel) {
        channel.lastPinTimestamp = time;
        client.emit(Events2.ChannelPinsUpdate, channel, time);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events2.ChannelUpdate, old, updated);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildAuditLogEntryCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanAdd.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanRemove.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    var Status2 = require_Status();
    module2.exports = (client, { d: data }, shard) => {
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (!guild.available && !data.unavailable) {
          guild._patch(data);
          client.emit(Events2.GuildAvailable, guild);
        }
      } else {
        data.shardId = shard.id;
        guild = client.guilds._add(data);
        if (client.ws.status === Status2.Ready) {
          client.emit(Events2.GuildCreate, guild);
        }
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildEmojisUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildIntegrationsUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Events2 = require_Events();
    module2.exports = (client, { d: data }) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const members = new Collection2();
      for (const member of data.members)
        members.set(member.user.id, guild.members._add(member));
      if (data.presences) {
        for (const presence of data.presences)
          guild.presences._add(Object.assign(presence, { guild }));
      }
      client.emit(Events2.GuildMembersChunk, members, guild, {
        index: data.chunk_index,
        count: data.chunk_count,
        notFound: data.not_found,
        nonce: data.nonce
      });
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    var Status2 = require_Status();
    module2.exports = (client, { d: data }, shard) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        guild.memberCount++;
        const member = guild.members._add(data);
        if (shard.status === Status2.Ready) {
          client.emit(Events2.GuildMemberAdd, member);
        }
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberRemove.handle(packet.d, shard);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberUpdate.handle(packet.d, shard);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserAdd.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserRemove.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildStickersUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InteractionCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDeleteBulk.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionAdd.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemove.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveAll.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveEmoji.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events2.MessageUpdate, old, updated);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.PresenceUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS({
  "node_modules/discord.js/src/structures/ClientUser.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var User = require_User();
    var DataResolver2 = require_DataResolver();
    var ClientUser = class extends User {
      _patch(data) {
        super._patch(data);
        if ("verified" in data) {
          this.verified = data.verified;
        }
        if ("mfa_enabled" in data) {
          this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
        } else {
          this.mfaEnabled ?? (this.mfaEnabled = null);
        }
        if ("token" in data)
          this.client.token = data.token;
      }
      /**
       * Represents the client user's presence
       * @type {ClientPresence}
       * @readonly
       */
      get presence() {
        return this.client.presence;
      }
      /**
       * Data used to edit the logged in client
       * @typedef {Object} ClientUserEditOptions
       * @property {string} [username] The new username
       * @property {?(BufferResolvable|Base64Resolvable)} [avatar] The new avatar
       */
      /**
       * Edits the logged in client.
       * @param {ClientUserEditOptions} options The options to provide
       * @returns {Promise<ClientUser>}
       */
      async edit({ username, avatar }) {
        const data = await this.client.rest.patch(Routes2.user(), {
          body: { username, avatar: avatar && await DataResolver2.resolveImage(avatar) }
        });
        this.client.token = data.token;
        this.client.rest.setToken(data.token);
        const { updated } = this.client.actions.UserUpdate.handle(data);
        return updated ?? this;
      }
      /**
       * Sets the username of the logged in client.
       * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests
       * every hour. Use this sparingly!</info>
       * @param {string} username The new username
       * @returns {Promise<ClientUser>}
       * @example
       * // Set username
       * client.user.setUsername('discordjs')
       *   .then(user => console.log(`My new username is ${user.username}`))
       *   .catch(console.error);
       */
      setUsername(username) {
        return this.edit({ username });
      }
      /**
       * Sets the avatar of the logged in client.
       * @param {?(BufferResolvable|Base64Resolvable)} avatar The new avatar
       * @returns {Promise<ClientUser>}
       * @example
       * // Set avatar
       * client.user.setAvatar('./avatar.png')
       *   .then(user => console.log(`New avatar set!`))
       *   .catch(console.error);
       */
      setAvatar(avatar) {
        return this.edit({ avatar });
      }
      /**
       * Options for setting activities
       * @typedef {Object} ActivitiesOptions
       * @property {string} name Name of the activity
       * @property {string} [state] State of the activity
       * @property {ActivityType} [type] Type of the activity
       * @property {string} [url] Twitch / YouTube stream URL
       */
      /**
       * Data resembling a raw Discord presence.
       * @typedef {Object} PresenceData
       * @property {PresenceStatusData} [status] Status of the user
       * @property {boolean} [afk] Whether the user is AFK
       * @property {ActivitiesOptions[]} [activities] Activity the user is playing
       * @property {number|number[]} [shardId] Shard id(s) to have the activity set on
       */
      /**
       * Sets the full presence of the client user.
       * @param {PresenceData} data Data for the presence
       * @returns {ClientPresence}
       * @example
       * // Set the client user's presence
       * client.user.setPresence({ activities: [{ name: 'with discord.js' }], status: 'idle' });
       */
      setPresence(data) {
        return this.client.presence.set(data);
      }
      /**
       * A user's status. Must be one of:
       * * `online`
       * * `idle`
       * * `invisible`
       * * `dnd` (do not disturb)
       * @typedef {string} PresenceStatusData
       */
      /**
       * Sets the status of the client user.
       * @param {PresenceStatusData} status Status to change to
       * @param {number|number[]} [shardId] Shard id(s) to have the activity set on
       * @returns {ClientPresence}
       * @example
       * // Set the client user's status
       * client.user.setStatus('idle');
       */
      setStatus(status, shardId) {
        return this.setPresence({ status, shardId });
      }
      /**
       * Options for setting an activity.
       * @typedef {Object} ActivityOptions
       * @property {string} name Name of the activity
       * @property {string} [state] State of the activity
       * @property {string} [url] Twitch / YouTube stream URL
       * @property {ActivityType} [type] Type of the activity
       * @property {number|number[]} [shardId] Shard Id(s) to have the activity set on
       */
      /**
       * Sets the activity the client user is playing.
       * @param {string|ActivityOptions} name Activity being played, or options for setting the activity
       * @param {ActivityOptions} [options] Options for setting the activity
       * @returns {ClientPresence}
       * @example
       * // Set the client user's activity
       * client.user.setActivity('discord.js', { type: ActivityType.Watching });
       */
      setActivity(name, options = {}) {
        if (!name)
          return this.setPresence({ activities: [], shardId: options.shardId });
        const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
        return this.setPresence({ activities: [activity], shardId: activity.shardId });
      }
      /**
       * Sets/removes the AFK flag for the client user.
       * @param {boolean} [afk=true] Whether or not the user is AFK
       * @param {number|number[]} [shardId] Shard Id(s) to have the AFK flag set on
       * @returns {ClientPresence}
       */
      setAFK(afk = true, shardId) {
        return this.setPresence({ afk, shardId });
      }
    };
    module2.exports = ClientUser;
  }
});

// node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/READY.js"(exports2, module2) {
    "use strict";
    var ClientApplication = require_ClientApplication();
    var ClientUser;
    module2.exports = (client, { d: data }, shard) => {
      if (client.user) {
        client.user._patch(data.user);
      } else {
        ClientUser ?? (ClientUser = require_ClientUser());
        client.user = new ClientUser(client, data.user);
        client.users.cache.set(client.user.id, client.user);
      }
      for (const guild of data.guilds) {
        guild.shardId = shard.id;
        client.guilds._add(guild);
      }
      if (client.application) {
        client.application._patch(data.application);
      } else {
        client.application = new ClientApplication(client, data.application);
      }
      shard.checkReady();
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/RESUMED.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    module2.exports = (client, packet, shard) => {
      const replayed = shard.sessionInfo.sequence - shard.closeSequence;
      client.emit(Events2.ShardResume, shard.id, replayed);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadCreate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadDelete.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadListSync.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMembersUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMemberUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events2 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events2.ThreadUpdate, old, updated);
      }
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.TypingStart.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.UserUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
      client.voice.onVoiceServer(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.VoiceStateUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.WebhooksUpdate.handle(packet.d);
    };
  }
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/discord.js/src/client/websocket/handlers/index.js"(exports2, module2) {
    "use strict";
    var handlers = Object.fromEntries([
      ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
      ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
      ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
      ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
      ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
      ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
      ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
      ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
      ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
      ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
      ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
      ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
      ["GUILD_CREATE", require_GUILD_CREATE()],
      ["GUILD_DELETE", require_GUILD_DELETE()],
      ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
      ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
      ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
      ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
      ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
      ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
      ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
      ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
      ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
      ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
      ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
      ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
      ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
      ["GUILD_UPDATE", require_GUILD_UPDATE()],
      ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
      ["INVITE_CREATE", require_INVITE_CREATE()],
      ["INVITE_DELETE", require_INVITE_DELETE()],
      ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
      ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
      ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
      ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
      ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
      ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
      ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
      ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
      ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
      ["READY", require_READY()],
      ["RESUMED", require_RESUMED()],
      ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
      ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
      ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
      ["THREAD_CREATE", require_THREAD_CREATE()],
      ["THREAD_DELETE", require_THREAD_DELETE()],
      ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
      ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
      ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
      ["THREAD_UPDATE", require_THREAD_UPDATE()],
      ["TYPING_START", require_TYPING_START()],
      ["USER_UPDATE", require_USER_UPDATE()],
      ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
      ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
      ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
    ]);
    module2.exports = handlers;
  }
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS({
  "node_modules/discord.js/src/client/websocket/WebSocketManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var process2 = require_node_process();
    var { setImmediate: setImmediate2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist6();
    var {
      WebSocketManager: WSWebSocketManager,
      WebSocketShardEvents: WSWebSocketShardEvents,
      CompressionMethod,
      CloseCodes
    } = require_dist10();
    var { GatewayCloseCodes, GatewayDispatchEvents } = require_v106();
    var WebSocketShard = require_WebSocketShard();
    var PacketHandlers = require_handlers();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Events2 = require_Events();
    var Status2 = require_Status();
    var WebSocketShardEvents = require_WebSocketShardEvents();
    var zlib;
    try {
      zlib = __require("zlib-sync");
    } catch {
    }
    var BeforeReadyWhitelist = [
      GatewayDispatchEvents.Ready,
      GatewayDispatchEvents.Resumed,
      GatewayDispatchEvents.GuildCreate,
      GatewayDispatchEvents.GuildDelete,
      GatewayDispatchEvents.GuildMembersChunk,
      GatewayDispatchEvents.GuildMemberAdd,
      GatewayDispatchEvents.GuildMemberRemove
    ];
    var WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];
    var UNRESUMABLE_CLOSE_CODES = [
      CloseCodes.Normal,
      GatewayCloseCodes.AlreadyAuthenticated,
      GatewayCloseCodes.InvalidSeq
    ];
    var reasonIsDeprecated = "the reason property is deprecated, use the code property to determine the reason";
    var deprecationEmittedForInvalidSessionEvent = false;
    var deprecationEmittedForDestroyedEvent = false;
    var WebSocketManager2 = class extends EventEmitter {
      constructor(client) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.gateway = null;
        this.shards = new Collection2();
        Object.defineProperty(this, "packetQueue", { value: [] });
        this.status = Status2.Idle;
        this.destroyed = false;
        this._ws = null;
      }
      /**
       * The average ping of all WebSocketShards
       * @type {number}
       * @readonly
       */
      get ping() {
        const sum = this.shards.reduce((a, b) => a + b.ping, 0);
        return sum / this.shards.size;
      }
      /**
       * Emits a debug message.
       * @param {string} message The debug message
       * @param {?number} [shardId] The id of the shard that emitted this message, if any
       * @private
       */
      debug(message, shardId) {
        this.client.emit(
          Events2.Debug,
          `[WS => ${typeof shardId === "number" ? `Shard ${shardId}` : "Manager"}] ${message}`
        );
      }
      /**
       * Connects this manager to the gateway.
       * @private
       */
      async connect() {
        const invalidToken = new DiscordjsError2(ErrorCodes2.TokenInvalid);
        const { shards, shardCount, intents, ws } = this.client.options;
        if (this._ws && this._ws.options.token !== this.client.token) {
          await this._ws.destroy({ code: CloseCodes.Normal, reason: "Login with differing token requested" });
          this._ws = null;
        }
        if (!this._ws) {
          const wsOptions = {
            intents: intents.bitfield,
            rest: this.client.rest,
            token: this.client.token,
            largeThreshold: ws.large_threshold,
            version: ws.version,
            shardIds: shards === "auto" ? null : shards,
            shardCount: shards === "auto" ? null : shardCount,
            initialPresence: ws.presence,
            retrieveSessionInfo: (shardId) => this.shards.get(shardId).sessionInfo,
            updateSessionInfo: (shardId, sessionInfo) => {
              this.shards.get(shardId).sessionInfo = sessionInfo;
            },
            compression: zlib ? CompressionMethod.ZlibStream : null
          };
          if (ws.buildIdentifyThrottler)
            wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;
          if (ws.buildStrategy)
            wsOptions.buildStrategy = ws.buildStrategy;
          this._ws = new WSWebSocketManager(wsOptions);
          this.attachEvents();
        }
        const {
          url: gatewayURL,
          shards: recommendedShards,
          session_start_limit: sessionStartLimit
        } = await this._ws.fetchGatewayInformation().catch((error) => {
          throw error.status === 401 ? invalidToken : error;
        });
        const { total, remaining } = sessionStartLimit;
        this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
        this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
        this.gateway = `${gatewayURL}/`;
        this.client.options.shardCount = await this._ws.getShardCount();
        this.client.options.shards = await this._ws.getShardIds();
        this.totalShards = this.client.options.shards.length;
        for (const id of this.client.options.shards) {
          if (!this.shards.has(id)) {
            const shard = new WebSocketShard(this, id);
            this.shards.set(id, shard);
            shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
              this.client.emit(Events2.ShardReady, shard.id, unavailableGuilds);
              this.checkShardsReady();
            });
            shard.status = Status2.Connecting;
          }
        }
        await this._ws.connect();
        this.shards.forEach((shard) => {
          if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
            process2.emitWarning(
              "The WebSocketShard#invalidSession event is deprecated and will never emit.",
              "DeprecationWarning"
            );
            deprecationEmittedForInvalidSessionEvent = true;
          }
          if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
            process2.emitWarning(
              "The WebSocketShard#destroyed event is deprecated and will never emit.",
              "DeprecationWarning"
            );
            deprecationEmittedForDestroyedEvent = true;
          }
        });
      }
      /**
       * Attaches event handlers to the internal WebSocketShardManager from `@discordjs/ws`.
       * @private
       */
      attachEvents() {
        this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug(message, shardId));
        this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
          this.client.emit(Events2.Raw, data, shardId);
          this.emit(data.t, data.d, shardId);
          const shard = this.shards.get(shardId);
          this.handlePacket(data, shard);
          if (shard.status === Status2.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
            shard.gotGuild(data.d.id);
          }
        });
        this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
          this.shards.get(shardId).onReadyPacket(data);
        });
        this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
          const shard = this.shards.get(shardId);
          shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
          if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {
            shard.status = Status2.Disconnected;
            this.client.emit(Events2.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
            this.debug(`Shard not resumable: ${code} (${GatewayCloseCodes[code] ?? CloseCodes[code]})`, shardId);
            return;
          }
          this.shards.get(shardId).status = Status2.Connecting;
          this.client.emit(Events2.ShardReconnecting, shardId);
        });
        this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
          const shard = this.shards.get(shardId);
          if (shard.sessionInfo) {
            shard.closeSequence = shard.sessionInfo.sequence;
            shard.status = Status2.Resuming;
          } else {
            shard.status = Status2.Identifying;
          }
        });
        this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
          const shard = this.shards.get(shardId);
          shard.status = Status2.Ready;
          shard.emit(WebSocketShardEvents.Resumed);
        });
        this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
          this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);
          const shard = this.shards.get(shardId);
          shard.lastPingTimestamp = heartbeatAt;
          shard.ping = latency;
        });
        this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {
          this.client.emit(Events2.ShardError, error, shardId);
        });
      }
      /**
       * Broadcasts a packet to every shard this manager handles.
       * @param {Object} packet The packet to send
       * @private
       */
      broadcast(packet) {
        for (const shardId of this.shards.keys())
          this._ws.send(shardId, packet);
      }
      /**
       * Destroys this manager and all its shards.
       * @private
       */
      async destroy() {
        var _a;
        if (this.destroyed)
          return;
        this.debug(Object.assign(new Error(), { name: "Manager was destroyed:" }).stack);
        this.destroyed = true;
        await ((_a = this._ws) == null ? void 0 : _a.destroy({ code: CloseCodes.Normal, reason: "Manager was destroyed" }));
      }
      /**
       * Processes a packet and queues it if this WebSocketManager is not ready.
       * @param {Object} [packet] The packet to be handled
       * @param {WebSocketShard} [shard] The shard that will handle this packet
       * @returns {boolean}
       * @private
       */
      handlePacket(packet, shard) {
        if (packet && this.status !== Status2.Ready) {
          if (!BeforeReadyWhitelist.includes(packet.t)) {
            this.packetQueue.push({ packet, shard });
            return false;
          }
        }
        if (this.packetQueue.length) {
          const item = this.packetQueue.shift();
          setImmediate2(() => {
            this.handlePacket(item.packet, item.shard);
          }).unref();
        }
        if (packet && PacketHandlers[packet.t]) {
          PacketHandlers[packet.t](this.client, packet, shard);
        }
        return true;
      }
      /**
       * Checks whether the client is ready to be marked as ready.
       * @private
       */
      checkShardsReady() {
        if (this.status === Status2.Ready)
          return;
        if (this.shards.size !== this.totalShards || this.shards.some((shard) => shard.status !== Status2.Ready)) {
          return;
        }
        this.triggerClientReady();
      }
      /**
       * Causes the client to be marked as ready and emits the ready event.
       * @private
       */
      triggerClientReady() {
        this.status = Status2.Ready;
        this.client.readyTimestamp = Date.now();
        this.client.emit(Events2.ClientReady, this.client);
        this.handlePacket();
      }
    };
    module2.exports = WebSocketManager2;
  }
});

// node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS({
  "node_modules/discord.js/src/managers/BaseGuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var { parseEmoji } = require_Util();
    var BaseGuildEmojiManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, GuildEmoji, iterable);
      }
      /**
       * The cache of GuildEmojis
       * @type {Collection<Snowflake, GuildEmoji>}
       * @name BaseGuildEmojiManager#cache
       */
      /**
       * Data that can be resolved into a GuildEmoji object. This can be:
       * * A Snowflake
       * * A GuildEmoji object
       * * A ReactionEmoji object
       * @typedef {Snowflake|GuildEmoji|ReactionEmoji} EmojiResolvable
       */
      /**
       * Resolves an EmojiResolvable to an Emoji object.
       * @param {EmojiResolvable} emoji The Emoji resolvable to identify
       * @returns {?GuildEmoji}
       */
      resolve(emoji) {
        if (emoji instanceof ReactionEmoji)
          return super.resolve(emoji.id);
        return super.resolve(emoji);
      }
      /**
       * Resolves an EmojiResolvable to an Emoji id string.
       * @param {EmojiResolvable} emoji The Emoji resolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(emoji) {
        if (emoji instanceof ReactionEmoji)
          return emoji.id;
        return super.resolveId(emoji);
      }
      /**
       * Data that can be resolved to give an emoji identifier. This can be:
       * * An EmojiResolvable
       * * The `<a:name:id>`, `<:name:id>`, `a:name:id` or `name:id` emoji identifier string of an emoji
       * * The Unicode representation of an emoji
       * @typedef {string|EmojiResolvable} EmojiIdentifierResolvable
       */
      /**
       * Resolves an EmojiResolvable to an emoji identifier.
       * @param {EmojiIdentifierResolvable} emoji The emoji resolvable to resolve
       * @returns {?string}
       */
      resolveIdentifier(emoji) {
        const emojiResolvable = this.resolve(emoji);
        if (emojiResolvable)
          return emojiResolvable.identifier;
        if (emoji instanceof ReactionEmoji)
          return emoji.identifier;
        if (typeof emoji === "string") {
          const res = parseEmoji(emoji);
          if (res == null ? void 0 : res.name.length) {
            emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
          }
          if (!emoji.includes("%"))
            return encodeURIComponent(emoji);
          return emoji;
        }
        return null;
      }
    };
    module2.exports = BaseGuildEmojiManager2;
  }
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS({
  "node_modules/discord.js/src/managers/ChannelManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { BaseChannel } = require_BaseChannel();
    var { createChannel } = require_Channels();
    var { ThreadChannelTypes } = require_Constants();
    var Events2 = require_Events();
    var cacheWarningEmitted = false;
    var ChannelManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, BaseChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === void 0 || this._cache.maxSize === Infinity;
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      /**
       * The cache of Channels
       * @type {Collection<Snowflake, BaseChannel>}
       * @name ChannelManager#cache
       */
      _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
        var _a, _b, _c;
        const existing = this.cache.get(data.id);
        if (existing) {
          if (cache)
            existing._patch(data);
          (_a = guild == null ? void 0 : guild.channels) == null ? void 0 : _a._add(existing);
          if (ThreadChannelTypes.includes(existing.type)) {
            (_c = (_b = existing.parent) == null ? void 0 : _b.threads) == null ? void 0 : _c._add(existing);
          }
          return existing;
        }
        const channel = createChannel(this.client, data, guild, { allowUnknownGuild });
        if (!channel) {
          this.client.emit(Events2.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
          return null;
        }
        if (cache && !allowUnknownGuild)
          this.cache.set(channel.id, channel);
        return channel;
      }
      _remove(id) {
        var _a, _b, _c, _d;
        const channel = this.cache.get(id);
        (_a = channel == null ? void 0 : channel.guild) == null ? void 0 : _a.channels.cache.delete(id);
        for (const [code, invite] of ((_b = channel == null ? void 0 : channel.guild) == null ? void 0 : _b.invites.cache) ?? []) {
          if (invite.channelId === id)
            channel.guild.invites.cache.delete(code);
        }
        (_d = (_c = channel == null ? void 0 : channel.parent) == null ? void 0 : _c.threads) == null ? void 0 : _d.cache.delete(id);
        this.cache.delete(id);
      }
      /**
       * Data that can be resolved to give a Channel object. This can be:
       * * A Channel object
       * * A Snowflake
       * @typedef {BaseChannel|Snowflake} ChannelResolvable
       */
      /**
       * Resolves a ChannelResolvable to a Channel object.
       * @method resolve
       * @memberof ChannelManager
       * @instance
       * @param {ChannelResolvable} channel The channel resolvable to resolve
       * @returns {?BaseChannel}
       */
      /**
       * Resolves a ChannelResolvable to a channel id string.
       * @method resolveId
       * @memberof ChannelManager
       * @instance
       * @param {ChannelResolvable} channel The channel resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options for fetching a channel from Discord
       * @typedef {BaseFetchOptions} FetchChannelOptions
       * @property {boolean} [allowUnknownGuild=false] Allows the channel to be returned even if the guild is not in cache,
       * it will not be cached. <warn>Many of the properties and methods on the returned channel will throw errors</warn>
       */
      /**
       * Obtains a channel from Discord, or the channel cache if it's already available.
       * @param {Snowflake} id The channel's id
       * @param {FetchChannelOptions} [options] Additional options for this fetch
       * @returns {Promise<?BaseChannel>}
       * @example
       * // Fetch a channel by its id
       * client.channels.fetch('222109930545610754')
       *   .then(channel => console.log(channel.name))
       *   .catch(console.error);
       */
      async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.channel(id));
        return this._add(data, null, { cache, allowUnknownGuild });
      }
    };
    module2.exports = ChannelManager2;
  }
});

// browser-external:node:worker_threads
var require_node_worker_threads = __commonJS({
  "browser-external:node:worker_threads"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:worker_threads" has been externalized for browser compatibility. Cannot access "node:worker_threads.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS({
  "node_modules/discord.js/src/sharding/ShardClientUtil.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { calculateShardId } = require_dist();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Events2 = require_Events();
    var { makeError, makePlainError } = require_Util();
    var ShardClientUtil2 = class {
      constructor(client, mode) {
        this.client = client;
        this.mode = mode;
        this.parentPort = null;
        switch (mode) {
          case "process":
            process2.on("message", this._handleMessage.bind(this));
            client.on(Events2.ShardReady, () => {
              process2.send({ _ready: true });
            });
            client.on(Events2.ShardDisconnect, () => {
              process2.send({ _disconnect: true });
            });
            client.on(Events2.ShardReconnecting, () => {
              process2.send({ _reconnecting: true });
            });
            client.on(Events2.ShardResume, () => {
              process2.send({ _resume: true });
            });
            break;
          case "worker":
            this.parentPort = require_node_worker_threads().parentPort;
            this.parentPort.on("message", this._handleMessage.bind(this));
            client.on(Events2.ShardReady, () => {
              this.parentPort.postMessage({ _ready: true });
            });
            client.on(Events2.ShardDisconnect, () => {
              this.parentPort.postMessage({ _disconnect: true });
            });
            client.on(Events2.ShardReconnecting, () => {
              this.parentPort.postMessage({ _reconnecting: true });
            });
            client.on(Events2.ShardResume, () => {
              this.parentPort.postMessage({ _resume: true });
            });
            break;
        }
      }
      /**
       * Array of shard ids of this client
       * @type {number[]}
       * @readonly
       */
      get ids() {
        return this.client.options.shards;
      }
      /**
       * Total number of shards
       * @type {number}
       * @readonly
       */
      get count() {
        return this.client.options.shardCount;
      }
      /**
       * Sends a message to the master process.
       * @param {*} message Message to send
       * @returns {Promise<void>}
       * @emits Shard#message
       */
      send(message) {
        return new Promise((resolve, reject) => {
          switch (this.mode) {
            case "process":
              process2.send(message, (err) => {
                if (err)
                  reject(err);
                else
                  resolve();
              });
              break;
            case "worker":
              this.parentPort.postMessage(message);
              resolve();
              break;
          }
        });
      }
      /**
       * Fetches a client property value of each shard, or a given shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @param {number} [shard] Shard to fetch property from, all if undefined
       * @returns {Promise<*|Array<*>>}
       * @example
       * client.shard.fetchClientValues('guilds.cache.size')
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       * @see {@link ShardingManager#fetchClientValues}
       */
      fetchClientValues(prop, shard) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process2;
          const listener = (message) => {
            if ((message == null ? void 0 : message._sFetchProp) !== prop || message._sFetchPropShard !== shard)
              return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      /**
       * Evaluates a script or function on all shards, or a given shard, in the context of the {@link Client}s.
       * @param {Function} script JavaScript to run on each shard
       * @param {BroadcastEvalOptions} [options={}] The options for the broadcast
       * @returns {Promise<*|Array<*>>} Results of the script execution
       * @example
       * client.shard.broadcastEval(client => client.guilds.cache.size)
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       * @see {@link ShardingManager#broadcastEval}
       */
      broadcastEval(script2, options = {}) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process2;
          if (typeof script2 !== "function") {
            reject(new DiscordjsTypeError2(ErrorCodes2.ShardingInvalidEvalBroadcast));
            return;
          }
          script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
          const listener = (message) => {
            if ((message == null ? void 0 : message._sEval) !== script2 || message._sEvalShard !== options.shard)
              return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      /**
       * Requests a respawn of all shards.
       * @param {MultipleShardRespawnOptions} [options] Options for respawning shards
       * @returns {Promise<void>} Resolves upon the message being sent
       * @see {@link ShardingManager#respawnAll}
       */
      respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
      }
      /**
       * Handles an IPC message.
       * @param {*} message Message received
       * @private
       */
      async _handleMessage(message) {
        if (!message)
          return;
        if (message._fetchProp) {
          try {
            const props = message._fetchProp.split(".");
            let value = this.client;
            for (const prop of props)
              value = value[prop];
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
          } catch (err) {
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
          }
        } else if (message._eval) {
          try {
            this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
          } catch (err) {
            this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
          }
        }
      }
      /**
       * Sends a message to the master process, emitting an error from the client upon failure.
       * @param {string} type Type of response to send
       * @param {*} message Message to send
       * @private
       */
      _respond(type, message) {
        this.send(message).catch((err) => {
          const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
          error.stack = err.stack;
          this.client.emit(Events2.Error, error);
        });
      }
      /**
       * Creates/gets the singleton of this class.
       * @param {Client} client The client to use
       * @param {ShardingManagerMode} mode Mode the shard was spawned with
       * @returns {ShardClientUtil}
       */
      static singleton(client, mode) {
        if (!this._singleton) {
          this._singleton = new this(client, mode);
        } else {
          client.emit(
            Events2.Warn,
            "Multiple clients created in child process/worker; only the first will handle sharding helpers."
          );
        }
        return this._singleton;
      }
      /**
       * Get the shard id for a given guild id.
       * @param {Snowflake} guildId Snowflake guild id to get shard id for
       * @param {number} shardCount Number of shards
       * @returns {number}
       */
      static shardIdForGuildId(guildId, shardCount) {
        const shard = calculateShardId(guildId, shardCount);
        if (shard < 0)
          throw new DiscordjsError2(ErrorCodes2.ShardingShardMiscalculation, shard, guildId, shardCount);
        return shard;
      }
      /**
       * Increments max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = ShardClientUtil2;
  }
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS({
  "node_modules/discord.js/src/structures/GuildAuditLogs.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var ApplicationCommand = require_ApplicationCommand();
    var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var { flatten } = require_Util();
    var GuildAuditLogs = class {
      constructor(guild, data) {
        if (data.users)
          for (const user of data.users)
            guild.client.users._add(user);
        if (data.threads)
          for (const thread of data.threads)
            guild.client.channels._add(thread, guild);
        this.webhooks = new Collection2();
        if (data.webhooks) {
          for (const hook of data.webhooks) {
            this.webhooks.set(hook.id, new Webhook2(guild.client, hook));
          }
        }
        this.integrations = new Collection2();
        if (data.integrations) {
          for (const integration of data.integrations) {
            this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
          }
        }
        this.guildScheduledEvents = data.guild_scheduled_events.reduce(
          (guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)),
          new Collection2()
        );
        this.applicationCommands = new Collection2();
        if (data.application_commands) {
          for (const command of data.application_commands) {
            this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
          }
        }
        this.autoModerationRules = data.auto_moderation_rules.reduce(
          (autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)),
          new Collection2()
        );
        this.entries = new Collection2();
        for (const item of data.audit_log_entries) {
          const entry = new GuildAuditLogsEntry(guild, item, this);
          this.entries.set(entry.id, entry);
        }
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = GuildAuditLogs;
  }
});

// node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js
var require_GuildOnboardingPromptOption = __commonJS({
  "node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var GuildOnboardingPromptOption = class extends Base {
      constructor(client, data, guildId) {
        super(client);
        this.guildId = guildId;
        const guild = this.guild;
        this.id = data.id;
        this.channels = data.channel_ids.reduce(
          (channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)),
          new Collection2()
        );
        this.roles = data.role_ids.reduce(
          (roles, roleId) => roles.set(roleId, guild.roles.cache.get(roleId)),
          new Collection2()
        );
        this._emoji = data.emoji;
        this.title = data.title;
        this.description = data.description;
      }
      /**
       * The guild this onboarding prompt option is from
       * @type {Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId);
      }
      /**
       * The emoji of this onboarding prompt option
       * @type {?(GuildEmoji|Emoji)}
       */
      get emoji() {
        if (!this._emoji.id && !this._emoji.name)
          return null;
        return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
      }
    };
    exports2.GuildOnboardingPromptOption = GuildOnboardingPromptOption;
  }
});

// node_modules/discord.js/src/structures/GuildOnboardingPrompt.js
var require_GuildOnboardingPrompt = __commonJS({
  "node_modules/discord.js/src/structures/GuildOnboardingPrompt.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Base = require_Base();
    var { GuildOnboardingPromptOption } = require_GuildOnboardingPromptOption();
    var GuildOnboardingPrompt = class extends Base {
      constructor(client, data, guildId) {
        super(client);
        this.guildId = guildId;
        this.id = data.id;
        this.options = data.options.reduce(
          (options, option) => options.set(option.id, new GuildOnboardingPromptOption(client, option, guildId)),
          new Collection2()
        );
        this.title = data.title;
        this.singleSelect = data.single_select;
        this.required = data.required;
        this.inOnboarding = data.in_onboarding;
        this.type = data.type;
      }
      /**
       * The guild this onboarding prompt is from
       * @type {Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId);
      }
    };
    exports2.GuildOnboardingPrompt = GuildOnboardingPrompt;
  }
});

// node_modules/discord.js/src/structures/GuildOnboarding.js
var require_GuildOnboarding = __commonJS({
  "node_modules/discord.js/src/structures/GuildOnboarding.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var Base = require_Base();
    var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();
    var GuildOnboarding = class extends Base {
      constructor(client, data) {
        super(client);
        this.guildId = data.guild_id;
        const guild = this.guild;
        this.prompts = data.prompts.reduce(
          (prompts, prompt) => prompts.set(prompt.id, new GuildOnboardingPrompt(client, prompt, this.guildId)),
          new Collection2()
        );
        this.defaultChannels = data.default_channel_ids.reduce(
          (channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)),
          new Collection2()
        );
        this.enabled = data.enabled;
        this.mode = data.mode;
      }
      /**
       * The guild this onboarding is from
       * @type {Guild}
       * @readonly
       */
      get guild() {
        return this.client.guilds.cache.get(this.guildId);
      }
    };
    exports2.GuildOnboarding = GuildOnboarding;
  }
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS({
  "node_modules/discord.js/src/structures/GuildPreviewEmoji.js"(exports2, module2) {
    "use strict";
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var GuildPreviewEmoji = class extends BaseGuildEmoji {
      /**
       * The public guild this emoji is part of
       * @type {GuildPreview}
       * @name GuildPreviewEmoji#guild
       */
      constructor(client, data, guild) {
        super(client, data, guild);
        this.roles = data.roles;
      }
    };
    module2.exports = GuildPreviewEmoji;
  }
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS({
  "node_modules/discord.js/src/structures/GuildPreview.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var GuildPreviewEmoji = require_GuildPreviewEmoji();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildPreview2 = class extends Base {
      constructor(client, data) {
        super(client);
        if (!data)
          return;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        }
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("features" in data) {
          this.features = data.features;
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if (!this.emojis) {
          this.emojis = new Collection2();
        } else {
          this.emojis.clear();
        }
        for (const emoji of data.emojis) {
          this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
        }
        this.stickers = data.stickers.reduce(
          (stickers, sticker) => stickers.set(sticker.id, new Sticker2(this.client, sticker)),
          new Collection2()
        );
      }
      /**
       * The timestamp this guild was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time this guild was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The URL to this guild's splash.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      splashURL(options = {}) {
        return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
      }
      /**
       * The URL to this guild's discovery splash.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      discoverySplashURL(options = {}) {
        return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
      }
      /**
       * The URL to this guild's icon.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
      }
      /**
       * Fetches this guild.
       * @returns {Promise<GuildPreview>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.guildPreview(this.id));
        this._patch(data);
        return this;
      }
      /**
       * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.
       * @returns {string}
       * @example
       * // Logs: Hello from My Guild!
       * console.log(`Hello from ${previewGuild}!`);
       */
      toString() {
        return this.name;
      }
      toJSON() {
        const json = super.toJSON();
        json.iconURL = this.iconURL();
        json.splashURL = this.splashURL();
        return json;
      }
    };
    module2.exports = GuildPreview2;
  }
});

// node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS({
  "node_modules/discord.js/src/managers/AutoModerationRuleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var AutoModerationRule = require_AutoModerationRule();
    var AutoModerationRuleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, AutoModerationRule, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, AutoModerationRule>}
       * @name AutoModerationRuleManager#cache
       */
      /**
       * Resolves an {@link AutoModerationRuleResolvable} to an {@link AutoModerationRule} object.
       * @method resolve
       * @memberof AutoModerationRuleManager
       * @instance
       * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve
       * @returns {?AutoModerationRule}
       */
      /**
       * Resolves an {@link AutoModerationRuleResolvable} to a {@link AutoModerationRule} id.
       * @method resolveId
       * @memberof AutoModerationRuleManager
       * @instance
       * @param {AutoModerationRuleResolvable} autoModerationRule The AutoModerationRule resolvable to resolve
       * @returns {?Snowflake}
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used to set the trigger metadata of an auto moderation rule.
       * @typedef {Object} AutoModerationTriggerMetadataOptions
       * @property {string[]} [keywordFilter] The substrings that will be searched for in the content
       * @property {string[]} [regexPatterns] The regular expression patterns which will be matched against the content
       * <info>Only Rust-flavored regular expressions are supported.</info>
       * @property {AutoModerationRuleKeywordPresetType[]} [presets]
       * The internally pre-defined wordsets which will be searched for in the content
       * @property {string[]} [allowList] The substrings that will be exempt from triggering
       * {@link AutoModerationRuleTriggerType.Keyword} and {@link AutoModerationRuleTriggerType.KeywordPreset}
       * @property {?number} [mentionTotalLimit] The total number of role & user mentions allowed per message
       * @property {boolean} [mentionRaidProtectionEnabled] Whether to automatically detect mention raids
       */
      /**
       * Options used to set the actions of an auto moderation rule.
       * @typedef {Object} AutoModerationActionOptions
       * @property {AutoModerationActionType} type The type of this auto moderation rule action
       * @property {AutoModerationActionMetadataOptions} [metadata] Additional metadata needed during execution
       * <info>This property is required if using a `type` of
       * {@link AutoModerationActionType.SendAlertMessage} or {@link AutoModerationActionType.Timeout}.</info>
       */
      /**
       * Options used to set the metadata of an auto moderation rule action.
       * @typedef {Object} AutoModerationActionMetadataOptions
       * @property {GuildTextChannelResolvable|ThreadChannel} [channel] The channel to which content will be logged
       * @property {number} [durationSeconds] The timeout duration in seconds
       * @property {string} [customMessage] The custom message that is shown whenever a message is blocked
       */
      /**
       * Options used to create an auto moderation rule.
       * @typedef {Object} AutoModerationRuleCreateOptions
       * @property {string} name The name of the auto moderation rule
       * @property {AutoModerationRuleEventType} eventType The event type of the auto moderation rule
       * @property {AutoModerationRuleTriggerType} triggerType The trigger type of the auto moderation rule
       * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule
       * <info>This property is required if using a `triggerType` of
       * {@link AutoModerationRuleTriggerType.Keyword}, {@link AutoModerationRuleTriggerType.KeywordPreset},
       * or {@link AutoModerationRuleTriggerType.MentionSpam}.</info>
       * @property {AutoModerationActionOptions[]} actions
       * The actions that will execute when the auto moderation rule is triggered
       * @property {boolean} [enabled] Whether the auto moderation rule should be enabled
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @property {string} [reason] The reason for creating the auto moderation rule
       */
      /**
       * Creates a new auto moderation rule.
       * @param {AutoModerationRuleCreateOptions} options Options for creating the auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      async create({
        name,
        eventType,
        triggerType,
        triggerMetadata,
        actions,
        enabled,
        exemptRoles,
        exemptChannels,
        reason
      }) {
        const data = await this.client.rest.post(Routes2.guildAutoModerationRules(this.guild.id), {
          body: {
            name,
            event_type: eventType,
            trigger_type: triggerType,
            trigger_metadata: triggerMetadata && {
              keyword_filter: triggerMetadata.keywordFilter,
              regex_patterns: triggerMetadata.regexPatterns,
              presets: triggerMetadata.presets,
              allow_list: triggerMetadata.allowList,
              mention_total_limit: triggerMetadata.mentionTotalLimit,
              mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
            },
            actions: actions.map((action) => {
              var _a, _b, _c;
              return {
                type: action.type,
                metadata: {
                  duration_seconds: (_a = action.metadata) == null ? void 0 : _a.durationSeconds,
                  channel_id: ((_b = action.metadata) == null ? void 0 : _b.channel) && this.guild.channels.resolveId(action.metadata.channel),
                  custom_message: (_c = action.metadata) == null ? void 0 : _c.customMessage
                }
              };
            }),
            enabled,
            exempt_roles: exemptRoles == null ? void 0 : exemptRoles.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
            exempt_channels: exemptChannels == null ? void 0 : exemptChannels.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Options used to edit an auto moderation rule.
       * @typedef {Object} AutoModerationRuleEditOptions
       * @property {string} [name] The name of the auto moderation rule
       * @property {AutoModerationRuleEventType} [eventType] The event type of the auto moderation rule
       * @property {AutoModerationTriggerMetadataOptions} [triggerMetadata] The trigger metadata of the auto moderation rule
       * @property {AutoModerationActionOptions[]} [actions]
       * The actions that will execute when the auto moderation rule is triggered
       * @property {boolean} [enabled] Whether the auto moderation rule should be enabled
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [exemptRoles]
       * The roles that should not be affected by the auto moderation rule
       * @property {Collection<Snowflake, GuildChannel|ThreadChannel>|GuildChannelResolvable[]} [exemptChannels]
       * The channels that should not be affected by the auto moderation rule
       * @property {string} [reason] The reason for creating the auto moderation rule
       */
      /**
       * Edits an auto moderation rule.
       * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to edit
       * @param {AutoModerationRuleEditOptions} options Options for editing the auto moderation rule
       * @returns {Promise<AutoModerationRule>}
       */
      async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
        const autoModerationRuleId = this.resolveId(autoModerationRule);
        const data = await this.client.rest.patch(Routes2.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
          body: {
            name,
            event_type: eventType,
            trigger_metadata: triggerMetadata && {
              keyword_filter: triggerMetadata.keywordFilter,
              regex_patterns: triggerMetadata.regexPatterns,
              presets: triggerMetadata.presets,
              allow_list: triggerMetadata.allowList,
              mention_total_limit: triggerMetadata.mentionTotalLimit,
              mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
            },
            actions: actions == null ? void 0 : actions.map((action) => {
              var _a, _b, _c;
              return {
                type: action.type,
                metadata: {
                  duration_seconds: (_a = action.metadata) == null ? void 0 : _a.durationSeconds,
                  channel_id: ((_b = action.metadata) == null ? void 0 : _b.channel) && this.guild.channels.resolveId(action.metadata.channel),
                  custom_message: (_c = action.metadata) == null ? void 0 : _c.customMessage
                }
              };
            }),
            enabled,
            exempt_roles: exemptRoles == null ? void 0 : exemptRoles.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
            exempt_channels: exemptChannels == null ? void 0 : exemptChannels.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Data that can be resolved to give an AutoModerationRule object. This can be:
       * * An AutoModerationRule
       * * A Snowflake
       * @typedef {AutoModerationRule|Snowflake} AutoModerationRuleResolvable
       */
      /**
       * Options used to fetch a single auto moderation rule from a guild.
       * @typedef {BaseFetchOptions} FetchAutoModerationRuleOptions
       * @property {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to fetch
       */
      /**
       * Options used to fetch all auto moderation rules from a guild.
       * @typedef {Object} FetchAutoModerationRulesOptions
       * @property {boolean} [cache] Whether to cache the fetched auto moderation rules
       */
      /**
       * Fetches auto moderation rules from Discord.
       * @param {AutoModerationRuleResolvable|FetchAutoModerationRuleOptions|FetchAutoModerationRulesOptions} [options]
       * Options for fetching auto moderation rule(s)
       * @returns {Promise<AutoModerationRule|Collection<Snowflake, AutoModerationRule>>}
       * @example
       * // Fetch all auto moderation rules from a guild without caching
       * guild.autoModerationRules.fetch({ cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single auto moderation rule
       * guild.autoModerationRules.fetch('979083472868098119')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single auto moderation rule without checking cache and without caching
       * guild.autoModerationRules.fetch({ autoModerationRule: '979083472868098119', cache: false, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { autoModerationRule, cache, force } = options;
        const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
        if (resolvedAutoModerationRule) {
          return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ autoModerationRule, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(autoModerationRule);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildAutoModerationRule(this.guild.id, autoModerationRule));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes2.guildAutoModerationRules(this.guild.id));
        return data.reduce(
          (col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)),
          new Collection2()
        );
      }
      /**
       * Deletes an auto moderation rule.
       * @param {AutoModerationRuleResolvable} autoModerationRule The auto moderation rule to delete
       * @param {string} [reason] The reason for deleting the auto moderation rule
       * @returns {Promise<void>}
       */
      async delete(autoModerationRule, reason) {
        const autoModerationRuleId = this.resolveId(autoModerationRule);
        await this.client.rest.delete(Routes2.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
      }
    };
    module2.exports = AutoModerationRuleManager;
  }
});

// node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var ApplicationCommandManager = require_ApplicationCommandManager();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var GuildApplicationCommandManager = class extends ApplicationCommandManager {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
    };
    module2.exports = GuildApplicationCommandManager;
  }
});

// node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildBanManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildBan = require_GuildBan();
    var { GuildMember } = require_GuildMember();
    var deprecationEmittedForDeleteMessageDays = false;
    var GuildBanManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildBan, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildBan>}
       * @name GuildBanManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      /**
       * Data that resolves to give a GuildBan object. This can be:
       * * A GuildBan object
       * * A User resolvable
       * @typedef {GuildBan|UserResolvable} GuildBanResolvable
       */
      /**
       * Resolves a GuildBanResolvable to a GuildBan object.
       * @param {GuildBanResolvable} ban The ban that is in the guild
       * @returns {?GuildBan}
       */
      resolve(ban) {
        return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
      }
      /**
       * Options used to fetch a single ban from a guild.
       * @typedef {BaseFetchOptions} FetchBanOptions
       * @property {UserResolvable} user The ban to fetch
       */
      /**
       * Options used to fetch multiple bans from a guild.
       * @typedef {Object} FetchBansOptions
       * @property {number} [limit] The maximum number of bans to return
       * @property {Snowflake} [before] Consider only bans before this id
       * @property {Snowflake} [after] Consider only bans after this id
       * @property {boolean} [cache] Whether to cache the fetched bans
       */
      /**
       * Fetches ban(s) from Discord.
       * @param {UserResolvable|FetchBanOptions|FetchBansOptions} [options] Options for fetching guild ban(s)
       * @returns {Promise<GuildBan|Collection<Snowflake, GuildBan>>}
       * @example
       * // Fetch multiple bans from a guild
       * guild.bans.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a maximum of 5 bans from a guild without caching
       * guild.bans.fetch({ limit: 5, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single ban
       * guild.bans.fetch('351871113346809860')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single ban without checking cache
       * guild.bans.fetch({ user, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single ban without caching
       * guild.bans.fetch({ user, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { user, cache, force, limit, before, after } = options;
        const resolvedUser = this.client.users.resolveId(user ?? options);
        if (resolvedUser)
          return this._fetchSingle({ user: resolvedUser, cache, force });
        if (!before && !after && !limit && cache === void 0) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.FetchBanResolveId));
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildBan(this.guild.id, user));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes2.guildBans(this.guild.id), {
          query: makeURLSearchParams2(options)
        });
        return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection2());
      }
      /**
       * Options used to ban a user from a guild.
       * @typedef {Object} BanOptions
       * @property {number} [deleteMessageDays] Number of days of messages to delete, must be between 0 and 7, inclusive
       * <warn>This property is deprecated. Use `deleteMessageSeconds` instead.</warn>
       * @property {number} [deleteMessageSeconds] Number of seconds of messages to delete,
       * must be between 0 and 604800 (7 days), inclusive
       * @property {string} [reason] The reason for the ban
       */
      /**
       * Bans a user from the guild.
       * @param {UserResolvable} user The user to ban
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user id will be the result.
       * @example
       * // Ban a user by id (or with a user/guild member object)
       * guild.bans.create('84484653687267328')
       *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))
       *   .catch(console.error);
       */
      async create(user, options = {}) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.BanResolveId, true);
        if (options.deleteMessageDays !== void 0 && !deprecationEmittedForDeleteMessageDays) {
          process2.emitWarning(
            // eslint-disable-next-line max-len
            "The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForDeleteMessageDays = true;
        }
        await this.client.rest.put(Routes2.guildBan(this.guild.id, id), {
          body: {
            delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : void 0)
          },
          reason: options.reason
        });
        if (user instanceof GuildMember)
          return user;
        const _user = this.client.users.resolve(id);
        if (_user) {
          return this.guild.members.resolve(_user) ?? _user;
        }
        return id;
      }
      /**
       * Unbans a user from the guild.
       * @param {UserResolvable} user The user to unban
       * @param {string} [reason] Reason for unbanning user
       * @returns {Promise<?User>}
       * @example
       * // Unban a user by id (or with a user/guild member object)
       * guild.bans.remove('84484653687267328')
       *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
       *   .catch(console.error);
       */
      async remove(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.BanResolveId);
        await this.client.rest.delete(Routes2.guildBan(this.guild.id, id), { reason });
        return this.client.users.resolve(user);
      }
    };
    module2.exports = GuildBanManager;
  }
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildChannelManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist6();
    var { ChannelType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var GuildChannel = require_GuildChannel();
    var PermissionOverwrites = require_PermissionOverwrites();
    var ThreadChannel = require_ThreadChannel();
    var Webhook2 = require_Webhook();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
    var { ThreadChannelTypes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var { setPosition } = require_Util();
    var cacheWarningEmitted = false;
    var GuildChannelManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === void 0 || this._cache.maxSize === Infinity;
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      /**
       * The number of channels in this managers cache excluding thread channels
       * that do not count towards a guild's maximum channels restriction.
       * @type {number}
       * @readonly
       */
      get channelCountWithoutThreads() {
        return this.cache.reduce((acc, channel) => {
          if (ThreadChannelTypes.includes(channel.type))
            return acc;
          return ++acc;
        }, 0);
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildChannel|ThreadChannel>}
       * @name GuildChannelManager#cache
       */
      _add(channel) {
        const existing = this.cache.get(channel.id);
        if (existing)
          return existing;
        this.cache.set(channel.id, channel);
        return channel;
      }
      /**
       * Data that can be resolved to give a Guild Channel object. This can be:
       * * A GuildChannel object
       * * A ThreadChannel object
       * * A Snowflake
       * @typedef {GuildChannel|ThreadChannel|Snowflake} GuildChannelResolvable
       */
      /**
       * Resolves a GuildChannelResolvable to a Channel object.
       * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
       * @returns {?(GuildChannel|ThreadChannel)}
       */
      resolve(channel) {
        if (channel instanceof ThreadChannel)
          return super.resolve(channel.id);
        return super.resolve(channel);
      }
      /**
       * Resolves a GuildChannelResolvable to a channel id.
       * @param {GuildChannelResolvable} channel The GuildChannel resolvable to resolve
       * @returns {?Snowflake}
       */
      resolveId(channel) {
        if (channel instanceof ThreadChannel)
          return super.resolveId(channel.id);
        return super.resolveId(channel);
      }
      /**
       * Adds the target channel to a channel's followers.
       * @param {NewsChannel|Snowflake} channel The channel to follow
       * @param {TextChannelResolvable} targetChannel The channel where published announcements will be posted at
       * @param {string} [reason] Reason for creating the webhook
       * @returns {Promise<Snowflake>} Returns created target webhook id.
       */
      async addFollower(channel, targetChannel, reason) {
        const channelId = this.resolveId(channel);
        const targetChannelId = this.resolveId(targetChannel);
        if (!channelId || !targetChannelId)
          throw new Error(ErrorCodes2.GuildChannelResolve);
        const { webhook_id } = await this.client.rest.post(Routes2.channelFollowers(channelId), {
          body: { webhook_channel_id: targetChannelId },
          reason
        });
        return webhook_id;
      }
      /**
       * Options used to create a new channel in a guild.
       * @typedef {CategoryCreateChannelOptions} GuildChannelCreateOptions
       * @property {?CategoryChannelResolvable} [parent] Parent of the new channel
       */
      /**
       * Creates a new channel in the guild.
       * @param {GuildChannelCreateOptions} options Options for creating the new channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Create a new text channel
       * guild.channels.create({ name: 'new-general', reason: 'Needed a cool new channel' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Create a new channel with permission overwrites
       * guild.channels.create({
       *   name: 'new-general',
       *   type: ChannelType.GuildVoice,
       *   permissionOverwrites: [
       *      {
       *        id: message.author.id,
       *        deny: [PermissionFlagsBits.ViewChannel],
       *     },
       *   ],
       * })
       */
      async create({
        name,
        type,
        topic,
        nsfw,
        bitrate,
        userLimit,
        parent,
        permissionOverwrites,
        position,
        rateLimitPerUser,
        rtcRegion,
        videoQualityMode,
        defaultThreadRateLimitPerUser,
        availableTags,
        defaultReactionEmoji,
        defaultAutoArchiveDuration,
        defaultSortOrder,
        defaultForumLayout,
        reason
      }) {
        parent && (parent = this.client.channels.resolveId(parent));
        permissionOverwrites && (permissionOverwrites = permissionOverwrites.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild)));
        const data = await this.client.rest.post(Routes2.guildChannels(this.guild.id), {
          body: {
            name,
            topic,
            type,
            nsfw,
            bitrate,
            user_limit: userLimit,
            parent_id: parent,
            position,
            permission_overwrites: permissionOverwrites,
            rate_limit_per_user: rateLimitPerUser,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            default_thread_rate_limit_per_user: defaultThreadRateLimitPerUser,
            available_tags: availableTags == null ? void 0 : availableTags.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
            default_auto_archive_duration: defaultAutoArchiveDuration,
            default_sort_order: defaultSortOrder,
            default_forum_layout: defaultForumLayout
          },
          reason
        });
        return this.client.actions.ChannelCreate.handle(data).channel;
      }
      /**
       * @typedef {ChannelWebhookCreateOptions} WebhookCreateOptions
       * @property {TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|MediaChannel|Snowflake} channel
       * The channel to create the webhook for
       */
      /**
       * Creates a webhook for the channel.
       * @param {WebhookCreateOptions} options Options for creating the webhook
       * @returns {Promise<Webhook>} Returns the created Webhook
       * @example
       * // Create a webhook for the current channel
       * guild.channels.createWebhook({
       *   channel: '222197033908436994',
       *   name: 'Snek',
       *   avatar: 'https://i.imgur.com/mI8XcpG.jpg',
       *   reason: 'Needed a cool new Webhook'
       * })
       *   .then(console.log)
       *   .catch(console.error)
       */
      async createWebhook({ channel, name, avatar, reason }) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        if (typeof avatar === "string" && !avatar.startsWith("data:")) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        const data = await this.client.rest.post(Routes2.channelWebhooks(id), {
          body: {
            name,
            avatar
          },
          reason
        });
        return new Webhook2(this.client, data);
      }
      /**
       * Options used to edit a guild channel.
       * @typedef {Object} GuildChannelEditOptions
       * @property {string} [name] The name of the channel
       * @property {ChannelType} [type] The type of the channel (only conversion between text and news is supported)
       * @property {number} [position] The position of the channel
       * @property {?string} [topic] The topic of the text channel
       * @property {boolean} [nsfw] Whether the channel is NSFW
       * @property {number} [bitrate] The bitrate of the voice channel
       * @property {number} [userLimit] The user limit of the voice channel
       * @property {?CategoryChannelResolvable} [parent] The parent of the channel
       * @property {boolean} [lockPermissions]
       * Lock the permissions of the channel to what the parent's permissions are
       * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]
       * Permission overwrites for the channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) for the channel in seconds
       * @property {ThreadAutoArchiveDuration} [defaultAutoArchiveDuration]
       * The default auto archive duration for all new threads in this channel
       * @property {?string} [rtcRegion] The RTC region of the channel
       * @property {?VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel
       * @property {GuildForumTagData[]} [availableTags] The tags to set as available in a forum channel
       * @property {?DefaultReactionEmoji} [defaultReactionEmoji] The emoji to set as the default reaction emoji
       * @property {number} [defaultThreadRateLimitPerUser] The rate limit per user (slowmode) to set on forum posts
       * @property {ChannelFlagsResolvable} [flags] The flags to set on the channel
       * @property {?SortOrderType} [defaultSortOrder] The default sort order mode to set on the channel
       * @property {ForumLayoutType} [defaultForumLayout] The default forum layout to set on the channel
       * @property {string} [reason] Reason for editing this channel
       */
      /**
       * Edits the channel.
       * @param {GuildChannelResolvable} channel The channel to edit
       * @param {GuildChannelEditOptions} options Options for editing the channel
       * @returns {Promise<GuildChannel>}
       * @example
       * // Edit a channel
       * guild.channels.edit('222197033908436994', { name: 'new-channel' })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async edit(channel, options) {
        var _a, _b;
        channel = this.resolve(channel);
        if (!channel)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const parent = options.parent && this.client.channels.resolveId(options.parent);
        if (options.position !== void 0) {
          await this.setPosition(channel, options.position, { position: options.position, reason: options.reason });
        }
        let permission_overwrites = (_a = options.permissionOverwrites) == null ? void 0 : _a.map(
          (overwrite) => PermissionOverwrites.resolve(overwrite, this.guild)
        );
        if (options.lockPermissions) {
          if (parent) {
            const newParent = this.guild.channels.resolve(parent);
            if ((newParent == null ? void 0 : newParent.type) === ChannelType.GuildCategory) {
              permission_overwrites = newParent.permissionOverwrites.cache.map(
                (overwrite) => PermissionOverwrites.resolve(overwrite, this.guild)
              );
            }
          } else if (channel.parent) {
            permission_overwrites = channel.parent.permissionOverwrites.cache.map(
              (overwrite) => PermissionOverwrites.resolve(overwrite, this.guild)
            );
          }
        }
        const newData = await this.client.rest.patch(Routes2.channel(channel.id), {
          body: {
            name: (options.name ?? channel.name).trim(),
            type: options.type,
            topic: options.topic,
            nsfw: options.nsfw,
            bitrate: options.bitrate ?? channel.bitrate,
            user_limit: options.userLimit ?? channel.userLimit,
            rtc_region: "rtcRegion" in options ? options.rtcRegion : channel.rtcRegion,
            video_quality_mode: options.videoQualityMode,
            parent_id: parent,
            lock_permissions: options.lockPermissions,
            rate_limit_per_user: options.rateLimitPerUser,
            default_auto_archive_duration: options.defaultAutoArchiveDuration,
            permission_overwrites,
            available_tags: (_b = options.availableTags) == null ? void 0 : _b.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
            default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
            flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : void 0,
            default_sort_order: options.defaultSortOrder,
            default_forum_layout: options.defaultForumLayout
          },
          reason: options.reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      /**
       * Sets a new position for the guild channel.
       * @param {GuildChannelResolvable} channel The channel to set the position for
       * @param {number} position The new position for the guild channel
       * @param {SetChannelPositionOptions} options Options for setting position
       * @returns {Promise<GuildChannel>}
       * @example
       * // Set a new channel position
       * guild.channels.setPosition('222078374472843266', 2)
       *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))
       *   .catch(console.error);
       */
      async setPosition(channel, position, { relative, reason } = {}) {
        channel = this.resolve(channel);
        if (!channel)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const updatedChannels = await setPosition(
          channel,
          position,
          relative,
          this.guild._sortedChannels(channel),
          this.client,
          Routes2.guildChannels(this.guild.id),
          reason
        );
        this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: updatedChannels
        });
        return channel;
      }
      /**
       * Obtains one or more guild channels from Discord, or the channel cache if they're already available.
       * @param {Snowflake} [id] The channel's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?GuildChannel|ThreadChannel|Collection<Snowflake, ?GuildChannel>>}
       * @example
       * // Fetch all channels from the guild (excluding threads)
       * message.guild.channels.fetch()
       *   .then(channels => console.log(`There are ${channels.size} channels.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single channel
       * message.guild.channels.fetch('222197033908436994')
       *   .then(channel => console.log(`The channel name is: ${channel.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        if (id) {
          const data2 = await this.client.rest.get(Routes2.channel(id));
          if (this.guild.id !== data2.guild_id)
            throw new DiscordjsError2(ErrorCodes2.GuildChannelUnowned);
          return this.client.channels._add(data2, this.guild, { cache });
        }
        const data = await this.client.rest.get(Routes2.guildChannels(this.guild.id));
        const channels = new Collection2();
        for (const channel of data)
          channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
        return channels;
      }
      /**
       * Fetches all webhooks for the channel.
       * @param {GuildChannelResolvable} channel The channel to fetch webhooks for
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * guild.channels.fetchWebhooks('769862166131245066')
       *   .then(hooks => console.log(`This channel has ${hooks.size} hooks`))
       *   .catch(console.error);
       */
      async fetchWebhooks(channel) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const data = await this.client.rest.get(Routes2.channelWebhooks(id));
        return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook2(this.client, hook)), new Collection2());
      }
      /**
       * Data that can be resolved to give a Category Channel object. This can be:
       * * A CategoryChannel object
       * * A Snowflake
       * @typedef {CategoryChannel|Snowflake} CategoryChannelResolvable
       */
      /**
       * The data needed for updating a channel's position.
       * @typedef {Object} ChannelPosition
       * @property {GuildChannel|Snowflake} channel Channel to update
       * @property {number} [position] New position for the channel
       * @property {CategoryChannelResolvable} [parent] Parent channel for this channel
       * @property {boolean} [lockPermissions] If the overwrites should be locked to the parents overwrites
       */
      /**
       * Batch-updates the guild's channels' positions.
       * <info>Only one channel's parent can be changed at a time</info>
       * @param {ChannelPosition[]} channelPositions Channel positions to update
       * @returns {Promise<Guild>}
       * @example
       * guild.channels.setPositions([{ channel: channelId, position: newChannelIndex }])
       *   .then(guild => console.log(`Updated channel positions for ${guild}`))
       *   .catch(console.error);
       */
      async setPositions(channelPositions) {
        channelPositions = channelPositions.map((channelPosition) => ({
          id: this.client.channels.resolveId(channelPosition.channel),
          position: channelPosition.position,
          lock_permissions: channelPosition.lockPermissions,
          parent_id: channelPosition.parent !== void 0 ? this.resolveId(channelPosition.parent) : void 0
        }));
        await this.client.rest.patch(Routes2.guildChannels(this.guild.id), { body: channelPositions });
        return this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: channelPositions
        }).guild;
      }
      /**
       * Data returned from fetching threads.
       * @typedef {Object} FetchedThreads
       * @property {Collection<Snowflake, ThreadChannel>} threads The threads that were fetched
       * @property {Collection<Snowflake, ThreadMember>} members The thread members in the received threads
       */
      /**
       * Obtains all active thread channels in the guild.
       * @param {boolean} [cache=true] Whether to cache the fetched data
       * @returns {Promise<FetchedThreads>}
       * @example
       * // Fetch all threads from the guild
       * message.guild.channels.fetchActiveThreads()
       *   .then(fetched => console.log(`There are ${fetched.threads.size} threads.`))
       *   .catch(console.error);
       */
      async fetchActiveThreads(cache = true) {
        const data = await this.rawFetchGuildActiveThreads();
        return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });
      }
      /**
       * `GET /guilds/{guild.id}/threads/active`
       * @private
       * @returns {Promise<RESTGetAPIGuildThreadsResult>}
       */
      rawFetchGuildActiveThreads() {
        return this.client.rest.get(Routes2.guildActiveThreads(this.guild.id));
      }
      /**
       * Deletes the channel.
       * @param {GuildChannelResolvable} channel The channel to delete
       * @param {string} [reason] Reason for deleting this channel
       * @returns {Promise<void>}
       * @example
       * // Delete the channel
       * guild.channels.delete('858850993013260338', 'making room for new channels')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async delete(channel, reason) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        await this.client.rest.delete(Routes2.channel(id), { reason });
        this.client.actions.ChannelDelete.handle({ id });
      }
    };
    module2.exports = GuildChannelManager;
  }
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2, PermissionFlagsBits } = require_v106();
    var BaseGuildEmojiManager2 = require_BaseGuildEmojiManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var DataResolver2 = require_DataResolver();
    var GuildEmojiManager = class extends BaseGuildEmojiManager2 {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used for creating an emoji in a guild.
       * @typedef {Object} GuildEmojiCreateOptions
       * @property {BufferResolvable|Base64Resolvable} attachment The image for the emoji
       * @property {string} name The name for the emoji
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to limit the emoji to
       * @property {string} [reason] The reason for creating the emoji
       */
      /**
       * Creates a new custom emoji in the guild.
       * @param {GuildEmojiCreateOptions} options Options for creating the emoji
       * @returns {Promise<Emoji>} The created emoji
       * @example
       * // Create a new emoji from a URL
       * guild.emojis.create({ attachment: 'https://i.imgur.com/w3duR07.png', name: 'rip' })
       *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
       *   .catch(console.error);
       * @example
       * // Create a new emoji from a file on your computer
       * guild.emojis.create({ attachment: './memes/banana.png', name: 'banana' })
       *   .then(emoji => console.log(`Created new emoji with name ${emoji.name}!`))
       *   .catch(console.error);
       */
      async create({ attachment, name, roles, reason }) {
        attachment = await DataResolver2.resolveImage(attachment);
        if (!attachment)
          throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
        const body = { image: attachment, name };
        if (roles) {
          if (!Array.isArray(roles) && !(roles instanceof Collection2)) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "options.roles",
              "Array or Collection of Roles or Snowflakes",
              true
            );
          }
          body.roles = [];
          for (const role of roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "options.roles", role);
            }
            body.roles.push(resolvedRole);
          }
        }
        const emoji = await this.client.rest.post(Routes2.guildEmojis(this.guild.id), { body, reason });
        return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
      }
      /**
       * Obtains one or more emojis from Discord, or the emoji cache if they're already available.
       * @param {Snowflake} [id] The emoji's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<GuildEmoji|Collection<Snowflake, GuildEmoji>>}
       * @example
       * // Fetch all emojis from the guild
       * message.guild.emojis.fetch()
       *   .then(emojis => console.log(`There are ${emojis.size} emojis.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single emoji
       * message.guild.emojis.fetch('222078108977594368')
       *   .then(emoji => console.log(`The emoji name is: ${emoji.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const emoji = await this.client.rest.get(Routes2.guildEmoji(this.guild.id, id));
          return this._add(emoji, cache);
        }
        const data = await this.client.rest.get(Routes2.guildEmojis(this.guild.id));
        const emojis = new Collection2();
        for (const emoji of data)
          emojis.set(emoji.id, this._add(emoji, cache));
        return emojis;
      }
      /**
       * Deletes an emoji.
       * @param {EmojiResolvable} emoji The Emoji resolvable to delete
       * @param {string} [reason] Reason for deleting the emoji
       * @returns {Promise<void>}
       */
      async delete(emoji, reason) {
        const id = this.resolveId(emoji);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        await this.client.rest.delete(Routes2.guildEmoji(this.guild.id, id), { reason });
      }
      /**
       * Edits an emoji.
       * @param {EmojiResolvable} emoji The Emoji resolvable to edit
       * @param {GuildEmojiEditOptions} options The options to provide
       * @returns {Promise<GuildEmoji>}
       */
      async edit(emoji, options) {
        var _a;
        const id = this.resolveId(emoji);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        const roles = (_a = options.roles) == null ? void 0 : _a.map((role) => this.guild.roles.resolveId(role));
        const newData = await this.client.rest.patch(Routes2.guildEmoji(this.guild.id, id), {
          body: {
            name: options.name,
            roles
          },
          reason: options.reason
        });
        const existing = this.cache.get(id);
        if (existing) {
          const clone = existing._clone();
          clone._patch(newData);
          return clone;
        }
        return this._add(newData);
      }
      /**
       * Fetches the author for this emoji
       * @param {EmojiResolvable} emoji The emoji to fetch the author of
       * @returns {Promise<User>}
       */
      async fetchAuthor(emoji) {
        emoji = this.resolve(emoji);
        if (!emoji)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        if (emoji.managed) {
          throw new DiscordjsError2(ErrorCodes2.EmojiManaged);
        }
        const { me } = this.guild.members;
        if (!me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {
          throw new DiscordjsError2(ErrorCodes2.MissingManageGuildExpressionsPermission, this.guild);
        }
        const data = await this.client.rest.get(Routes2.guildEmoji(this.guild.id, emoji.id));
        emoji._patch(data);
        return emoji.author;
      }
    };
    module2.exports = GuildEmojiManager;
  }
});

// node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildInviteManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Invite2 = require_Invite();
    var DataResolver2 = require_DataResolver();
    var GuildInviteManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Invite2, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<string, Invite>}
       * @name GuildInviteManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.code, extras: [this.guild] });
      }
      /**
       * Data that resolves to give an Invite object. This can be:
       * * An invite code
       * * An invite URL
       * @typedef {string} InviteResolvable
       */
      /**
       * Data that can be resolved to a channel that an invite can be created on. This can be:
       * * TextChannel
       * * VoiceChannel
       * * NewsChannel
       * * StageChannel
       * * ForumChannel
       * * MediaChannel
       * * Snowflake
       * @typedef {TextChannel|VoiceChannel|NewsChannel|StageChannel|ForumChannel|MediaChannel|Snowflake}
       * GuildInvitableChannelResolvable
       */
      /**
       * Resolves an InviteResolvable to an Invite object.
       * @method resolve
       * @memberof GuildInviteManager
       * @instance
       * @param {InviteResolvable} invite The invite resolvable to resolve
       * @returns {?Invite}
       */
      /**
       * Resolves an InviteResolvable to an invite code string.
       * @method resolveId
       * @memberof GuildInviteManager
       * @instance
       * @param {InviteResolvable} invite The invite resolvable to resolve
       * @returns {?string}
       */
      /**
       * Options used to fetch a single invite from a guild.
       * @typedef {Object} FetchInviteOptions
       * @property {InviteResolvable} code The invite to fetch
       * @property {boolean} [cache=true] Whether or not to cache the fetched invite
       * @property {boolean} [force=false] Whether to skip the cache check and request the API
       */
      /**
       * Options used to fetch all invites from a guild.
       * @typedef {Object} FetchInvitesOptions
       * @property {GuildInvitableChannelResolvable} [channelId]
       * The channel to fetch all invites from
       * @property {boolean} [cache=true] Whether or not to cache the fetched invites
       */
      /**
       * Fetches invite(s) from Discord.
       * @param {InviteResolvable|FetchInviteOptions|FetchInvitesOptions} [options] Options for fetching guild invite(s)
       * @returns {Promise<Invite|Collection<string, Invite>>}
       * @example
       * // Fetch all invites from a guild
       * guild.invites.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch all invites from a guild without caching
       * guild.invites.fetch({ cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch all invites from a channel
       * guild.invites.fetch({ channelId: '222197033908436994' })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single invite
       * guild.invites.fetch('bRCvFy9')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single invite without checking cache
       * guild.invites.fetch({ code: 'bRCvFy9', force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single invite without caching
       * guild.invites.fetch({ code: 'bRCvFy9', cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        if (!options)
          return this._fetchMany();
        if (typeof options === "string") {
          const code = DataResolver2.resolveInviteCode(options);
          if (!code)
            return Promise.reject(new DiscordjsError2(ErrorCodes2.InviteResolveCode));
          return this._fetchSingle({ code, cache: true });
        }
        if (!options.code) {
          if (options.channelId) {
            const id = this.guild.channels.resolveId(options.channelId);
            if (!id)
              return Promise.reject(new DiscordjsError2(ErrorCodes2.GuildChannelResolve));
            return this._fetchChannelMany(id, options.cache);
          }
          if ("cache" in options)
            return this._fetchMany(options.cache);
          return Promise.reject(new DiscordjsError2(ErrorCodes2.InviteResolveCode));
        }
        return this._fetchSingle({
          ...options,
          code: DataResolver2.resolveInviteCode(options.code)
        });
      }
      async _fetchSingle({ code, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(code);
          if (existing)
            return existing;
        }
        const invites = await this._fetchMany(cache);
        const invite = invites.get(code);
        if (!invite)
          throw new DiscordjsError2(ErrorCodes2.InviteNotFound);
        return invite;
      }
      async _fetchMany(cache) {
        const data = await this.client.rest.get(Routes2.guildInvites(this.guild.id));
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      async _fetchChannelMany(channelId, cache) {
        const data = await this.client.rest.get(Routes2.channelInvites(channelId));
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      /**
       * Create an invite to the guild from the provided channel.
       * @param {GuildInvitableChannelResolvable} channel The options for creating the invite from a channel.
       * @param {InviteCreateOptions} [options={}] The options for creating the invite from a channel.
       * @returns {Promise<Invite>}
       * @example
       * // Create an invite to a selected channel
       * guild.invites.create('599942732013764608')
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(channel, { temporary, maxAge, maxUses, unique: unique2, targetUser, targetApplication, targetType, reason } = {}) {
        const id = this.guild.channels.resolveId(channel);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        const invite = await this.client.rest.post(Routes2.channelInvites(id), {
          body: {
            temporary,
            max_age: maxAge,
            max_uses: maxUses,
            unique: unique2,
            target_user_id: this.client.users.resolveId(targetUser),
            target_application_id: (targetApplication == null ? void 0 : targetApplication.id) ?? (targetApplication == null ? void 0 : targetApplication.applicationId) ?? targetApplication,
            target_type: targetType
          },
          reason
        });
        return new Invite2(this.client, invite);
      }
      /**
       * Deletes an invite.
       * @param {InviteResolvable} invite The invite to delete
       * @param {string} [reason] Reason for deleting the invite
       * @returns {Promise<void>}
       */
      async delete(invite, reason) {
        const code = DataResolver2.resolveInviteCode(invite);
        await this.client.rest.delete(Routes2.invite(code), { reason });
      }
    };
    module2.exports = GuildInviteManager;
  }
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildMemberManager.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes2, GatewayOpcodes } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var { GuildMember } = require_GuildMember();
    var { Role } = require_Role();
    var Events2 = require_Events();
    var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
    var Partials = require_Partials();
    var GuildMemberManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildMember, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, GuildMember>}
       * @name GuildMemberManager#cache
       */
      _add(data, cache = true) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      /**
       * Data that resolves to give a GuildMember object. This can be:
       * * A GuildMember object
       * * A User resolvable
       * @typedef {GuildMember|UserResolvable} GuildMemberResolvable
       */
      /**
       * Resolves a {@link GuildMemberResolvable} to a {@link GuildMember} object.
       * @param {GuildMemberResolvable} member The user that is part of the guild
       * @returns {?GuildMember}
       */
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable)
          return super.resolve(userResolvable);
        return null;
      }
      /**
       * Resolves a {@link GuildMemberResolvable} to a member id.
       * @param {GuildMemberResolvable} member The user that is part of the guild
       * @returns {?Snowflake}
       */
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      /**
       * Options used to add a user to a guild using OAuth2.
       * @typedef {Object} AddGuildMemberOptions
       * @property {string} accessToken An OAuth2 access token for the user with the {@link OAuth2Scopes.GuildsJoin}
       * scope granted to the bot's application
       * @property {string} [nick] The nickname to give to the member
       * <info>This property requires the {@link PermissionFlagsBits.ManageNicknames} permission.</info>
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles to add to the member
       * <info>This property requires the {@link PermissionFlagsBits.ManageRoles} permission.</info>
       * @property {boolean} [mute] Whether the member should be muted
       * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>
       * @property {boolean} [deaf] Whether the member should be deafened
       * <info>This property requires the {@link PermissionFlagsBits.MuteMembers} permission.</info>
       * @property {boolean} [force] Whether to skip the cache check and request the API directly
       * @property {boolean} [fetchWhenExisting=true] Whether to fetch the user if not cached and already a member
       */
      /**
       * Adds a user to the guild using OAuth2.
       * <info>This method requires the {@link PermissionFlagsBits.CreateInstantInvite} permission.
       * @param {UserResolvable} user The user to add to the guild
       * @param {AddGuildMemberOptions} options Options for adding the user to the guild
       * @returns {Promise<?GuildMember>}
       */
      async add(user, options) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
        if (!options.force) {
          const cachedUser = this.cache.get(userId);
          if (cachedUser)
            return cachedUser;
        }
        const resolvedOptions = {
          access_token: options.accessToken,
          nick: options.nick,
          mute: options.mute,
          deaf: options.deaf
        };
        if (options.roles) {
          if (!Array.isArray(options.roles) && !(options.roles instanceof Collection2)) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "options.roles",
              "Array or Collection of Roles or Snowflakes",
              true
            );
          }
          const resolvedRoles = [];
          for (const role of options.roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "options.roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          resolvedOptions.roles = resolvedRoles;
        }
        const data = await this.client.rest.put(Routes2.guildMember(this.guild.id, userId), { body: resolvedOptions });
        return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
      }
      /**
       * The client user as a GuildMember of this guild
       * @type {?GuildMember}
       * @readonly
       */
      get me() {
        return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
      }
      /**
       * Options used to fetch a single member from a guild.
       * @typedef {BaseFetchOptions} FetchMemberOptions
       * @property {UserResolvable} user The user to fetch
       */
      /**
       * Options used to fetch multiple members from a guild.
       * @typedef {Object} FetchMembersOptions
       * @property {UserResolvable|UserResolvable[]} [user] The user(s) to fetch
       * @property {?string} [query] Limit fetch to members with similar usernames
       * @property {number} [limit=0] Maximum number of members to request
       * @property {boolean} [withPresences=false] Whether to include the presences
       * @property {number} [time=120e3] Timeout for receipt of members
       * @property {?string} [nonce] Nonce for this request (32 characters max - default to base 16 now timestamp)
       */
      /**
       * Fetches member(s) from a guild.
       * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] Options for fetching member(s).
       * Omitting the parameter or providing `undefined` will fetch all members.
       * @returns {Promise<GuildMember|Collection<Snowflake, GuildMember>>}
       * @example
       * // Fetch all members from a guild
       * guild.members.fetch()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single member
       * guild.members.fetch('66564597481480192')
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch a single member without checking cache
       * guild.members.fetch({ user, force: true })
       *   .then(console.log)
       *   .catch(console.error)
       * @example
       * // Fetch a single member without caching
       * guild.members.fetch({ user, cache: false })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch by an array of users including their presences
       * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Fetch by query
       * guild.members.fetch({ query: 'hydra', limit: 1 })
       *   .then(console.log)
       *   .catch(console.error);
       */
      fetch(options) {
        var _a;
        if (!options)
          return this._fetchMany();
        const { user: users, limit, withPresences, cache, force } = options;
        const resolvedUser = this.client.users.resolveId(users ?? options);
        if (resolvedUser && !limit && !withPresences)
          return this._fetchSingle({ user: resolvedUser, cache, force });
        const resolvedUsers = ((_a = users == null ? void 0 : users.map) == null ? void 0 : _a.call(users, (user) => this.client.users.resolveId(user))) ?? resolvedUser ?? void 0;
        return this._fetchMany({ ...options, users: resolvedUsers });
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildMember(this.guild.id, user));
        return this._add(data, cache);
      }
      _fetchMany({
        limit = 0,
        withPresences: presences,
        users,
        query,
        time = 12e4,
        nonce = DiscordSnowflake.generate().toString()
      } = {}) {
        if (nonce.length > 32)
          return Promise.reject(new DiscordjsRangeError2(ErrorCodes2.MemberFetchNonceLength));
        return new Promise((resolve, reject) => {
          if (!query && !users)
            query = "";
          this.guild.shard.send({
            op: GatewayOpcodes.RequestGuildMembers,
            d: {
              guild_id: this.guild.id,
              presences,
              user_ids: users,
              query,
              nonce,
              limit
            }
          });
          const fetchedMembers = new Collection2();
          let i = 0;
          const handler = (members, _, chunk) => {
            if (chunk.nonce !== nonce)
              return;
            timeout.refresh();
            i++;
            for (const member of members.values()) {
              fetchedMembers.set(member.id, member);
            }
            if (members.size < 1e3 || limit && fetchedMembers.size >= limit || i === chunk.count) {
              clearTimeout2(timeout);
              this.client.removeListener(Events2.GuildMembersChunk, handler);
              this.client.decrementMaxListeners();
              resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
            }
          };
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events2.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            reject(new DiscordjsError2(ErrorCodes2.GuildMembersTimeout));
          }, time).unref();
          this.client.incrementMaxListeners();
          this.client.on(Events2.GuildMembersChunk, handler);
        });
      }
      /**
       * Fetches the client user as a GuildMember of the guild.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<GuildMember>}
       */
      fetchMe(options) {
        return this.fetch({ ...options, user: this.client.user.id });
      }
      /**
       * Options used for searching guild members.
       * @typedef {Object} GuildSearchMembersOptions
       * @property {string} query Filter members whose username or nickname start with this query
       * @property {number} [limit] Maximum number of members to search
       * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)
       */
      /**
       * Searches for members in the guild based on a query.
       * @param {GuildSearchMembersOptions} options Options for searching members
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      async search({ query, limit, cache = true } = {}) {
        const data = await this.client.rest.get(Routes2.guildMembersSearch(this.guild.id), {
          query: makeURLSearchParams2({ query, limit })
        });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      /**
       * Options used for listing guild members.
       * @typedef {Object} GuildListMembersOptions
       * @property {Snowflake} [after] Limit fetching members to those with an id greater than the supplied id
       * @property {number} [limit] Maximum number of members to list
       * @property {boolean} [cache=true] Whether or not to cache the fetched member(s)
       */
      /**
       * Lists up to 1000 members of the guild.
       * @param {GuildListMembersOptions} [options] Options for listing members
       * @returns {Promise<Collection<Snowflake, GuildMember>>}
       */
      async list({ after, limit, cache = true } = {}) {
        const query = makeURLSearchParams2({ limit, after });
        const data = await this.client.rest.get(Routes2.guildMembers(this.guild.id), { query });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      /**
       * The data for editing a guild member.
       * @typedef {Object} GuildMemberEditOptions
       * @property {?string} [nick] The nickname to set for the member
       * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role ids to apply
       * @property {boolean} [mute] Whether or not the member should be muted
       * @property {boolean} [deaf] Whether or not the member should be deafened
       * @property {?GuildVoiceChannelResolvable} [channel] Channel to move the member to
       * (if they are connected to voice), or `null` if you want to disconnect them from voice
       * @property {?DateResolvable} [communicationDisabledUntil] The date or timestamp
       * for the member's communication to be disabled until. Provide `null` to enable communication again.
       * @property {GuildMemberFlagsResolvable} [flags] The flags to set for the member
       * @property {string} [reason] Reason for editing this user
       */
      /**
       * Edits a member of the guild.
       * <info>The user must be a member of the guild</info>
       * @param {UserResolvable} user The member to edit
       * @param {GuildMemberEditOptions} options The options to provide
       * @returns {Promise<GuildMember>}
       */
      async edit(user, { reason, ...options }) {
        var _a;
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
        if (options.channel) {
          options.channel = this.guild.channels.resolve(options.channel);
          if (!(options.channel instanceof BaseGuildVoiceChannel)) {
            throw new DiscordjsError2(ErrorCodes2.GuildVoiceChannelResolve);
          }
          options.channel_id = options.channel.id;
          options.channel = void 0;
        } else if (options.channel === null) {
          options.channel_id = null;
          options.channel = void 0;
        }
        options.roles && (options.roles = options.roles.map((role) => role instanceof Role ? role.id : role));
        if (options.communicationDisabledUntil !== void 0) {
          options.communication_disabled_until = // eslint-disable-next-line eqeqeq
          options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
        }
        if (options.flags !== void 0) {
          options.flags = GuildMemberFlagsBitField.resolve(options.flags);
        }
        let endpoint;
        if (id === this.client.user.id) {
          const keys = Object.keys(options);
          if (keys.length === 1 && keys[0] === "nick")
            endpoint = Routes2.guildMember(this.guild.id);
          else
            endpoint = Routes2.guildMember(this.guild.id, id);
        } else {
          endpoint = Routes2.guildMember(this.guild.id, id);
        }
        const d = await this.client.rest.patch(endpoint, { body: options, reason });
        const clone = (_a = this.cache.get(id)) == null ? void 0 : _a._clone();
        clone == null ? void 0 : clone._patch(d);
        return clone ?? this._add(d, false);
      }
      /**
       * Options used for pruning guild members.
       * <info>It's recommended to set {@link GuildPruneMembersOptions#count options.count}
       * to `false` for large guilds.</info>
       * @typedef {Object} GuildPruneMembersOptions
       * @property {number} [days] Number of days of inactivity required to kick
       * @property {boolean} [dry=false] Get the number of users that will be kicked, without actually kicking them
       * @property {boolean} [count] Whether or not to return the number of users that have been kicked.
       * @property {RoleResolvable[]} [roles] Array of roles to bypass the "...and no roles" constraint when pruning
       * @property {string} [reason] Reason for this prune
       */
      /**
       * Prunes members from the guild based on how long they have been inactive.
       * @param {GuildPruneMembersOptions} [options] Options for pruning
       * @returns {Promise<?number>} The number of members that were/will be kicked
       * @example
       * // See how many members will be pruned
       * guild.members.prune({ dry: true })
       *   .then(pruned => console.log(`This will prune ${pruned} people!`))
       *   .catch(console.error);
       * @example
       * // Actually prune the members
       * guild.members.prune({ days: 1, reason: 'too many people!' })
       *   .then(pruned => console.log(`I just pruned ${pruned} people!`))
       *   .catch(console.error);
       * @example
       * // Include members with a specified role
       * guild.members.prune({ days: 7, roles: ['657259391652855808'] })
       *    .then(pruned => console.log(`I just pruned ${pruned} people!`))
       *    .catch(console.error);
       */
      async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
        if (typeof days !== "number")
          throw new DiscordjsTypeError2(ErrorCodes2.PruneDaysType);
        const query = { days };
        const resolvedRoles = [];
        for (const role of roles) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        if (resolvedRoles.length) {
          query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
        }
        const endpoint = Routes2.guildPrune(this.guild.id);
        const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams2(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
        return pruned;
      }
      /**
       * Kicks a user from the guild.
       * <info>The user must be a member of the guild</info>
       * @param {UserResolvable} user The member to kick
       * @param {string} [reason] Reason for kicking
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user's id will be the result.
       * @example
       * // Kick a user by id (or with a user/guild member object)
       * guild.members.kick('84484653687267328')
       *   .then(kickInfo => console.log(`Kicked ${kickInfo.user?.tag ?? kickInfo.tag ?? kickInfo}`))
       *   .catch(console.error);
       */
      async kick(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id)
          return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable"));
        await this.client.rest.delete(Routes2.guildMember(this.guild.id, id), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
      }
      /**
       * Bans a user from the guild.
       * @param {UserResolvable} user The user to ban
       * @param {BanOptions} [options] Options for the ban
       * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.
       * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
       * be resolved, the user id will be the result.
       * Internally calls the GuildBanManager#create method.
       * @example
       * // Ban a user by id (or with a user/guild member object)
       * guild.members.ban('84484653687267328')
       *   .then(banInfo => console.log(`Banned ${banInfo.user?.tag ?? banInfo.tag ?? banInfo}`))
       *   .catch(console.error);
       */
      ban(user, options) {
        return this.guild.bans.create(user, options);
      }
      /**
       * Unbans a user from the guild. Internally calls the {@link GuildBanManager#remove} method.
       * @param {UserResolvable} user The user to unban
       * @param {string} [reason] Reason for unbanning user
       * @returns {Promise<?User>} The user that was unbanned
       * @example
       * // Unban a user by id (or with a user/guild member object)
       * guild.members.unban('84484653687267328')
       *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))
       *   .catch(console.error);
       */
      unban(user, reason) {
        return this.guild.bans.remove(user, reason);
      }
      /**
       * Options used for adding or removing a role from a member.
       * @typedef {Object} AddOrRemoveGuildMemberRoleOptions
       * @property {GuildMemberResolvable} user The user to add/remove the role from
       * @property {RoleResolvable} role The role to add/remove
       * @property {string} [reason] Reason for adding/removing the role
       */
      /**
       * Adds a role to a member.
       * @param {AddOrRemoveGuildMemberRoleOptions} options Options for adding the role
       * @returns {Promise<GuildMember|User|Snowflake>}
       */
      async addRole(options) {
        const { user, role, reason } = options;
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.rest.put(Routes2.guildMemberRole(this.guild.id, userId, roleId), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
      /**
       * Removes a role from a member.
       * @param {AddOrRemoveGuildMemberRoleOptions} options Options for removing the role
       * @returns {Promise<GuildMember|User|Snowflake>}
       */
      async removeRole(options) {
        const { user, role, reason } = options;
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.rest.delete(Routes2.guildMemberRole(this.guild.id, userId, roleId), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
    };
    module2.exports = GuildMemberManager;
  }
});

// node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildScheduledEventManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { GuildScheduledEventEntityType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var DataResolver2 = require_DataResolver();
    var GuildScheduledEventManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildScheduledEvent, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, GuildScheduledEvent>}
       * @name GuildScheduledEventManager#cache
       */
      /**
       * Data that resolves to give a GuildScheduledEvent object. This can be:
       * * A Snowflake
       * * A GuildScheduledEvent object
       * @typedef {Snowflake|GuildScheduledEvent} GuildScheduledEventResolvable
       */
      /**
       * Options used to create a guild scheduled event.
       * @typedef {Object} GuildScheduledEventCreateOptions
       * @property {string} name The name of the guild scheduled event
       * @property {DateResolvable} scheduledStartTime The time to schedule the event at
       * @property {DateResolvable} [scheduledEndTime] The time to end the event at
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>
       * @property {GuildScheduledEventPrivacyLevel} privacyLevel The privacy level of the guild scheduled event
       * @property {GuildScheduledEventEntityType} entityType The scheduled entity type of the event
       * @property {string} [description] The description of the guild scheduled event
       * @property {GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.StageInstance} or
       * {@link GuildScheduledEventEntityType.Voice}</warn>
       * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the
       * guild scheduled event
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>
       * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event
       * @property {string} [reason] The reason for creating the guild scheduled event
       */
      /**
       * Options used to set entity metadata of a guild scheduled event.
       * @typedef {Object} GuildScheduledEventEntityMetadataOptions
       * @property {string} [location] The location of the guild scheduled event
       * <warn>This is required if `entityType` is {@link GuildScheduledEventEntityType.External}</warn>
       */
      /**
       * Creates a new guild scheduled event.
       * @param {GuildScheduledEventCreateOptions} options Options for creating the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       */
      async create(options) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        let entity_metadata, channel_id;
        if (entityType === GuildScheduledEventEntityType.External) {
          channel_id = channel === void 0 ? channel : null;
          entity_metadata = { location: entityMetadata == null ? void 0 : entityMetadata.location };
        } else {
          channel_id = this.guild.channels.resolveId(channel);
          if (!channel_id)
            throw new DiscordjsError2(ErrorCodes2.GuildVoiceChannelResolve);
          entity_metadata = entityMetadata === void 0 ? entityMetadata : null;
        }
        const data = await this.client.rest.post(Routes2.guildScheduledEvents(this.guild.id), {
          body: {
            channel_id,
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: new Date(scheduledStartTime).toISOString(),
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            entity_metadata,
            image: image && await DataResolver2.resolveImage(image)
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Options used to fetch a single guild scheduled event from a guild.
       * @typedef {BaseFetchOptions} FetchGuildScheduledEventOptions
       * @property {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch
       * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to the scheduled event
       */
      /**
       * Options used to fetch multiple guild scheduled events from a guild.
       * @typedef {Object} FetchGuildScheduledEventsOptions
       * @property {boolean} [cache] Whether or not to cache the fetched guild scheduled events
       * @property {boolean} [withUserCount=true] Whether to fetch the number of users subscribed to each scheduled event
       * should be returned
       */
      /**
       * Obtains one or more guild scheduled events from Discord, or the guild cache if it's already available.
       * @param {GuildScheduledEventResolvable|FetchGuildScheduledEventOptions|FetchGuildScheduledEventsOptions} [options]
       * The id of the guild scheduled event or options
       * @returns {Promise<GuildScheduledEvent|Collection<Snowflake, GuildScheduledEvent>>}
       */
      async fetch(options = {}) {
        const id = this.resolveId(options.guildScheduledEvent ?? options);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const data2 = await this.client.rest.get(Routes2.guildScheduledEvent(this.guild.id, id), {
            query: makeURLSearchParams2({ with_user_count: options.withUserCount ?? true })
          });
          return this._add(data2, options.cache);
        }
        const data = await this.client.rest.get(Routes2.guildScheduledEvents(this.guild.id), {
          query: makeURLSearchParams2({ with_user_count: options.withUserCount ?? true })
        });
        return data.reduce(
          (coll, rawGuildScheduledEventData) => coll.set(
            rawGuildScheduledEventData.id,
            this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)
          ),
          new Collection2()
        );
      }
      /**
       * Options used to edit a guild scheduled event.
       * @typedef {Object} GuildScheduledEventEditOptions
       * @property {string} [name] The name of the guild scheduled event
       * @property {DateResolvable} [scheduledStartTime] The time to schedule the event at
       * @property {DateResolvable} [scheduledEndTime] The time to end the event at
       * @property {GuildScheduledEventPrivacyLevel} [privacyLevel] The privacy level of the guild scheduled event
       * @property {GuildScheduledEventEntityType} [entityType] The scheduled entity type of the event
       * @property {string} [description] The description of the guild scheduled event
       * @property {?GuildVoiceChannelResolvable} [channel] The channel of the guild scheduled event
       * @property {GuildScheduledEventStatus} [status] The status of the guild scheduled event
       * @property {GuildScheduledEventEntityMetadataOptions} [entityMetadata] The entity metadata of the
       * guild scheduled event
       * <warn>This can be modified only if `entityType` of the `GuildScheduledEvent` to be edited is
       * {@link GuildScheduledEventEntityType.External}</warn>
       * @property {?(BufferResolvable|Base64Resolvable)} [image] The cover image of the guild scheduled event
       * @property {string} [reason] The reason for editing the guild scheduled event
       */
      /**
       * Edits a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to edit
       * @param {GuildScheduledEventEditOptions} options Options to edit the guild scheduled event
       * @returns {Promise<GuildScheduledEvent>}
       */
      async edit(guildScheduledEvent, options) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          status,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        let entity_metadata;
        if (entityMetadata) {
          entity_metadata = {
            location: entityMetadata.location
          };
        }
        const data = await this.client.rest.patch(Routes2.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
          body: {
            channel_id: channel === void 0 ? channel : this.guild.channels.resolveId(channel),
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : void 0,
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            status,
            image: image && await DataResolver2.resolveImage(image),
            entity_metadata
          },
          reason
        });
        return this._add(data);
      }
      /**
       * Deletes a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to delete
       * @returns {Promise<void>}
       */
      async delete(guildScheduledEvent) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        await this.client.rest.delete(Routes2.guildScheduledEvent(this.guild.id, guildScheduledEventId));
      }
      /**
       * Options used to fetch subscribers of a guild scheduled event
       * @typedef {Object} FetchGuildScheduledEventSubscribersOptions
       * @property {number} [limit] The maximum numbers of users to fetch
       * @property {boolean} [withMember] Whether to fetch guild member data of the users
       * @property {Snowflake} [before] Consider only users before this user id
       * @property {Snowflake} [after] Consider only users after this user id
       * <warn>If both `before` and `after` are provided, only `before` is respected</warn>
       */
      /**
       * Represents a subscriber of a {@link GuildScheduledEvent}
       * @typedef {Object} GuildScheduledEventUser
       * @property {Snowflake} guildScheduledEventId The id of the guild scheduled event which the user subscribed to
       * @property {User} user The user that subscribed to the guild scheduled event
       * @property {?GuildMember} member The guild member associated with the user, if any
       */
      /**
       * Fetches subscribers of a guild scheduled event.
       * @param {GuildScheduledEventResolvable} guildScheduledEvent The guild scheduled event to fetch subscribers of
       * @param {FetchGuildScheduledEventSubscribersOptions} [options={}] Options for fetching the subscribers
       * @returns {Promise<Collection<Snowflake, GuildScheduledEventUser>>}
       */
      async fetchSubscribers(guildScheduledEvent, options = {}) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        const query = makeURLSearchParams2({
          limit: options.limit,
          with_member: options.withMember,
          before: options.before,
          after: options.after
        });
        const data = await this.client.rest.get(Routes2.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
          query
        });
        return data.reduce(
          (coll, rawData) => coll.set(rawData.user.id, {
            guildScheduledEventId: rawData.guild_scheduled_event_id,
            user: this.client.users._add(rawData.user),
            member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
          }),
          new Collection2()
        );
      }
    };
    module2.exports = GuildScheduledEventManager;
  }
});

// node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildStickerManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var MessagePayload = require_MessagePayload();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildStickerManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Sticker2, iterable);
        this.guild = guild;
      }
      /**
       * The cache of Guild Stickers
       * @type {Collection<Snowflake, Sticker>}
       * @name GuildStickerManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Options used to create a guild sticker.
       * @typedef {Object} GuildStickerCreateOptions
       * @property {AttachmentPayload|BufferResolvable|Stream} file The file for the sticker
       * @property {string} name The name for the sticker
       * @property {string} tags The Discord name of a unicode emoji representing the sticker's expression
       * @property {?string} [description] The description for the sticker
       * @property {string} [reason] Reason for creating the sticker
       */
      /**
       * Creates a new custom sticker in the guild.
       * @param {GuildStickerCreateOptions} options Options for creating a guild sticker
       * @returns {Promise<Sticker>} The created sticker
       * @example
       * // Create a new sticker from a URL
       * guild.stickers.create({ file: 'https://i.imgur.com/w3duR07.png', name: 'rip', tags: 'headstone' })
       *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))
       *   .catch(console.error);
       * @example
       * // Create a new sticker from a file on your computer
       * guild.stickers.create({ file: './memes/banana.png', name: 'banana', tags: 'banana' })
       *   .then(sticker => console.log(`Created new sticker with name ${sticker.name}!`))
       *   .catch(console.error);
       */
      async create({ file, name, tags, description, reason } = {}) {
        const resolvedFile = await MessagePayload.resolveFile(file);
        if (!resolvedFile)
          throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
        file = { ...resolvedFile, key: "file" };
        const body = { name, tags, description: description ?? "" };
        const sticker = await this.client.rest.post(Routes2.guildStickers(this.guild.id), {
          appendToFormData: true,
          body,
          files: [file],
          reason
        });
        return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
      }
      /**
       * Data that resolves to give a Sticker object. This can be:
       * * A Sticker object
       * * A Snowflake
       * @typedef {Sticker|Snowflake} StickerResolvable
       */
      /**
       * Resolves a StickerResolvable to a Sticker object.
       * @method resolve
       * @memberof GuildStickerManager
       * @instance
       * @param {StickerResolvable} sticker The Sticker resolvable to identify
       * @returns {?Sticker}
       */
      /**
       * Resolves a StickerResolvable to a Sticker id string.
       * @method resolveId
       * @memberof GuildStickerManager
       * @instance
       * @param {StickerResolvable} sticker The Sticker resolvable to identify
       * @returns {?Snowflake}
       */
      /**
       * Edits a sticker.
       * @param {StickerResolvable} sticker The sticker to edit
       * @param {GuildStickerEditOptions} [options={}] The new data for the sticker
       * @returns {Promise<Sticker>}
       */
      async edit(sticker, options = {}) {
        const stickerId = this.resolveId(sticker);
        if (!stickerId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        const d = await this.client.rest.patch(Routes2.guildSticker(this.guild.id, stickerId), {
          body: options,
          reason: options.reason
        });
        const existing = this.cache.get(stickerId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      /**
       * Deletes a sticker.
       * @param {StickerResolvable} sticker The sticker to delete
       * @param {string} [reason] Reason for deleting this sticker
       * @returns {Promise<void>}
       */
      async delete(sticker, reason) {
        sticker = this.resolveId(sticker);
        if (!sticker)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        await this.client.rest.delete(Routes2.guildSticker(this.guild.id, sticker), { reason });
      }
      /**
       * Obtains one or more stickers from Discord, or the sticker cache if they're already available.
       * @param {Snowflake} [id] The Sticker's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<Sticker|Collection<Snowflake, Sticker>>}
       * @example
       * // Fetch all stickers from the guild
       * message.guild.stickers.fetch()
       *   .then(stickers => console.log(`There are ${stickers.size} stickers.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single sticker
       * message.guild.stickers.fetch('222078108977594368')
       *   .then(sticker => console.log(`The sticker name is: ${sticker.name}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const sticker = await this.client.rest.get(Routes2.guildSticker(this.guild.id, id));
          return this._add(sticker, cache);
        }
        const data = await this.client.rest.get(Routes2.guildStickers(this.guild.id));
        return new Collection2(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
      }
      /**
       * Fetches the user who uploaded this sticker, if this is a guild sticker.
       * @param {StickerResolvable} sticker The sticker to fetch the user for
       * @returns {Promise<?User>}
       */
      async fetchUser(sticker) {
        sticker = this.resolve(sticker);
        if (!sticker)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        const data = await this.client.rest.get(Routes2.guildSticker(this.guild.id, sticker.id));
        sticker._patch(data);
        return sticker.user;
      }
    };
    module2.exports = GuildStickerManager;
  }
});

// node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/ActivityFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ActivityFlags } = require_v106();
    var BitField = require_BitField();
    var ActivityFlagsBitField = class extends BitField {
    };
    /**
     * Numeric activity flags.
     * @type {ActivityFlags}
     * @memberof ActivityFlagsBitField
     */
    __publicField(ActivityFlagsBitField, "Flags", ActivityFlags);
    module2.exports = ActivityFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS({
  "node_modules/discord.js/src/structures/Presence.js"(exports2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var ActivityFlagsBitField = require_ActivityFlagsBitField();
    var { flatten } = require_Util();
    var Presence = class extends Base {
      constructor(client, data = {}) {
        super(client);
        this.userId = data.user.id;
        this.guild = data.guild ?? null;
        this._patch(data);
      }
      /**
       * The user of this presence
       * @type {?User}
       * @readonly
       */
      get user() {
        return this.client.users.resolve(this.userId);
      }
      /**
       * The member of this presence
       * @type {?GuildMember}
       * @readonly
       */
      get member() {
        return this.guild.members.resolve(this.userId);
      }
      _patch(data) {
        if ("status" in data) {
          this.status = data.status;
        } else {
          this.status ?? (this.status = "offline");
        }
        if ("activities" in data) {
          this.activities = data.activities.map((activity) => new Activity(this, activity));
        } else {
          this.activities ?? (this.activities = []);
        }
        if ("client_status" in data) {
          this.clientStatus = data.client_status;
        } else {
          this.clientStatus ?? (this.clientStatus = null);
        }
        return this;
      }
      _clone() {
        const clone = Object.assign(Object.create(this), this);
        clone.activities = this.activities.map((activity) => activity._clone());
        return clone;
      }
      /**
       * Whether this presence is equal to another.
       * @param {Presence} presence The presence to compare with
       * @returns {boolean}
       */
      equals(presence) {
        var _a, _b, _c, _d, _e, _f;
        return this === presence || presence && this.status === presence.status && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index])) && ((_a = this.clientStatus) == null ? void 0 : _a.web) === ((_b = presence.clientStatus) == null ? void 0 : _b.web) && ((_c = this.clientStatus) == null ? void 0 : _c.mobile) === ((_d = presence.clientStatus) == null ? void 0 : _d.mobile) && ((_e = this.clientStatus) == null ? void 0 : _e.desktop) === ((_f = presence.clientStatus) == null ? void 0 : _f.desktop);
      }
      toJSON() {
        return flatten(this);
      }
    };
    var Activity = class {
      constructor(presence, data) {
        Object.defineProperty(this, "presence", { value: presence });
        this.name = data.name;
        this.type = data.type;
        this.url = data.url ?? null;
        this.details = data.details ?? null;
        this.state = data.state ?? null;
        this.applicationId = data.application_id ?? null;
        this.timestamps = data.timestamps ? {
          start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
          end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
        } : null;
        this.party = data.party ?? null;
        this.syncId = data.sync_id ?? null;
        this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
        this.flags = new ActivityFlagsBitField(data.flags).freeze();
        this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
        this.buttons = data.buttons ?? [];
        this.createdTimestamp = data.created_at;
      }
      /**
       * Whether this activity is equal to another activity.
       * @param {Activity} activity The activity to compare with
       * @returns {boolean}
       */
      equals(activity) {
        var _a, _b, _c, _d;
        return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && ((_a = this.emoji) == null ? void 0 : _a.id) === ((_b = activity.emoji) == null ? void 0 : _b.id) && ((_c = this.emoji) == null ? void 0 : _c.name) === ((_d = activity.emoji) == null ? void 0 : _d.name);
      }
      /**
       * The time the activity was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * When concatenated with a string, this automatically returns the activity's name instead of the Activity object.
       * @returns {string}
       */
      toString() {
        return this.name;
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
    };
    var RichPresenceAssets = class {
      constructor(activity, assets) {
        Object.defineProperty(this, "activity", { value: activity });
        this.largeText = assets.large_text ?? null;
        this.smallText = assets.small_text ?? null;
        this.largeImage = assets.large_image ?? null;
        this.smallImage = assets.small_image ?? null;
      }
      /**
       * Gets the URL of the small image asset
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      smallImageURL(options = {}) {
        if (!this.smallImage)
          return null;
        if (this.smallImage.includes(":")) {
          const [platform, id] = this.smallImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
      }
      /**
       * Gets the URL of the large image asset
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      largeImageURL(options = {}) {
        if (!this.largeImage)
          return null;
        if (this.largeImage.includes(":")) {
          const [platform, id] = this.largeImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            case "spotify":
              return `https://i.scdn.co/image/${id}`;
            case "youtube":
              return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
            case "twitch":
              return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
      }
    };
    exports2.Presence = Presence;
    exports2.Activity = Activity;
    exports2.RichPresenceAssets = RichPresenceAssets;
  }
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS({
  "node_modules/discord.js/src/managers/PresenceManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var { Presence } = require_Presence();
    var PresenceManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Presence, iterable);
      }
      /**
       * The cache of Presences
       * @type {Collection<Snowflake, Presence>}
       * @name PresenceManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id });
      }
      /**
       * Data that can be resolved to a Presence object. This can be:
       * * A Presence
       * * A UserResolvable
       * * A Snowflake
       * @typedef {Presence|UserResolvable|Snowflake} PresenceResolvable
       */
      /**
       * Resolves a {@link PresenceResolvable} to a {@link Presence} object.
       * @param {PresenceResolvable} presence The presence resolvable to resolve
       * @returns {?Presence}
       */
      resolve(presence) {
        const presenceResolvable = super.resolve(presence);
        if (presenceResolvable)
          return presenceResolvable;
        const UserResolvable = this.client.users.resolveId(presence);
        return super.resolve(UserResolvable);
      }
      /**
       * Resolves a {@link PresenceResolvable} to a {@link Presence} id.
       * @param {PresenceResolvable} presence The presence resolvable to resolve
       * @returns {?Snowflake}
       */
      resolveId(presence) {
        const presenceResolvable = super.resolveId(presence);
        if (presenceResolvable)
          return presenceResolvable;
        const userResolvable = this.client.users.resolveId(presence);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
    };
    module2.exports = PresenceManager;
  }
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS({
  "node_modules/discord.js/src/managers/RoleManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var PermissionsBitField2 = require_PermissionsBitField();
    var { setPosition, resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var RoleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Role, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      /**
       * The role cache of this manager
       * @type {Collection<Snowflake, Role>}
       * @name RoleManager#cache
       */
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      /**
       * Obtains a role from Discord, or the role cache if they're already available.
       * @param {Snowflake} [id] The role's id
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<?Role|Collection<Snowflake, Role>>}
       * @example
       * // Fetch all roles from the guild
       * message.guild.roles.fetch()
       *   .then(roles => console.log(`There are ${roles.size} roles.`))
       *   .catch(console.error);
       * @example
       * // Fetch a single role
       * message.guild.roles.fetch('222078108977594368')
       *   .then(role => console.log(`The role color is: ${role.color}`))
       *   .catch(console.error);
       */
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.guildRoles(this.guild.id));
        const roles = new Collection2();
        for (const role of data)
          roles.set(role.id, this._add(role, cache));
        return id ? roles.get(id) ?? null : roles;
      }
      /**
       * Data that can be resolved to a Role object. This can be:
       * * A Role
       * * A Snowflake
       * @typedef {Role|Snowflake} RoleResolvable
       */
      /**
       * Resolves a {@link RoleResolvable} to a {@link Role} object.
       * @method resolve
       * @memberof RoleManager
       * @instance
       * @param {RoleResolvable} role The role resolvable to resolve
       * @returns {?Role}
       */
      /**
       * Resolves a {@link RoleResolvable} to a {@link Role} id.
       * @method resolveId
       * @memberof RoleManager
       * @instance
       * @param {RoleResolvable} role The role resolvable to resolve
       * @returns {?Snowflake}
       */
      /**
       * Options used to create a new role.
       * @typedef {Object} RoleCreateOptions
       * @property {string} [name] The name of the new role
       * @property {ColorResolvable} [color] The data to create the role with
       * @property {boolean} [hoist] Whether or not the new role should be hoisted
       * @property {PermissionResolvable} [permissions] The permissions for the new role
       * @property {number} [position] The position of the new role
       * @property {boolean} [mentionable] Whether or not the new role should be mentionable
       * @property {?(BufferResolvable|Base64Resolvable|EmojiResolvable)} [icon] The icon for the role
       * <warn>The `EmojiResolvable` should belong to the same guild as the role.
       * If not, pass the emoji's URL directly</warn>
       * @property {?string} [unicodeEmoji] The unicode emoji for the role
       * @property {string} [reason] The reason for creating this role
       */
      /**
       * Creates a new role in the guild with given information.
       * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>
       * @param {RoleCreateOptions} [options] Options for creating the new role
       * @returns {Promise<Role>}
       * @example
       * // Create a new role
       * guild.roles.create()
       *   .then(console.log)
       *   .catch(console.error);
       * @example
       * // Create a new role with data and a reason
       * guild.roles.create({
       *   name: 'Super Cool Blue People',
       *   color: Colors.Blue,
       *   reason: 'we needed a role for Super Cool People',
       * })
       *   .then(console.log)
       *   .catch(console.error);
       */
      async create(options = {}) {
        var _a;
        let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
        color && (color = resolveColor(color));
        if (permissions !== void 0)
          permissions = new PermissionsBitField2(permissions);
        if (icon) {
          const guildEmojiURL = (_a = this.guild.emojis.resolve(icon)) == null ? void 0 : _a.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string")
            icon = void 0;
        }
        const data = await this.client.rest.post(Routes2.guildRoles(this.guild.id), {
          body: {
            name,
            color,
            hoist,
            permissions,
            mentionable,
            icon,
            unicode_emoji: unicodeEmoji
          },
          reason
        });
        const { role } = this.client.actions.GuildRoleCreate.handle({
          guild_id: this.guild.id,
          role: data
        });
        if (position)
          return this.setPosition(role, position, { reason });
        return role;
      }
      /**
       * Options for editing a role
       * @typedef {RoleData} RoleEditOptions
       * @property {string} [reason] The reason for editing this role
       */
      /**
       * Edits a role of the guild.
       * @param {RoleResolvable} role The role to edit
       * @param {RoleEditOptions} options The options to provide
       * @returns {Promise<Role>}
       * @example
       * // Edit a role
       * guild.roles.edit('222079219327434752', { name: 'buddies' })
       *   .then(updated => console.log(`Edited role name to ${updated.name}`))
       *   .catch(console.error);
       */
      async edit(role, options) {
        var _a;
        role = this.resolve(role);
        if (!role)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "RoleResolvable");
        if (typeof options.position === "number") {
          await this.setPosition(role, options.position, { reason: options.reason });
        }
        let icon = options.icon;
        if (icon) {
          const guildEmojiURL = (_a = this.guild.emojis.resolve(icon)) == null ? void 0 : _a.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string")
            icon = void 0;
        }
        const body = {
          name: options.name,
          color: options.color === void 0 ? void 0 : resolveColor(options.color),
          hoist: options.hoist,
          permissions: options.permissions === void 0 ? void 0 : new PermissionsBitField2(options.permissions),
          mentionable: options.mentionable,
          icon,
          unicode_emoji: options.unicodeEmoji
        };
        const d = await this.client.rest.patch(Routes2.guildRole(this.guild.id, role.id), { body, reason: options.reason });
        const clone = role._clone();
        clone._patch(d);
        return clone;
      }
      /**
       * Deletes a role.
       * @param {RoleResolvable} role The role to delete
       * @param {string} [reason] Reason for deleting the role
       * @returns {Promise<void>}
       * @example
       * // Delete a role
       * guild.roles.delete('222079219327434752', 'The role needed to go')
       *   .then(() => console.log('Deleted the role'))
       *   .catch(console.error);
       */
      async delete(role, reason) {
        const id = this.resolveId(role);
        await this.client.rest.delete(Routes2.guildRole(this.guild.id, id), { reason });
        this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
      }
      /**
       * Sets the new position of the role.
       * @param {RoleResolvable} role The role to change the position of
       * @param {number} position The new position for the role
       * @param {SetRolePositionOptions} [options] Options for setting the position
       * @returns {Promise<Role>}
       * @example
       * // Set the position of the role
       * guild.roles.setPosition('222197033908436994', 1)
       *   .then(updated => console.log(`Role position: ${updated.position}`))
       *   .catch(console.error);
       */
      async setPosition(role, position, { relative, reason } = {}) {
        role = this.resolve(role);
        if (!role)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "RoleResolvable");
        const updatedRoles = await setPosition(
          role,
          position,
          relative,
          this.guild._sortedRoles(),
          this.client,
          Routes2.guildRoles(this.guild.id),
          reason
        );
        this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: updatedRoles
        });
        return role;
      }
      /**
       * The data needed for updating a guild role's position
       * @typedef {Object} GuildRolePosition
       * @property {RoleResolvable} role The role's id
       * @property {number} position The position to update
       */
      /**
       * Batch-updates the guild's role positions
       * @param {GuildRolePosition[]} rolePositions Role positions to update
       * @returns {Promise<Guild>}
       * @example
       * guild.roles.setPositions([{ role: roleId, position: updatedRoleIndex }])
       *  .then(guild => console.log(`Role positions updated for ${guild}`))
       *  .catch(console.error);
       */
      async setPositions(rolePositions) {
        rolePositions = rolePositions.map((rolePosition) => ({
          id: this.resolveId(rolePosition.role),
          position: rolePosition.position
        }));
        await this.client.rest.patch(Routes2.guildRoles(this.guild.id), { body: rolePositions });
        return this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: rolePositions
        }).guild;
      }
      /**
       * Compares the positions of two roles.
       * @param {RoleResolvable} role1 First role to compare
       * @param {RoleResolvable} role2 Second role to compare
       * @returns {number} Negative number if the first role's position is lower (second role's is higher),
       * positive number if the first's is higher (second's is lower), 0 if equal
       */
      comparePositions(role1, role2) {
        const resolvedRole1 = this.resolve(role1);
        const resolvedRole2 = this.resolve(role2);
        if (!resolvedRole1 || !resolvedRole2) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "Role nor a Snowflake");
        }
        const role1Position = resolvedRole1.position;
        const role2Position = resolvedRole2.position;
        if (role1Position === role2Position) {
          return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
        }
        return role1Position - role2Position;
      }
      /**
       * Gets the managed role a user created when joining the guild, if any
       * <info>Only ever available for bots</info>
       * @param {UserResolvable} user The user to access the bot role for
       * @returns {?Role}
       */
      botRoleFor(user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          return null;
        return this.cache.find((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.botId) === userId;
        }) ?? null;
      }
      /**
       * The `@everyone` role of the guild
       * @type {Role}
       * @readonly
       */
      get everyone() {
        return this.cache.get(this.guild.id);
      }
      /**
       * The premium subscriber role of the guild, if any
       * @type {?Role}
       * @readonly
       */
      get premiumSubscriberRole() {
        return this.cache.find((role) => {
          var _a;
          return (_a = role.tags) == null ? void 0 : _a.premiumSubscriberRole;
        }) ?? null;
      }
      /**
       * The role with the highest position in the cache
       * @type {Role}
       * @readonly
       */
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
    };
    module2.exports = RoleManager;
  }
});

// node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS({
  "node_modules/discord.js/src/managers/StageInstanceManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { StageInstance } = require_StageInstance();
    var StageInstanceManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, StageInstance, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, StageInstance>}
       * @name StageInstanceManager#cache
       */
      /**
       * Options used to create a stage instance.
       * @typedef {Object} StageInstanceCreateOptions
       * @property {string} topic The topic of the stage instance
       * @property {StageInstancePrivacyLevel} [privacyLevel] The privacy level of the stage instance
       * @property {boolean} [sendStartNotification] Whether to notify `@everyone` that the stage instance has started
       * @property {GuildScheduledEventResolvable} [guildScheduledEvent]
       * The guild scheduled event associated with the stage instance
       */
      /**
       * Data that can be resolved to a Stage Channel object. This can be:
       * * A StageChannel
       * * A Snowflake
       * @typedef {StageChannel|Snowflake} StageChannelResolvable
       */
      /**
       * Creates a new stage instance.
       * @param {StageChannelResolvable} channel The stage channel to associate the created stage instance to
       * @param {StageInstanceCreateOptions} options The options to create the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Create a stage instance
       * guild.stageInstances.create('1234567890123456789', {
       *  topic: 'A very creative topic',
       *  privacyLevel: GuildPrivacyLevel.GuildOnly
       * })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async create(channel, options) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const { guildScheduledEvent, topic, privacyLevel, sendStartNotification } = options;
        const guildScheduledEventId = guildScheduledEvent && this.resolveId(guildScheduledEvent);
        const data = await this.client.rest.post(Routes2.stageInstances(), {
          body: {
            channel_id: channelId,
            topic,
            privacy_level: privacyLevel,
            send_start_notification: sendStartNotification,
            guild_scheduled_event_id: guildScheduledEventId
          }
        });
        return this._add(data);
      }
      /**
       * Fetches the stage instance associated with a stage channel, if it exists.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be fetched
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<StageInstance>}
       * @example
       * // Fetch a stage instance
       * guild.stageInstances.fetch('1234567890123456789')
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async fetch(channel, { cache = true, force = false } = {}) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        if (!force) {
          const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.stageInstance(channelId));
        return this._add(data, cache);
      }
      /**
       * Options used to edit an existing stage instance.
       * @typedef {Object} StageInstanceEditOptions
       * @property {string} [topic] The new topic of the stage instance
       * @property {StageInstancePrivacyLevel} [privacyLevel] The new privacy level of the stage instance
       */
      /**
       * Edits an existing stage instance.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be edited
       * @param {StageInstanceEditOptions} options The options to edit the stage instance
       * @returns {Promise<StageInstance>}
       * @example
       * // Edit a stage instance
       * guild.stageInstances.edit('1234567890123456789', { topic: 'new topic' })
       *  .then(stageInstance => console.log(stageInstance))
       *  .catch(console.error);
       */
      async edit(channel, options) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        let { topic, privacyLevel } = options;
        const data = await this.client.rest.patch(Routes2.stageInstance(channelId), {
          body: {
            topic,
            privacy_level: privacyLevel
          }
        });
        if (this.cache.has(data.id)) {
          const clone = this.cache.get(data.id)._clone();
          clone._patch(data);
          return clone;
        }
        return this._add(data);
      }
      /**
       * Deletes an existing stage instance.
       * @param {StageChannelResolvable} channel The stage channel whose associated stage instance is to be deleted
       * @returns {Promise<void>}
       */
      async delete(channel) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        await this.client.rest.delete(Routes2.stageInstance(channelId));
      }
    };
    module2.exports = StageInstanceManager;
  }
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS({
  "node_modules/discord.js/src/managers/VoiceStateManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var VoiceState = require_VoiceState();
    var VoiceStateManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, VoiceState, iterable);
        this.guild = guild;
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, VoiceState>}
       * @name VoiceStateManager#cache
       */
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (existing)
          return existing._patch(data);
        const entry = new this.holds(this.guild, data);
        if (cache)
          this.cache.set(data.user_id, entry);
        return entry;
      }
    };
    module2.exports = VoiceStateManager;
  }
});

// node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS({
  "node_modules/discord.js/src/util/SystemChannelFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { GuildSystemChannelFlags } = require_v106();
    var BitField = require_BitField();
    var SystemChannelFlagsBitField = class extends BitField {
    };
    /**
     * Numeric system channel flags.
     * @type {GuildSystemChannelFlags}
     * @memberof SystemChannelFlagsBitField
     */
    __publicField(SystemChannelFlagsBitField, "Flags", GuildSystemChannelFlags);
    module2.exports = SystemChannelFlagsBitField;
  }
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS({
  "node_modules/discord.js/src/structures/Guild.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { DiscordSnowflake } = require_dist3();
    var { ChannelType, GuildPremiumTier, Routes: Routes2, GuildFeature } = require_v106();
    var AnonymousGuild = require_AnonymousGuild();
    var GuildAuditLogs = require_GuildAuditLogs();
    var { GuildOnboarding } = require_GuildOnboarding();
    var GuildPreview2 = require_GuildPreview();
    var GuildTemplate2 = require_GuildTemplate();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var WelcomeScreen = require_WelcomeScreen();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var AutoModerationRuleManager = require_AutoModerationRuleManager();
    var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
    var GuildBanManager = require_GuildBanManager();
    var GuildChannelManager = require_GuildChannelManager();
    var GuildEmojiManager = require_GuildEmojiManager();
    var GuildInviteManager = require_GuildInviteManager();
    var GuildMemberManager = require_GuildMemberManager();
    var GuildScheduledEventManager = require_GuildScheduledEventManager();
    var GuildStickerManager = require_GuildStickerManager();
    var PresenceManager = require_PresenceManager();
    var RoleManager = require_RoleManager();
    var StageInstanceManager = require_StageInstanceManager();
    var VoiceStateManager = require_VoiceStateManager();
    var DataResolver2 = require_DataResolver();
    var Status2 = require_Status();
    var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    var { discordSort, getSortableGroupTypes, resolvePartialEmoji } = require_Util();
    var Guild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data, false);
        this.commands = new GuildApplicationCommandManager(this);
        this.members = new GuildMemberManager(this);
        this.channels = new GuildChannelManager(this);
        this.bans = new GuildBanManager(this);
        this.roles = new RoleManager(this);
        this.presences = new PresenceManager(this.client);
        this.voiceStates = new VoiceStateManager(this);
        this.stageInstances = new StageInstanceManager(this);
        this.invites = new GuildInviteManager(this);
        this.scheduledEvents = new GuildScheduledEventManager(this);
        this.autoModerationRules = new AutoModerationRuleManager(this);
        if (!data)
          return;
        if (data.unavailable) {
          this.available = false;
        } else {
          this._patch(data);
          if (!data.channels)
            this.available = false;
        }
        this.shardId = data.shardId;
      }
      /**
       * The Shard this Guild belongs to.
       * @type {WebSocketShard}
       * @readonly
       */
      get shard() {
        return this.client.ws.shards.get(this.shardId);
      }
      _patch(data) {
        super._patch(data);
        this.id = data.id;
        if ("name" in data)
          this.name = data.name;
        if ("icon" in data)
          this.icon = data.icon;
        if ("unavailable" in data) {
          this.available = !data.unavailable;
        } else {
          this.available ?? (this.available = true);
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        }
        if ("large" in data) {
          this.large = Boolean(data.large);
        }
        if ("premium_progress_bar_enabled" in data) {
          this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        }
        if ("afk_timeout" in data) {
          this.afkTimeout = data.afk_timeout;
        }
        if ("afk_channel_id" in data) {
          this.afkChannelId = data.afk_channel_id;
        }
        if ("system_channel_id" in data) {
          this.systemChannelId = data.system_channel_id;
        }
        if ("premium_tier" in data) {
          this.premiumTier = data.premium_tier;
        }
        if ("widget_enabled" in data) {
          this.widgetEnabled = data.widget_enabled;
        } else {
          this.widgetEnabled ?? (this.widgetEnabled = null);
        }
        if ("widget_channel_id" in data) {
          this.widgetChannelId = data.widget_channel_id;
        } else {
          this.widgetChannelId ?? (this.widgetChannelId = null);
        }
        if ("explicit_content_filter" in data) {
          this.explicitContentFilter = data.explicit_content_filter;
        }
        if ("mfa_level" in data) {
          this.mfaLevel = data.mfa_level;
        }
        if ("joined_at" in data) {
          this.joinedTimestamp = Date.parse(data.joined_at);
        }
        if ("default_message_notifications" in data) {
          this.defaultMessageNotifications = data.default_message_notifications;
        }
        if ("system_channel_flags" in data) {
          this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
        }
        if ("max_members" in data) {
          this.maximumMembers = data.max_members;
        } else {
          this.maximumMembers ?? (this.maximumMembers = null);
        }
        if ("max_presences" in data) {
          this.maximumPresences = data.max_presences;
        } else {
          this.maximumPresences ?? (this.maximumPresences = null);
        }
        if ("max_video_channel_users" in data) {
          this.maxVideoChannelUsers = data.max_video_channel_users;
        } else {
          this.maxVideoChannelUsers ?? (this.maxVideoChannelUsers = null);
        }
        if ("max_stage_video_channel_users" in data) {
          this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
        } else {
          this.maxStageVideoChannelUsers ?? (this.maxStageVideoChannelUsers = null);
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        } else {
          this.approximateMemberCount ?? (this.approximateMemberCount = null);
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        } else {
          this.approximatePresenceCount ?? (this.approximatePresenceCount = null);
        }
        this.vanityURLUses ?? (this.vanityURLUses = null);
        if ("rules_channel_id" in data) {
          this.rulesChannelId = data.rules_channel_id;
        }
        if ("public_updates_channel_id" in data) {
          this.publicUpdatesChannelId = data.public_updates_channel_id;
        }
        if ("preferred_locale" in data) {
          this.preferredLocale = data.preferred_locale;
        }
        if ("safety_alerts_channel_id" in data) {
          this.safetyAlertsChannelId = data.safety_alerts_channel_id;
        } else {
          this.safetyAlertsChannelId ?? (this.safetyAlertsChannelId = null);
        }
        if (data.channels) {
          this.channels.cache.clear();
          for (const rawChannel of data.channels) {
            this.client.channels._add(rawChannel, this);
          }
        }
        if (data.threads) {
          for (const rawThread of data.threads) {
            this.client.channels._add(rawThread, this);
          }
        }
        if (data.roles) {
          this.roles.cache.clear();
          for (const role of data.roles)
            this.roles._add(role);
        }
        if (data.members) {
          this.members.cache.clear();
          for (const guildUser of data.members)
            this.members._add(guildUser);
        }
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        }
        if (data.presences) {
          for (const presence of data.presences) {
            this.presences._add(Object.assign(presence, { guild: this }));
          }
        }
        if (data.stage_instances) {
          this.stageInstances.cache.clear();
          for (const stageInstance of data.stage_instances) {
            this.stageInstances._add(stageInstance);
          }
        }
        if (data.guild_scheduled_events) {
          this.scheduledEvents.cache.clear();
          for (const scheduledEvent of data.guild_scheduled_events) {
            this.scheduledEvents._add(scheduledEvent);
          }
        }
        if (data.voice_states) {
          this.voiceStates.cache.clear();
          for (const voiceState of data.voice_states) {
            this.voiceStates._add(voiceState);
          }
        }
        if (!this.emojis) {
          this.emojis = new GuildEmojiManager(this);
          if (data.emojis)
            for (const emoji of data.emojis)
              this.emojis._add(emoji);
        } else if (data.emojis) {
          this.client.actions.GuildEmojisUpdate.handle({
            guild_id: this.id,
            emojis: data.emojis
          });
        }
        if (!this.stickers) {
          this.stickers = new GuildStickerManager(this);
          if (data.stickers)
            for (const sticker of data.stickers)
              this.stickers._add(sticker);
        } else if (data.stickers) {
          this.client.actions.GuildStickersUpdate.handle({
            guild_id: this.id,
            stickers: data.stickers
          });
        }
      }
      /**
       * The time the client user joined the guild
       * @type {Date}
       * @readonly
       */
      get joinedAt() {
        return new Date(this.joinedTimestamp);
      }
      /**
       * The URL to this guild's discovery splash image.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      discoverySplashURL(options = {}) {
        return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
      }
      /**
       * Fetches the owner of the guild.
       * If the member object isn't needed, use {@link Guild#ownerId} instead.
       * @param {BaseFetchOptions} [options] The options for fetching the member
       * @returns {Promise<GuildMember>}
       */
      async fetchOwner(options) {
        if (!this.ownerId) {
          throw new DiscordjsError2(ErrorCodes2.FetchOwnerId);
        }
        const member = await this.members.fetch({ ...options, user: this.ownerId });
        return member;
      }
      /**
       * AFK voice channel for this guild
       * @type {?VoiceChannel}
       * @readonly
       */
      get afkChannel() {
        return this.client.channels.resolve(this.afkChannelId);
      }
      /**
       * System channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get systemChannel() {
        return this.client.channels.resolve(this.systemChannelId);
      }
      /**
       * Widget channel for this guild
       * @type {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|MediaChannel)}
       * @readonly
       */
      get widgetChannel() {
        return this.client.channels.resolve(this.widgetChannelId);
      }
      /**
       * Rules channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get rulesChannel() {
        return this.client.channels.resolve(this.rulesChannelId);
      }
      /**
       * Public updates channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get publicUpdatesChannel() {
        return this.client.channels.resolve(this.publicUpdatesChannelId);
      }
      /**
       * Safety alerts channel for this guild
       * @type {?TextChannel}
       * @readonly
       */
      get safetyAlertsChannel() {
        return this.client.channels.resolve(this.safetyAlertsChannelId);
      }
      /**
       * The maximum bitrate available for this guild
       * @type {number}
       * @readonly
       */
      get maximumBitrate() {
        if (this.features.includes(GuildFeature.VIPRegions)) {
          return 384e3;
        }
        switch (this.premiumTier) {
          case GuildPremiumTier.Tier1:
            return 128e3;
          case GuildPremiumTier.Tier2:
            return 256e3;
          case GuildPremiumTier.Tier3:
            return 384e3;
          default:
            return 96e3;
        }
      }
      /**
       * Fetches a collection of integrations to this guild.
       * Resolves with a collection mapping integrations by their ids.
       * @returns {Promise<Collection<Snowflake|string, Integration>>}
       * @example
       * // Fetch integrations
       * guild.fetchIntegrations()
       *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))
       *   .catch(console.error);
       */
      async fetchIntegrations() {
        const data = await this.client.rest.get(Routes2.guildIntegrations(this.id));
        return data.reduce(
          (collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)),
          new Collection2()
        );
      }
      /**
       * Fetches a collection of templates from this guild.
       * Resolves with a collection mapping templates by their codes.
       * @returns {Promise<Collection<string, GuildTemplate>>}
       */
      async fetchTemplates() {
        const templates = await this.client.rest.get(Routes2.guildTemplates(this.id));
        return templates.reduce((col, data) => col.set(data.code, new GuildTemplate2(this.client, data)), new Collection2());
      }
      /**
       * Fetches the welcome screen for this guild.
       * @returns {Promise<WelcomeScreen>}
       */
      async fetchWelcomeScreen() {
        const data = await this.client.rest.get(Routes2.guildWelcomeScreen(this.id));
        return new WelcomeScreen(this, data);
      }
      /**
       * Creates a template for the guild.
       * @param {string} name The name for the template
       * @param {string} [description] The description for the template
       * @returns {Promise<GuildTemplate>}
       */
      async createTemplate(name, description) {
        const data = await this.client.rest.post(Routes2.guildTemplates(this.id), { body: { name, description } });
        return new GuildTemplate2(this.client, data);
      }
      /**
       * Obtains a guild preview for this guild from Discord.
       * @returns {Promise<GuildPreview>}
       */
      async fetchPreview() {
        const data = await this.client.rest.get(Routes2.guildPreview(this.id));
        return new GuildPreview2(this.client, data);
      }
      /**
       * An object containing information about a guild's vanity invite.
       * @typedef {Object} Vanity
       * @property {?string} code Vanity invite code
       * @property {number} uses How many times this invite has been used
       */
      /**
       * Fetches the vanity URL invite object to this guild.
       * Resolves with an object containing the vanity URL invite code and the use count
       * @returns {Promise<Vanity>}
       * @example
       * // Fetch invite data
       * guild.fetchVanityData()
       *   .then(res => {
       *     console.log(`Vanity URL: https://discord.gg/${res.code} with ${res.uses} uses`);
       *   })
       *   .catch(console.error);
       */
      async fetchVanityData() {
        const data = await this.client.rest.get(Routes2.guildVanityUrl(this.id));
        this.vanityURLCode = data.code;
        this.vanityURLUses = data.uses;
        return data;
      }
      /**
       * Fetches all webhooks for the guild.
       * @returns {Promise<Collection<Snowflake, Webhook>>}
       * @example
       * // Fetch webhooks
       * guild.fetchWebhooks()
       *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))
       *   .catch(console.error);
       */
      async fetchWebhooks() {
        const apiHooks = await this.client.rest.get(Routes2.guildWebhooks(this.id));
        const hooks = new Collection2();
        for (const hook of apiHooks)
          hooks.set(hook.id, new Webhook2(this.client, hook));
        return hooks;
      }
      /**
       * Fetches the guild widget data, requires the widget to be enabled.
       * @returns {Promise<Widget>}
       * @example
       * // Fetches the guild widget data
       * guild.fetchWidget()
       *   .then(widget => console.log(`The widget shows ${widget.channels.size} channels`))
       *   .catch(console.error);
       */
      fetchWidget() {
        return this.client.fetchGuildWidget(this.id);
      }
      /**
       * Data for the Guild Widget Settings object
       * @typedef {Object} GuildWidgetSettings
       * @property {boolean} enabled Whether the widget is enabled
       * @property {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|MediaChannel)} channel
       * The widget invite channel
       */
      /**
       * The Guild Widget Settings object
       * @typedef {Object} GuildWidgetSettingsData
       * @property {boolean} enabled Whether the widget is enabled
       * @property {?(TextChannel|NewsChannel|VoiceChannel|StageChannel|ForumChannel|MediaChannel|Snowflake)} channel
       * The widget invite channel
       */
      /**
       * Fetches the guild widget settings.
       * @returns {Promise<GuildWidgetSettings>}
       * @example
       * // Fetches the guild widget settings
       * guild.fetchWidgetSettings()
       *   .then(widget => console.log(`The widget is ${widget.enabled ? 'enabled' : 'disabled'}`))
       *   .catch(console.error);
       */
      async fetchWidgetSettings() {
        const data = await this.client.rest.get(Routes2.guildWidgetSettings(this.id));
        this.widgetEnabled = data.enabled;
        this.widgetChannelId = data.channel_id;
        return {
          enabled: data.enabled,
          channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
        };
      }
      /**
       * Returns a URL for the PNG widget of the guild.
       * @param {GuildWidgetStyle} [style] The style for the widget image
       * @returns {string}
       */
      widgetImageURL(style) {
        return this.client.guilds.widgetImageURL(this.id, style);
      }
      /**
       * Options used to fetch audit logs.
       * @typedef {Object} GuildAuditLogsFetchOptions
       * @property {Snowflake|GuildAuditLogsEntry} [before] Consider only entries before this entry
       * @property {Snowflake|GuildAuditLogsEntry} [after] Consider only entries after this entry
       * @property {number} [limit] The number of entries to return
       * @property {UserResolvable} [user] Only return entries for actions made by this user
       * @property {?AuditLogEvent} [type] Only return entries for this action type
       */
      /**
       * Fetches audit logs for this guild.
       * @param {GuildAuditLogsFetchOptions} [options={}] Options for fetching audit logs
       * @returns {Promise<GuildAuditLogs>}
       * @example
       * // Output audit log entries
       * guild.fetchAuditLogs()
       *   .then(audit => console.log(audit.entries.first()))
       *   .catch(console.error);
       */
      async fetchAuditLogs({ before, after, limit, user, type } = {}) {
        const query = makeURLSearchParams2({
          before: (before == null ? void 0 : before.id) ?? before,
          after: (after == null ? void 0 : after.id) ?? after,
          limit,
          action_type: type
        });
        if (user) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
          query.set("user_id", userId);
        }
        const data = await this.client.rest.get(Routes2.guildAuditLog(this.id), { query });
        return new GuildAuditLogs(this, data);
      }
      /**
       * Fetches the guild onboarding data for this guild.
       * @returns {Promise<GuildOnboarding>}
       */
      async fetchOnboarding() {
        const data = await this.client.rest.get(Routes2.guildOnboarding(this.id));
        return new GuildOnboarding(this.client, data);
      }
      /**
       * The data for editing a guild.
       * @typedef {Object} GuildEditOptions
       * @property {string} [name] The name of the guild
       * @property {?GuildVerificationLevel} [verificationLevel] The verification level of the guild
       * @property {?GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message
       * notification level of the guild
       * @property {?GuildExplicitContentFilter} [explicitContentFilter] The level of the explicit content filter
       * @property {?VoiceChannelResolvable} [afkChannel] The AFK channel of the guild
       * @property {number} [afkTimeout] The AFK timeout of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [icon] The icon of the guild
       * @property {GuildMemberResolvable} [owner] The owner of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [splash] The invite splash image of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [discoverySplash] The discovery splash image of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [banner] The banner of the guild
       * @property {?TextChannelResolvable} [systemChannel] The system channel of the guild
       * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild
       * @property {?TextChannelResolvable} [rulesChannel] The rules channel of the guild
       * @property {?TextChannelResolvable} [publicUpdatesChannel] The community updates channel of the guild
       * @property {?TextChannelResolvable} [safetyAlertsChannel] The safety alerts channel of the guild
       * @property {?string} [preferredLocale] The preferred locale of the guild
       * @property {GuildFeature[]} [features] The features of the guild
       * @property {?string} [description] The discovery description of the guild
       * @property {boolean} [premiumProgressBarEnabled] Whether the guild's premium progress bar is enabled
       * @property {string} [reason] Reason for editing this guild
       */
      /**
       * Data that can be resolved to a Text Channel object. This can be:
       * * A TextChannel
       * * A Snowflake
       * @typedef {TextChannel|Snowflake} TextChannelResolvable
       */
      /**
       * Data that can be resolved to a Voice Channel object. This can be:
       * * A VoiceChannel
       * * A Snowflake
       * @typedef {VoiceChannel|Snowflake} VoiceChannelResolvable
       */
      /**
       * Updates the guild with new information - e.g. a new name.
       * @param {GuildEditOptions} options The options to provide
       * @returns {Promise<Guild>}
       * @example
       * // Set the guild name
       * guild.edit({
       *   name: 'Discord Guild',
       * })
       *   .then(updated => console.log(`New guild name ${updated}`))
       *   .catch(console.error);
       */
      async edit({
        verificationLevel,
        defaultMessageNotifications,
        explicitContentFilter,
        afkChannel,
        afkTimeout,
        icon,
        owner,
        splash,
        discoverySplash,
        banner,
        systemChannel,
        systemChannelFlags,
        rulesChannel,
        publicUpdatesChannel,
        preferredLocale,
        premiumProgressBarEnabled,
        safetyAlertsChannel,
        ...options
      }) {
        const data = await this.client.rest.patch(Routes2.guild(this.id), {
          body: {
            ...options,
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
            afk_timeout: afkTimeout,
            icon: icon && await DataResolver2.resolveImage(icon),
            owner_id: owner && this.client.users.resolveId(owner),
            splash: splash && await DataResolver2.resolveImage(splash),
            discovery_splash: discoverySplash && await DataResolver2.resolveImage(discoverySplash),
            banner: banner && await DataResolver2.resolveImage(banner),
            system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
            system_channel_flags: systemChannelFlags === void 0 ? void 0 : SystemChannelFlagsBitField.resolve(systemChannelFlags),
            rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
            public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
            preferred_locale: preferredLocale,
            premium_progress_bar_enabled: premiumProgressBarEnabled,
            safety_alerts_channel_id: safetyAlertsChannel && this.client.channels.resolveId(safetyAlertsChannel)
          },
          reason: options.reason
        });
        return this.client.actions.GuildUpdate.handle(data).updated;
      }
      /**
       * Options used to edit the guild onboarding.
       * @typedef {Object} GuildOnboardingEditOptions
       * @property {GuildOnboardingPromptData[]|Collection<Snowflake, GuildOnboardingPrompt>} [prompts]
       * The prompts shown during onboarding and in customize community
       * @property {ChannelResolvable[]|Collection<Snowflake, GuildChannel>} [defaultChannels]
       * The channels that new members get opted into automatically
       * @property {boolean} [enabled] Whether the onboarding is enabled
       * @property {GuildOnboardingMode} [mode] The mode to edit the guild onboarding with
       * @property {string} [reason] The reason for editing the guild onboarding
       */
      /**
       * Data for editing a guild onboarding prompt.
       * @typedef {Object} GuildOnboardingPromptData
       * @property {Snowflake} [id] The id of the prompt
       * @property {string} title The title for the prompt
       * @property {boolean} [singleSelect] Whether users are limited to selecting one option for the prompt
       * @property {boolean} [required] Whether the prompt is required before a user completes the onboarding flow
       * @property {boolean} [inOnboarding] Whether the prompt is present in the onboarding flow
       * @property {GuildOnboardingPromptType} [type] The type of the prompt
       * @property {GuildOnboardingPromptOptionData[]|Collection<Snowflake, GuildOnboardingPrompt>} options
       * The options available within the prompt
       */
      /**
       * Data for editing a guild onboarding prompt option.
       * @typedef {Object} GuildOnboardingPromptOptionData
       * @property {?Snowflake} [id] The id of the option
       * @property {ChannelResolvable[]|Collection<Snowflake, GuildChannel>} [channels]
       * The channels a member is added to when the option is selected
       * @property {RoleResolvable[]|Collection<Snowflake, Role>} [roles]
       * The roles assigned to a member when the option is selected
       * @property {string} title The title of the option
       * @property {?string} [description] The description of the option
       * @property {?(EmojiIdentifierResolvable|Emoji)} [emoji] The emoji of the option
       */
      /**
       * Edits the guild onboarding data for this guild.
       * @param {GuildOnboardingEditOptions} options The options to provide
       * @returns {Promise<GuildOnboarding>}
       */
      async editOnboarding(options) {
        var _a, _b;
        const newData = await this.client.rest.put(Routes2.guildOnboarding(this.id), {
          body: {
            prompts: (_a = options.prompts) == null ? void 0 : _a.map((prompt) => ({
              // Currently, the prompt ids are required even for new ones (which won't be used)
              id: prompt.id ?? DiscordSnowflake.generate().toString(),
              title: prompt.title,
              single_select: prompt.singleSelect,
              required: prompt.required,
              in_onboarding: prompt.inOnboarding,
              type: prompt.type,
              options: prompt.options.map((option) => {
                var _a2, _b2;
                const emoji = resolvePartialEmoji(option.emoji);
                return {
                  id: option.id,
                  channel_ids: (_a2 = option.channels) == null ? void 0 : _a2.map((channel) => this.channels.resolveId(channel)),
                  role_ids: (_b2 = option.roles) == null ? void 0 : _b2.map((role) => this.roles.resolveId(role)),
                  title: option.title,
                  description: option.description,
                  emoji_animated: emoji == null ? void 0 : emoji.animated,
                  emoji_id: emoji == null ? void 0 : emoji.id,
                  emoji_name: emoji == null ? void 0 : emoji.name
                };
              })
            })),
            default_channel_ids: (_b = options.defaultChannels) == null ? void 0 : _b.map((channel) => this.channels.resolveId(channel)),
            enabled: options.enabled,
            mode: options.mode
          },
          reason: options.reason
        });
        return new GuildOnboarding(this.client, newData);
      }
      /**
       * Welcome channel data
       * @typedef {Object} WelcomeChannelData
       * @property {string} description The description to show for this welcome channel
       * @property {TextChannel|NewsChannel|ForumChannel|MediaChannel|Snowflake} channel
       * The channel to link for this welcome channel
       * @property {EmojiIdentifierResolvable} [emoji] The emoji to display for this welcome channel
       */
      /**
       * Welcome screen edit data
       * @typedef {Object} WelcomeScreenEditOptions
       * @property {boolean} [enabled] Whether the welcome screen is enabled
       * @property {string} [description] The description for the welcome screen
       * @property {WelcomeChannelData[]} [welcomeChannels] The welcome channel data for the welcome screen
       */
      /**
       * Data that can be resolved to a GuildTextChannel object. This can be:
       * * A TextChannel
       * * A NewsChannel
       * * A Snowflake
       * @typedef {TextChannel|NewsChannel|Snowflake} GuildTextChannelResolvable
       */
      /**
       * Data that can be resolved to a GuildVoiceChannel object. This can be:
       * * A VoiceChannel
       * * A StageChannel
       * * A Snowflake
       * @typedef {VoiceChannel|StageChannel|Snowflake} GuildVoiceChannelResolvable
       */
      /**
       * Updates the guild's welcome screen
       * @param {WelcomeScreenEditOptions} options The options to provide
       * @returns {Promise<WelcomeScreen>}
       * @example
       * guild.editWelcomeScreen({
       *   description: 'Hello World',
       *   enabled: true,
       *   welcomeChannels: [
       *     {
       *       description: 'foobar',
       *       channel: '222197033908436994',
       *     }
       *   ],
       * })
       */
      async editWelcomeScreen(options) {
        const { enabled, description, welcomeChannels } = options;
        const welcome_channels = welcomeChannels == null ? void 0 : welcomeChannels.map((welcomeChannelData) => {
          const emoji = this.emojis.resolve(welcomeChannelData.emoji);
          return {
            emoji_id: emoji == null ? void 0 : emoji.id,
            emoji_name: (emoji == null ? void 0 : emoji.name) ?? welcomeChannelData.emoji,
            channel_id: this.channels.resolveId(welcomeChannelData.channel),
            description: welcomeChannelData.description
          };
        });
        const patchData = await this.client.rest.patch(Routes2.guildWelcomeScreen(this.id), {
          body: {
            welcome_channels,
            description,
            enabled
          }
        });
        return new WelcomeScreen(this, patchData);
      }
      /**
       * Edits the level of the explicit content filter.
       * @param {?GuildExplicitContentFilter} explicitContentFilter The new level of the explicit content filter
       * @param {string} [reason] Reason for changing the level of the guild's explicit content filter
       * @returns {Promise<Guild>}
       */
      setExplicitContentFilter(explicitContentFilter, reason) {
        return this.edit({ explicitContentFilter, reason });
      }
      /**
       * Edits the setting of the default message notifications of the guild.
       * @param {?GuildDefaultMessageNotifications} defaultMessageNotifications
       * The new default message notification level of the guild
       * @param {string} [reason] Reason for changing the setting of the default message notifications
       * @returns {Promise<Guild>}
       */
      setDefaultMessageNotifications(defaultMessageNotifications, reason) {
        return this.edit({ defaultMessageNotifications, reason });
      }
      /**
       * Edits the flags of the default message notifications of the guild.
       * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications
       * @param {string} [reason] Reason for changing the flags of the default message notifications
       * @returns {Promise<Guild>}
       */
      setSystemChannelFlags(systemChannelFlags, reason) {
        return this.edit({ systemChannelFlags, reason });
      }
      /**
       * Edits the name of the guild.
       * @param {string} name The new name of the guild
       * @param {string} [reason] Reason for changing the guild's name
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild name
       * guild.setName('Discord Guild')
       *  .then(updated => console.log(`Updated guild name to ${updated.name}`))
       *  .catch(console.error);
       */
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      /**
       * Edits the verification level of the guild.
       * @param {?GuildVerificationLevel} verificationLevel The new verification level of the guild
       * @param {string} [reason] Reason for changing the guild's verification level
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild verification level
       * guild.setVerificationLevel(1)
       *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))
       *  .catch(console.error);
       */
      setVerificationLevel(verificationLevel, reason) {
        return this.edit({ verificationLevel, reason });
      }
      /**
       * Edits the AFK channel of the guild.
       * @param {?VoiceChannelResolvable} afkChannel The new AFK channel
       * @param {string} [reason] Reason for changing the guild's AFK channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild AFK channel
       * guild.setAFKChannel(channel)
       *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))
       *  .catch(console.error);
       */
      setAFKChannel(afkChannel, reason) {
        return this.edit({ afkChannel, reason });
      }
      /**
       * Edits the system channel of the guild.
       * @param {?TextChannelResolvable} systemChannel The new system channel
       * @param {string} [reason] Reason for changing the guild's system channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild system channel
       * guild.setSystemChannel(channel)
       *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))
       *  .catch(console.error);
       */
      setSystemChannel(systemChannel, reason) {
        return this.edit({ systemChannel, reason });
      }
      /**
       * Edits the AFK timeout of the guild.
       * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK
       * @param {string} [reason] Reason for changing the guild's AFK timeout
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild AFK channel
       * guild.setAFKTimeout(60)
       *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))
       *  .catch(console.error);
       */
      setAFKTimeout(afkTimeout, reason) {
        return this.edit({ afkTimeout, reason });
      }
      /**
       * Sets a new guild icon.
       * @param {?(Base64Resolvable|BufferResolvable)} icon The new icon of the guild
       * @param {string} [reason] Reason for changing the guild's icon
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild icon
       * guild.setIcon('./icon.png')
       *  .then(updated => console.log('Updated the guild icon'))
       *  .catch(console.error);
       */
      setIcon(icon, reason) {
        return this.edit({ icon, reason });
      }
      /**
       * Sets a new owner of the guild.
       * @param {GuildMemberResolvable} owner The new owner of the guild
       * @param {string} [reason] Reason for setting the new owner
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild owner
       * guild.setOwner(guild.members.cache.first())
       *  .then(guild => guild.fetchOwner())
       *  .then(owner => console.log(`Updated the guild owner to ${owner.displayName}`))
       *  .catch(console.error);
       */
      setOwner(owner, reason) {
        return this.edit({ owner, reason });
      }
      /**
       * Sets a new guild invite splash image.
       * @param {?(Base64Resolvable|BufferResolvable)} splash The new invite splash image of the guild
       * @param {string} [reason] Reason for changing the guild's invite splash image
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild splash
       * guild.setSplash('./splash.png')
       *  .then(updated => console.log('Updated the guild splash'))
       *  .catch(console.error);
       */
      setSplash(splash, reason) {
        return this.edit({ splash, reason });
      }
      /**
       * Sets a new guild discovery splash image.
       * @param {?(Base64Resolvable|BufferResolvable)} discoverySplash The new discovery splash image of the guild
       * @param {string} [reason] Reason for changing the guild's discovery splash image
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild discovery splash
       * guild.setDiscoverySplash('./discoverysplash.png')
       *   .then(updated => console.log('Updated the guild discovery splash'))
       *   .catch(console.error);
       */
      setDiscoverySplash(discoverySplash, reason) {
        return this.edit({ discoverySplash, reason });
      }
      /**
       * Sets a new guild banner.
       * @param {?(Base64Resolvable|BufferResolvable)} banner The new banner of the guild
       * @param {string} [reason] Reason for changing the guild's banner
       * @returns {Promise<Guild>}
       * @example
       * guild.setBanner('./banner.png')
       *  .then(updated => console.log('Updated the guild banner'))
       *  .catch(console.error);
       */
      setBanner(banner, reason) {
        return this.edit({ banner, reason });
      }
      /**
       * Edits the rules channel of the guild.
       * @param {?TextChannelResolvable} rulesChannel The new rules channel
       * @param {string} [reason] Reason for changing the guild's rules channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild rules channel
       * guild.setRulesChannel(channel)
       *  .then(updated => console.log(`Updated guild rules channel to ${guild.rulesChannel.name}`))
       *  .catch(console.error);
       */
      setRulesChannel(rulesChannel, reason) {
        return this.edit({ rulesChannel, reason });
      }
      /**
       * Edits the community updates channel of the guild.
       * @param {?TextChannelResolvable} publicUpdatesChannel The new community updates channel
       * @param {string} [reason] Reason for changing the guild's community updates channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild community updates channel
       * guild.setPublicUpdatesChannel(channel)
       *  .then(updated => console.log(`Updated guild community updates channel to ${guild.publicUpdatesChannel.name}`))
       *  .catch(console.error);
       */
      setPublicUpdatesChannel(publicUpdatesChannel, reason) {
        return this.edit({ publicUpdatesChannel, reason });
      }
      /**
       * Edits the preferred locale of the guild.
       * @param {?Locale} preferredLocale The new preferred locale of the guild
       * @param {string} [reason] Reason for changing the guild's preferred locale
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild preferred locale
       * guild.setPreferredLocale('en-US')
       *  .then(updated => console.log(`Updated guild preferred locale to ${guild.preferredLocale}`))
       *  .catch(console.error);
       */
      setPreferredLocale(preferredLocale, reason) {
        return this.edit({ preferredLocale, reason });
      }
      /**
       * Edits the enabled state of the guild's premium progress bar
       * @param {boolean} [enabled=true] The new enabled state of the guild's premium progress bar
       * @param {string} [reason] Reason for changing the state of the guild's premium progress bar
       * @returns {Promise<Guild>}
       */
      setPremiumProgressBarEnabled(enabled = true, reason) {
        return this.edit({ premiumProgressBarEnabled: enabled, reason });
      }
      /**
       * Edits the safety alerts channel of the guild.
       * @param {?TextChannelResolvable} safetyAlertsChannel The new safety alerts channel
       * @param {string} [reason] Reason for changing the guild's safety alerts channel
       * @returns {Promise<Guild>}
       * @example
       * // Edit the guild safety alerts channel
       * guild.setSafetyAlertsChannel(channel)
       *  .then(updated => console.log(`Updated guild safety alerts channel to ${updated.safetyAlertsChannel.name}`))
       *  .catch(console.error);
       */
      setSafetyAlertsChannel(safetyAlertsChannel, reason) {
        return this.edit({ safetyAlertsChannel, reason });
      }
      /**
       * Edits the guild's widget settings.
       * @param {GuildWidgetSettingsData} settings The widget settings for the guild
       * @param {string} [reason] Reason for changing the guild's widget settings
       * @returns {Promise<Guild>}
       */
      async setWidgetSettings(settings2, reason) {
        await this.client.rest.patch(Routes2.guildWidgetSettings(this.id), {
          body: {
            enabled: settings2.enabled,
            channel_id: this.channels.resolveId(settings2.channel)
          },
          reason
        });
        return this;
      }
      /**
       * Sets the guild's MFA level
       * <info>An elevated MFA level requires guild moderators to have 2FA enabled.</info>
       * @param {GuildMFALevel} level The MFA level
       * @param {string} [reason] Reason for changing the guild's MFA level
       * @returns {Promise<Guild>}
       * @example
       * // Set the MFA level of the guild to Elevated
       * guild.setMFALevel(GuildMFALevel.Elevated)
       *   .then(guild => console.log("Set guild's MFA level to Elevated"))
       *   .catch(console.error);
       */
      async setMFALevel(level, reason) {
        await this.client.rest.post(Routes2.guildMFA(this.id), {
          body: {
            level
          },
          reason
        });
        return this;
      }
      /**
       * Leaves the guild.
       * @returns {Promise<Guild>}
       * @example
       * // Leave a guild
       * guild.leave()
       *   .then(guild => console.log(`Left the guild: ${guild.name}`))
       *   .catch(console.error);
       */
      async leave() {
        if (this.ownerId === this.client.user.id)
          throw new DiscordjsError2(ErrorCodes2.GuildOwned);
        await this.client.rest.delete(Routes2.userGuild(this.id));
        return this;
      }
      /**
       * Deletes the guild.
       * @returns {Promise<Guild>}
       * @example
       * // Delete a guild
       * guild.delete()
       *   .then(guild => console.log(`Deleted the guild ${guild}`))
       *   .catch(console.error);
       */
      async delete() {
        await this.client.rest.delete(Routes2.guild(this.id));
        return this;
      }
      /**
       * Sets whether this guild's invites are disabled.
       * @param {boolean} [disabled=true] Whether the invites are disabled
       * @returns {Promise<Guild>}
       */
      async disableInvites(disabled = true) {
        const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
        if (disabled)
          features.push(GuildFeature.InvitesDisabled);
        return this.edit({ features });
      }
      /**
       * Whether this guild equals another guild. It compares all properties, so for most operations
       * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often
       * what most users need.
       * @param {Guild} guild The guild to compare with
       * @returns {boolean}
       */
      equals(guild) {
        return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
      }
      toJSON() {
        const json = super.toJSON({
          available: false,
          createdTimestamp: true,
          nameAcronym: true,
          presences: false,
          voiceStates: false
        });
        json.iconURL = this.iconURL();
        json.splashURL = this.splashURL();
        json.discoverySplashURL = this.discoverySplashURL();
        json.bannerURL = this.bannerURL();
        return json;
      }
      /**
       * The voice state adapter for this guild that can be used with @discordjs/voice to play audio in voice
       * and stage channels.
       * @type {Function}
       * @readonly
       */
      get voiceAdapterCreator() {
        return (methods) => {
          this.client.voice.adapters.set(this.id, methods);
          return {
            sendPayload: (data) => {
              if (this.shard.status !== Status2.Ready)
                return false;
              this.shard.send(data);
              return true;
            },
            destroy: () => {
              this.client.voice.adapters.delete(this.id);
            }
          };
        };
      }
      /**
       * Creates a collection of this guild's roles, sorted by their position and ids.
       * @returns {Collection<Snowflake, Role>}
       * @private
       */
      _sortedRoles() {
        return discordSort(this.roles.cache);
      }
      /**
       * Creates a collection of this guild's or a specific category's channels, sorted by their position and ids.
       * @param {GuildChannel} [channel] Category to get the channels of
       * @returns {Collection<Snowflake, GuildChannel>}
       * @private
       */
      _sortedChannels(channel) {
        const channelIsCategory = channel.type === ChannelType.GuildCategory;
        const types = getSortableGroupTypes(channel.type);
        return discordSort(
          this.channels.cache.filter(
            ({ parentId, type }) => types.includes(type) && (channelIsCategory || parentId === channel.parentId)
          )
        );
      }
    };
    exports2.Guild = Guild;
  }
});

// node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS({
  "node_modules/discord.js/src/structures/OAuth2Guild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var PermissionsBitField2 = require_PermissionsBitField();
    var OAuth2Guild = class extends BaseGuild {
      constructor(client, data) {
        super(client, data);
        this.owner = data.owner;
        this.permissions = new PermissionsBitField2(BigInt(data.permissions)).freeze();
      }
    };
    module2.exports = OAuth2Guild;
  }
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS({
  "node_modules/discord.js/src/managers/GuildManager.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require_node_timers();
    var { Collection: Collection2 } = require_dist6();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_web();
    var { Routes: Routes2, RouteBases } = require_v106();
    var CachedManager = require_CachedManager();
    var ShardClientUtil2 = require_ShardClientUtil();
    var { Guild } = require_Guild();
    var GuildChannel = require_GuildChannel();
    var GuildEmoji = require_GuildEmoji();
    var { GuildMember } = require_GuildMember();
    var Invite2 = require_Invite();
    var OAuth2Guild = require_OAuth2Guild();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var Events2 = require_Events();
    var PermissionsBitField2 = require_PermissionsBitField();
    var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    var { resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var GuildManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Guild, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process2.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      /**
       * The cache of this Manager
       * @type {Collection<Snowflake, Guild>}
       * @name GuildManager#cache
       */
      /**
       * Data that resolves to give a Guild object. This can be:
       * * A Guild object
       * * A GuildChannel object
       * * A GuildEmoji object
       * * A Role object
       * * A Snowflake
       * * An Invite object
       * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable
       */
      /**
       * Partial data for a Role.
       * @typedef {Object} PartialRoleData
       * @property {Snowflake|number} [id] The role's id, used to set channel overrides.
       * This is a placeholder and will be replaced by the API after consumption
       * @property {string} [name] The name of the role
       * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number
       * @property {boolean} [hoist] Whether the role should be hoisted
       * @property {number} [position] The position of the role
       * @property {PermissionResolvable} [permissions] The permissions of the role
       * @property {boolean} [mentionable] Whether the role should be mentionable
       */
      /**
       * Partial overwrite data.
       * @typedef {Object} PartialOverwriteData
       * @property {Snowflake|number} id The id of the {@link Role} or {@link User} this overwrite belongs to
       * @property {OverwriteType} [type] The type of this overwrite
       * @property {PermissionResolvable} [allow] The permissions to allow
       * @property {PermissionResolvable} [deny] The permissions to deny
       */
      /**
       * Partial data for a Channel.
       * @typedef {Object} PartialChannelData
       * @property {Snowflake|number} [id] The channel's id, used to set its parent.
       * This is a placeholder and will be replaced by the API after consumption
       * @property {Snowflake|number} [parentId] The parent id for this channel
       * @property {ChannelType.GuildText|ChannelType.GuildVoice|ChannelType.GuildCategory} [type] The type of the channel
       * @property {string} name The name of the channel
       * @property {?string} [topic] The topic of the text channel
       * @property {boolean} [nsfw] Whether the channel is NSFW
       * @property {number} [bitrate] The bitrate of the voice channel
       * @property {number} [userLimit] The user limit of the channel
       * @property {?string} [rtcRegion] The RTC region of the channel
       * @property {VideoQualityMode} [videoQualityMode] The camera video quality mode of the channel
       * @property {PartialOverwriteData[]} [permissionOverwrites]
       * Overwrites of the channel
       * @property {number} [rateLimitPerUser] The rate limit per user (slowmode) of the channel in seconds
       */
      /**
       * Resolves a GuildResolvable to a Guild object.
       * @method resolve
       * @memberof GuildManager
       * @instance
       * @param {GuildResolvable} guild The guild resolvable to identify
       * @returns {?Guild}
       */
      resolve(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolve(guild.guild);
        }
        return super.resolve(guild);
      }
      /**
       * Resolves a {@link GuildResolvable} to a {@link Guild} id string.
       * @method resolveId
       * @memberof GuildManager
       * @instance
       * @param {GuildResolvable} guild The guild resolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolveId(guild.guild.id);
        }
        return super.resolveId(guild);
      }
      /**
       * Options used to create a guild.
       * @typedef {Object} GuildCreateOptions
       * @property {string} name The name of the guild
       * @property {?(BufferResolvable|Base64Resolvable)} [icon=null] The icon for the guild
       * @property {GuildVerificationLevel} [verificationLevel] The verification level for the guild
       * @property {GuildDefaultMessageNotifications} [defaultMessageNotifications] The default message notifications
       * for the guild
       * @property {GuildExplicitContentFilter} [explicitContentFilter] The explicit content filter level for the guild
       * @property {PartialRoleData[]} [roles=[]] The roles for this guild,
       * @property {PartialChannelData[]} [channels=[]] The channels for this guild
       * @property {Snowflake|number} [afkChannelId] The AFK channel's id
       * @property {number} [afkTimeout] The AFK timeout in seconds
       * the first element of this array is used to change properties of the guild's everyone role.
       * @property {Snowflake|number} [systemChannelId] The system channel's id
       * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The flags of the system channel
       */
      /* eslint-enable max-len */
      /**
       * Creates a guild.
       * <warn>This is only available to bots in fewer than 10 guilds.</warn>
       * @param {GuildCreateOptions} options Options for creating the guild
       * @returns {Promise<Guild>} The guild that was created
       */
      async create({
        name,
        icon = null,
        verificationLevel,
        defaultMessageNotifications,
        explicitContentFilter,
        roles = [],
        channels = [],
        afkChannelId,
        afkTimeout,
        systemChannelId,
        systemChannelFlags
      }) {
        const data = await this.client.rest.post(Routes2.guilds(), {
          body: {
            name,
            icon: icon && await DataResolver2.resolveImage(icon),
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            roles: roles.map(({ color, permissions, ...options }) => ({
              ...options,
              color: color && resolveColor(color),
              permissions: permissions === void 0 ? void 0 : PermissionsBitField2.resolve(permissions).toString()
            })),
            channels: channels.map(
              ({
                parentId,
                userLimit,
                rtcRegion,
                videoQualityMode,
                permissionOverwrites,
                rateLimitPerUser,
                ...options
              }) => ({
                ...options,
                parent_id: parentId,
                user_limit: userLimit,
                rtc_region: rtcRegion,
                video_quality_mode: videoQualityMode,
                permission_overwrites: permissionOverwrites == null ? void 0 : permissionOverwrites.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
                  ...permissionOverwriteOptions,
                  allow: allow === void 0 ? void 0 : PermissionsBitField2.resolve(allow).toString(),
                  deny: deny === void 0 ? void 0 : PermissionsBitField2.resolve(deny).toString()
                })),
                rate_limit_per_user: rateLimitPerUser
              })
            ),
            afk_channel_id: afkChannelId,
            afk_timeout: afkTimeout,
            system_channel_id: systemChannelId,
            system_channel_flags: systemChannelFlags === void 0 ? void 0 : SystemChannelFlagsBitField.resolve(systemChannelFlags)
          }
        });
        return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout2(timeout);
              this.client.decrementMaxListeners();
              resolve(guild);
            }
          };
          this.client.incrementMaxListeners();
          this.client.once(Events2.GuildCreate, handleGuild);
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events2.GuildCreate, handleGuild);
            this.client.decrementMaxListeners();
            resolve(this.client.guilds._add(data));
          }, 1e4).unref();
        });
      }
      /**
       * Options used to fetch a single guild.
       * @typedef {BaseFetchOptions} FetchGuildOptions
       * @property {GuildResolvable} guild The guild to fetch
       * @property {boolean} [withCounts=true] Whether the approximate member and presence counts should be returned
       */
      /**
       * Options used to fetch multiple guilds.
       * @typedef {Object} FetchGuildsOptions
       * @property {Snowflake} [before] Get guilds before this guild id
       * @property {Snowflake} [after] Get guilds after this guild id
       * @property {number} [limit] Maximum number of guilds to request (1-200)
       */
      /**
       * Obtains one or multiple guilds from Discord, or the guild cache if it's already available.
       * @param {GuildResolvable|FetchGuildOptions|FetchGuildsOptions} [options] The guild's id or options
       * @returns {Promise<Guild|Collection<Snowflake, OAuth2Guild>>}
       */
      async fetch(options = {}) {
        const id = this.resolveId(options) ?? this.resolveId(options.guild);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const data2 = await this.client.rest.get(Routes2.guild(id), {
            query: makeURLSearchParams2({ with_counts: options.withCounts ?? true })
          });
          data2.shardId = ShardClientUtil2.shardIdForGuildId(id, this.client.options.shardCount);
          return this._add(data2, options.cache);
        }
        const data = await this.client.rest.get(Routes2.userGuilds(), { query: makeURLSearchParams2(options) });
        return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection2());
      }
      /**
       * Returns a URL for the PNG widget of a guild.
       * @param {GuildResolvable} guild The guild of the widget image
       * @param {GuildWidgetStyle} [style] The style for the widget image
       * @returns {string}
       */
      widgetImageURL(guild, style) {
        const urlSearchParams = String(makeURLSearchParams2({ style }));
        return `${RouteBases.api}${Routes2.guildWidgetImage(this.resolveId(guild))}${urlSearchParams ? `?${urlSearchParams}` : ""}`;
      }
    };
    module2.exports = GuildManager2;
  }
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS({
  "node_modules/discord.js/src/managers/UserManager.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes2 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { GuildMember } = require_GuildMember();
    var { Message } = require_Message();
    var ThreadMember = require_ThreadMember();
    var User = require_User();
    var UserManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, User, iterable);
      }
      /**
       * The cache of this manager
       * @type {Collection<Snowflake, User>}
       * @name UserManager#cache
       */
      /**
       * Data that resolves to give a User object. This can be:
       * * A User object
       * * A Snowflake
       * * A Message object (resolves to the message author)
       * * A GuildMember object
       * * A ThreadMember object
       * @typedef {User|Snowflake|Message|GuildMember|ThreadMember} UserResolvable
       */
      /**
       * The DM between the client's user and a user
       * @param {Snowflake} userId The user id
       * @returns {?DMChannel}
       * @private
       */
      dmChannel(userId) {
        return this.client.channels.cache.find((channel) => channel.type === ChannelType.DM && channel.recipientId === userId) ?? null;
      }
      /**
       * Creates a {@link DMChannel} between the client and a user.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<DMChannel>}
       */
      async createDM(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const dmChannel = this.dmChannel(id);
          if (dmChannel && !dmChannel.partial)
            return dmChannel;
        }
        const data = await this.client.rest.post(Routes2.userChannels(), { body: { recipient_id: id } });
        return this.client.channels._add(data, null, { cache });
      }
      /**
       * Deletes a {@link DMChannel} (if one exists) between the client and a user. Resolves with the channel if successful.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {Promise<DMChannel>}
       */
      async deleteDM(user) {
        const id = this.resolveId(user);
        const dmChannel = this.dmChannel(id);
        if (!dmChannel)
          throw new DiscordjsError2(ErrorCodes2.UserNoDMChannel);
        await this.client.rest.delete(Routes2.channel(dmChannel.id));
        this.client.channels._remove(dmChannel.id);
        return dmChannel;
      }
      /**
       * Obtains a user from Discord, or the user cache if it's already available.
       * @param {UserResolvable} user The user to fetch
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<User>}
       */
      async fetch(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes2.user(id));
        return this._add(data, cache);
      }
      /**
       * Fetches a user's flags.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {BaseFetchOptions} [options] Additional options for this fetch
       * @returns {Promise<UserFlagsBitField>}
       */
      async fetchFlags(user, options) {
        return (await this.fetch(user, options)).flags;
      }
      /**
       * Sends a message to a user.
       * @param {UserResolvable} user The UserResolvable to identify
       * @param {string|MessagePayload|MessageCreateOptions} options The options to provide
       * @returns {Promise<Message>}
       */
      async send(user, options) {
        return (await this.createDM(user)).send(options);
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} object.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?User}
       */
      resolve(user) {
        if (user instanceof GuildMember || user instanceof ThreadMember)
          return user.user;
        if (user instanceof Message)
          return user.author;
        return super.resolve(user);
      }
      /**
       * Resolves a {@link UserResolvable} to a {@link User} id.
       * @param {UserResolvable} user The UserResolvable to identify
       * @returns {?Snowflake}
       */
      resolveId(user) {
        if (user instanceof ThreadMember)
          return user.id;
        if (user instanceof GuildMember)
          return user.user.id;
        if (user instanceof Message)
          return user.author.id;
        return super.resolveId(user);
      }
    };
    module2.exports = UserManager2;
  }
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS({
  "node_modules/discord.js/src/structures/ClientPresence.js"(exports2, module2) {
    "use strict";
    var { GatewayOpcodes, ActivityType } = require_v106();
    var { Presence } = require_Presence();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ClientPresence2 = class extends Presence {
      constructor(client, data = {}) {
        super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
      }
      /**
       * Sets the client's presence
       * @param {PresenceData} presence The data to set the presence to
       * @returns {ClientPresence}
       */
      set(presence) {
        const packet = this._parse(presence);
        this._patch(packet);
        if (presence.shardId === void 0) {
          this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        } else if (Array.isArray(presence.shardId)) {
          for (const shardId of presence.shardId) {
            this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
          }
        } else {
          this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
        return this;
      }
      /**
       * Parses presence data into a packet ready to be sent to Discord
       * @param {PresenceData} presence The data to parse
       * @returns {GatewayPresenceUpdateData}
       * @private
       */
      _parse({ status, since, afk, activities }) {
        const data = {
          activities: [],
          afk: typeof afk === "boolean" ? afk : false,
          since: typeof since === "number" && !Number.isNaN(since) ? since : null,
          status: status ?? this.status
        };
        if (activities == null ? void 0 : activities.length) {
          for (const [i, activity] of activities.entries()) {
            if (typeof activity.name !== "string") {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `activities[${i}].name`, "string");
            }
            activity.type ?? (activity.type = ActivityType.Playing);
            if (activity.type === ActivityType.Custom && !activity.state) {
              activity.state = activity.name;
              activity.name = "Custom Status";
            }
            data.activities.push({
              type: activity.type,
              name: activity.name,
              state: activity.state,
              url: activity.url
            });
          }
        } else if (!activities && (status || afk || since) && this.activities.length) {
          data.activities.push(
            ...this.activities.map((activity) => ({
              name: activity.name,
              state: activity.state ?? void 0,
              type: activity.type,
              url: activity.url ?? void 0
            }))
          );
        }
        return data;
      }
    };
    module2.exports = ClientPresence2;
  }
});

// node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS({
  "node_modules/discord.js/src/structures/StickerPack.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var { Sticker: Sticker2 } = require_Sticker();
    var StickerPack2 = class extends Base {
      constructor(client, pack) {
        super(client);
        this.id = pack.id;
        this.stickers = new Collection2(pack.stickers.map((sticker) => [sticker.id, new Sticker2(client, sticker)]));
        this.name = pack.name;
        this.skuId = pack.sku_id;
        this.coverStickerId = pack.cover_sticker_id ?? null;
        this.description = pack.description;
        this.bannerId = pack.banner_asset_id ?? null;
      }
      /**
       * The timestamp the sticker was created at
       * @type {number}
       * @readonly
       */
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      /**
       * The time the sticker was created at
       * @type {Date}
       * @readonly
       */
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      /**
       * The sticker which is shown as the pack's icon
       * @type {?Sticker}
       * @readonly
       */
      get coverSticker() {
        return this.coverStickerId && this.stickers.get(this.coverStickerId);
      }
      /**
       * The URL to this sticker pack's banner.
       * @param {ImageURLOptions} [options={}] Options for the image URL
       * @returns {?string}
       */
      bannerURL(options = {}) {
        return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
      }
    };
    module2.exports = StickerPack2;
  }
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS({
  "node_modules/discord.js/src/structures/VoiceRegion.js"(exports2, module2) {
    "use strict";
    var { flatten } = require_Util();
    var VoiceRegion2 = class {
      constructor(data) {
        this.id = data.id;
        this.name = data.name;
        this.deprecated = data.deprecated;
        this.optimal = data.optimal;
        this.custom = data.custom;
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = VoiceRegion2;
  }
});

// node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS({
  "node_modules/discord.js/src/structures/WidgetMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var WidgetMember = class extends Base {
      /**
       * Activity sent in a {@link WidgetMember}.
       * @typedef {Object} WidgetActivity
       * @property {string} name The name of the activity
       */
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.username = data.username;
        this.discriminator = data.discriminator;
        this.avatar = data.avatar;
        this.status = data.status;
        this.deaf = data.deaf ?? null;
        this.mute = data.mute ?? null;
        this.selfDeaf = data.self_deaf ?? null;
        this.selfMute = data.self_mute ?? null;
        this.suppress = data.suppress ?? null;
        this.channelId = data.channel_id ?? null;
        this.avatarURL = data.avatar_url;
        this.activity = data.activity ?? null;
      }
    };
    module2.exports = WidgetMember;
  }
});

// node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS({
  "node_modules/discord.js/src/structures/Widget.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist6();
    var { Routes: Routes2 } = require_v106();
    var Base = require_Base();
    var WidgetMember = require_WidgetMember();
    var Widget2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      /**
       * Represents a channel in a Widget
       * @typedef {Object} WidgetChannel
       * @property {Snowflake} id Id of the channel
       * @property {string} name Name of the channel
       * @property {number} position Position of the channel
       */
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("instant_invite" in data) {
          this.instantInvite = data.instant_invite;
        }
        this.channels = new Collection2();
        for (const channel of data.channels) {
          this.channels.set(channel.id, channel);
        }
        this.members = new Collection2();
        for (const member of data.members) {
          this.members.set(member.id, new WidgetMember(this.client, member));
        }
        if ("presence_count" in data) {
          this.presenceCount = data.presence_count;
        }
      }
      /**
       * Update the Widget.
       * @returns {Promise<Widget>}
       */
      async fetch() {
        const data = await this.client.rest.get(Routes2.guildWidgetJSON(this.id));
        this._patch(data);
        return this;
      }
      /**
       * Returns a URL for the PNG widget of the guild.
       * @param {GuildWidgetStyle} [style] The style for the widget image
       * @returns {string}
       */
      imageURL(style) {
        return this.client.guilds.widgetImageURL(this.id, style);
      }
    };
    module2.exports = Widget2;
  }
});

// node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS({
  "node_modules/discord.js/src/util/IntentsBitField.js"(exports2, module2) {
    "use strict";
    var { GatewayIntentBits } = require_v106();
    var BitField = require_BitField();
    var IntentsBitField2 = class extends BitField {
    };
    /**
     * Numeric WebSocket intents
     * @type {GatewayIntentBits}
     * @memberof IntentsBitField
     */
    __publicField(IntentsBitField2, "Flags", GatewayIntentBits);
    module2.exports = IntentsBitField2;
  }
});

// node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS({
  "node_modules/discord.js/src/util/Sweepers.js"(exports2, module2) {
    "use strict";
    var { setInterval: setInterval2, clearInterval: clearInterval2 } = require_node_timers();
    var { ThreadChannelTypes, SweeperKeys } = require_Constants();
    var Events2 = require_Events();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var Sweepers2 = class {
      constructor(client, options) {
        Object.defineProperty(this, "client", { value: client });
        this.options = options;
        this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
        for (const key of SweeperKeys) {
          if (!(key in options))
            continue;
          this._validateProperties(key);
          const clonedOptions = { ...this.options[key] };
          if (!("filter" in clonedOptions)) {
            switch (key) {
              case "invites":
                clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
                break;
              case "messages":
                clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
                break;
              case "threads":
                clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
            }
          }
          this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
        }
      }
      /**
       * Sweeps all guild and global application commands and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which commands will be removed from the caches.
       * @returns {number} Amount of commands that were removed from the caches
       */
      sweepApplicationCommands(filter) {
        var _a;
        const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
        const globalCommands = ((_a = this.client.application) == null ? void 0 : _a.commands.cache.sweep(filter)) ?? 0;
        this.client.emit(
          Events2.CacheSweep,
          `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`
        );
        return guildCommands + globalCommands;
      }
      /**
       * Sweeps all auto moderation rules and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine
       * which auto moderation rules will be removed from the caches
       * @returns {number} Amount of auto moderation rules that were removed from the caches
       */
      sweepAutoModerationRules(filter) {
        return this._sweepGuildDirectProp("autoModerationRules", filter).items;
      }
      /**
       * Sweeps all guild bans and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which bans will be removed from the caches.
       * @returns {number} Amount of bans that were removed from the caches
       */
      sweepBans(filter) {
        return this._sweepGuildDirectProp("bans", filter).items;
      }
      /**
       * Sweeps all guild emojis and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which emojis will be removed from the caches.
       * @returns {number} Amount of emojis that were removed from the caches
       */
      sweepEmojis(filter) {
        return this._sweepGuildDirectProp("emojis", filter).items;
      }
      /**
       * Sweeps all guild invites and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which invites will be removed from the caches.
       * @returns {number} Amount of invites that were removed from the caches
       */
      sweepInvites(filter) {
        return this._sweepGuildDirectProp("invites", filter).items;
      }
      /**
       * Sweeps all guild members and removes the ones which are indicated by the filter.
       * <info>It is highly recommended to keep the client guild member cached</info>
       * @param {Function} filter The function used to determine which guild members will be removed from the caches.
       * @returns {number} Amount of guild members that were removed from the caches
       */
      sweepGuildMembers(filter) {
        return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
      }
      /**
       * Sweeps all text-based channels' messages and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which messages will be removed from the caches.
       * @returns {number} Amount of messages that were removed from the caches
       * @example
       * // Remove all messages older than 1800 seconds from the messages cache
       * const amount = sweepers.sweepMessages(
       *   Sweepers.filterByLifetime({
       *     lifetime: 1800,
       *     getComparisonTimestamp: m => m.editedTimestamp ?? m.createdTimestamp,
       *   })(),
       * );
       * console.log(`Successfully removed ${amount} messages from the cache.`);
       */
      sweepMessages(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isTextBased())
            continue;
          channels++;
          messages += channel.messages.cache.sweep(filter);
        }
        this.client.emit(Events2.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
        return messages;
      }
      /**
       * Sweeps all presences and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which presences will be removed from the caches.
       * @returns {number} Amount of presences that were removed from the caches
       */
      sweepPresences(filter) {
        return this._sweepGuildDirectProp("presences", filter).items;
      }
      /**
       * Sweeps all message reactions and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which reactions will be removed from the caches.
       * @returns {number} Amount of reactions that were removed from the caches
       */
      sweepReactions(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        let reactions = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isTextBased())
            continue;
          channels++;
          for (const message of channel.messages.cache.values()) {
            messages++;
            reactions += message.reactions.cache.sweep(filter);
          }
        }
        this.client.emit(
          Events2.CacheSweep,
          `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`
        );
        return reactions;
      }
      /**
       * Sweeps all guild stage instances and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which stage instances will be removed from the caches.
       * @returns {number} Amount of stage instances that were removed from the caches
       */
      sweepStageInstances(filter) {
        return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
      }
      /**
       * Sweeps all guild stickers and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which stickers will be removed from the caches.
       * @returns {number} Amount of stickers that were removed from the caches
       */
      sweepStickers(filter) {
        return this._sweepGuildDirectProp("stickers", filter).items;
      }
      /**
       * Sweeps all thread members and removes the ones which are indicated by the filter.
       * <info>It is highly recommended to keep the client thread member cached</info>
       * @param {Function} filter The function used to determine which thread members will be removed from the caches.
       * @returns {number} Amount of thread members that were removed from the caches
       */
      sweepThreadMembers(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let threads = 0;
        let members = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!ThreadChannelTypes.includes(channel.type))
            continue;
          threads++;
          members += channel.members.cache.sweep(filter);
        }
        this.client.emit(Events2.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
        return members;
      }
      /**
       * Sweeps all threads and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which threads will be removed from the caches.
       * @returns {number} filter Amount of threads that were removed from the caches
       * @example
       * // Remove all threads archived greater than 1 day ago from all the channel caches
       * const amount = sweepers.sweepThreads(
       *   Sweepers.filterByLifetime({
       *     getComparisonTimestamp: t => t.archivedTimestamp,
       *     excludeFromSweep: t => !t.archived,
       *   })(),
       * );
       * console.log(`Successfully removed ${amount} threads from the cache.`);
       */
      sweepThreads(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let threads = 0;
        for (const [key, val] of this.client.channels.cache.entries()) {
          if (!ThreadChannelTypes.includes(val.type))
            continue;
          if (filter(val, key, this.client.channels.cache)) {
            threads++;
            this.client.channels._remove(key);
          }
        }
        this.client.emit(Events2.CacheSweep, `Swept ${threads} threads.`);
        return threads;
      }
      /**
       * Sweeps all users and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which users will be removed from the caches.
       * @returns {number} Amount of users that were removed from the caches
       */
      sweepUsers(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        const users = this.client.users.cache.sweep(filter);
        this.client.emit(Events2.CacheSweep, `Swept ${users} users.`);
        return users;
      }
      /**
       * Sweeps all guild voice states and removes the ones which are indicated by the filter.
       * @param {Function} filter The function used to determine which voice states will be removed from the caches.
       * @returns {number} Amount of voice states that were removed from the caches
       */
      sweepVoiceStates(filter) {
        return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
      }
      /**
       * Cancels all sweeping intervals
       * @returns {void}
       */
      destroy() {
        for (const key of SweeperKeys) {
          if (this.intervals[key])
            clearInterval2(this.intervals[key]);
        }
      }
      /**
       * Options for generating a filter function based on lifetime
       * @typedef {Object} LifetimeFilterOptions
       * @property {number} [lifetime=14400] How long, in seconds, an entry should stay in the collection
       * before it is considered sweepable.
       * @property {Function} [getComparisonTimestamp=e => e?.createdTimestamp] A function that takes an entry, key,
       * and the collection and returns a timestamp to compare against in order to determine the lifetime of the entry.
       * @property {Function} [excludeFromSweep=() => false] A function that takes an entry, key, and the collection
       * and returns a boolean, `true` when the entry should not be checked for sweepability.
       */
      /**
       * Create a sweepFilter function that uses a lifetime to determine sweepability.
       * @param {LifetimeFilterOptions} [options={}] The options used to generate the filter function
       * @returns {GlobalSweepFilter}
       */
      static filterByLifetime({
        lifetime = 14400,
        getComparisonTimestamp = (e) => e == null ? void 0 : e.createdTimestamp,
        excludeFromSweep = () => false
      } = {}) {
        if (typeof lifetime !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "lifetime", "number");
        }
        if (typeof getComparisonTimestamp !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "getComparisonTimestamp", "function");
        }
        if (typeof excludeFromSweep !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "excludeFromSweep", "function");
        }
        return () => {
          if (lifetime <= 0)
            return null;
          const lifetimeMs = lifetime * 1e3;
          const now = Date.now();
          return (entry, key, coll) => {
            if (excludeFromSweep(entry, key, coll)) {
              return false;
            }
            const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
            if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
              return false;
            return now - comparisonTimestamp > lifetimeMs;
          };
        };
      }
      /**
       * Creates a sweep filter that sweeps archived threads
       * @param {number} [lifetime=14400] How long a thread has to be archived to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static archivedThreadSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (e) => e.archiveTimestamp,
          excludeFromSweep: (e) => !e.archived
        });
      }
      /**
       * Creates a sweep filter that sweeps expired invites
       * @param {number} [lifetime=14400] How long ago an invite has to have expired to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static expiredInviteSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (i) => i.expiresTimestamp
        });
      }
      /**
       * Creates a sweep filter that sweeps outdated messages (edits taken into account)
       * @param {number} [lifetime=3600] How long ago a message has to have been sent or edited to be valid for sweeping
       * @returns {GlobalSweepFilter}
       */
      static outdatedMessageSweepFilter(lifetime = 3600) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
        });
      }
      /**
       * Configuration options for emitting the cache sweep client event
       * @typedef {Object} SweepEventOptions
       * @property {boolean} [emit=true] Whether to emit the client event in this method
       * @property {string} [outputName] A name to output in the client event if it should differ from the key
       * @private
       */
      /**
       * Sweep a direct sub property of all guilds
       * @param {string} key The name of the property
       * @param {Function} filter Filter function passed to sweep
       * @param {SweepEventOptions} [eventOptions={}] Options for the Client event emitted here
       * @returns {Object} Object containing the number of guilds swept and the number of items swept
       * @private
       */
      _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let guilds = 0;
        let items = 0;
        for (const guild of this.client.guilds.cache.values()) {
          const { cache } = guild[key];
          guilds++;
          items += cache.sweep(filter);
        }
        if (emit) {
          this.client.emit(Events2.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
        }
        return { guilds, items };
      }
      /**
       * Validates a set of properties
       * @param {string} key Key of the options object to check
       * @private
       */
      _validateProperties(key) {
        const props = this.options[key];
        if (typeof props !== "object") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}`, "object", true);
        }
        if (typeof props.interval !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.interval`, "number");
        }
        if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
          if (typeof props.lifetime !== "number") {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.lifetime`, "number");
          }
          return;
        }
        if (typeof props.filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.filter`, "function");
        }
      }
      /**
       * Initialize an interval for sweeping
       * @param {string} intervalKey The name of the property that stores the interval for this sweeper
       * @param {string} sweepKey The name of the function that sweeps the desired caches
       * @param {Object} opts Validated options for a sweep
       * @private
       */
      _initInterval(intervalKey, sweepKey, opts) {
        if (opts.interval <= 0 || opts.interval === Infinity)
          return;
        this.intervals[intervalKey] = setInterval2(() => {
          const sweepFn = opts.filter();
          if (sweepFn === null)
            return;
          if (typeof sweepFn !== "function")
            throw new DiscordjsTypeError2(ErrorCodes2.SweepFilterReturn);
          this[sweepKey](sweepFn);
        }, opts.interval * 1e3).unref();
      }
    };
    module2.exports = Sweepers2;
  }
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS({
  "node_modules/discord.js/src/client/Client.js"(exports, module) {
    "use strict";
    var process = require_node_process();
    var { Collection } = require_dist6();
    var { makeURLSearchParams } = require_web();
    var { OAuth2Scopes, Routes } = require_v106();
    var BaseClient = require_BaseClient();
    var ActionsManager = require_ActionsManager();
    var ClientVoiceManager = require_ClientVoiceManager();
    var WebSocketManager = require_WebSocketManager();
    var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
    var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    var ChannelManager = require_ChannelManager();
    var GuildManager = require_GuildManager();
    var UserManager = require_UserManager();
    var ShardClientUtil = require_ShardClientUtil();
    var ClientPresence = require_ClientPresence();
    var GuildPreview = require_GuildPreview();
    var GuildTemplate = require_GuildTemplate();
    var Invite = require_Invite();
    var { Sticker } = require_Sticker();
    var StickerPack = require_StickerPack();
    var VoiceRegion = require_VoiceRegion();
    var Webhook = require_Webhook();
    var Widget = require_Widget();
    var DataResolver = require_DataResolver();
    var Events = require_Events();
    var IntentsBitField = require_IntentsBitField();
    var Options = require_Options();
    var PermissionsBitField = require_PermissionsBitField();
    var Status = require_Status();
    var Sweepers = require_Sweepers();
    var deprecationEmittedForPremiumStickerPacks = false;
    var Client = class extends BaseClient {
      /**
       * @param {ClientOptions} options Options for the client
       */
      constructor(options) {
        super(options);
        const data = require_node_worker_threads().workerData ?? process.env;
        const defaults = Options.createDefault();
        if (this.options.shards === defaults.shards) {
          if ("SHARDS" in data) {
            this.options.shards = JSON.parse(data.SHARDS);
          }
        }
        if (this.options.shardCount === defaults.shardCount) {
          if ("SHARD_COUNT" in data) {
            this.options.shardCount = Number(data.SHARD_COUNT);
          } else if (Array.isArray(this.options.shards)) {
            this.options.shardCount = this.options.shards.length;
          }
        }
        const typeofShards = typeof this.options.shards;
        if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
          this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
        }
        if (typeofShards === "number")
          this.options.shards = [this.options.shards];
        if (Array.isArray(this.options.shards)) {
          this.options.shards = [
            ...new Set(
              this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0))
            )
          ];
        }
        this._validateOptions();
        this.ws = new WebSocketManager(this);
        this.actions = new ActionsManager(this);
        this.voice = new ClientVoiceManager(this);
        this.shard = process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;
        this.users = new UserManager(this);
        this.guilds = new GuildManager(this);
        this.channels = new ChannelManager(this);
        this.sweepers = new Sweepers(this, this.options.sweepers);
        this.presence = new ClientPresence(this, this.options.presence);
        Object.defineProperty(this, "token", { writable: true });
        if (!this.token && "DISCORD_TOKEN" in process.env) {
          this.token = process.env.DISCORD_TOKEN;
        } else {
          this.token = null;
        }
        this.user = null;
        this.application = null;
        this.readyTimestamp = null;
      }
      /**
       * All custom emojis that the client has access to, mapped by their ids
       * @type {BaseGuildEmojiManager}
       * @readonly
       */
      get emojis() {
        const emojis = new BaseGuildEmojiManager(this);
        for (const guild of this.guilds.cache.values()) {
          if (guild.available)
            for (const emoji of guild.emojis.cache.values())
              emojis.cache.set(emoji.id, emoji);
        }
        return emojis;
      }
      /**
       * Time at which the client was last regarded as being in the {@link Status.Ready} state
       * (each time the client disconnects and successfully reconnects, this will be overwritten)
       * @type {?Date}
       * @readonly
       */
      get readyAt() {
        return this.readyTimestamp && new Date(this.readyTimestamp);
      }
      /**
       * How long it has been since the client last entered the {@link Status.Ready} state in milliseconds
       * @type {?number}
       * @readonly
       */
      get uptime() {
        return this.readyTimestamp && Date.now() - this.readyTimestamp;
      }
      /**
       * Logs the client in, establishing a WebSocket connection to Discord.
       * @param {string} [token=this.token] Token of the account to log in with
       * @returns {Promise<string>} Token of the account used
       * @example
       * client.login('my token');
       */
      async login(token = this.token) {
        if (!token || typeof token !== "string")
          throw new DiscordjsError(ErrorCodes.TokenInvalid);
        this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
        this.rest.setToken(token);
        this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
        if (this.options.presence) {
          this.options.ws.presence = this.presence._parse(this.options.presence);
        }
        this.emit(Events.Debug, "Preparing to connect to the gateway...");
        try {
          await this.ws.connect();
          return this.token;
        } catch (error) {
          await this.destroy();
          throw error;
        }
      }
      /**
       * Returns whether the client has logged in, indicative of being able to access
       * properties such as `user` and `application`.
       * @returns {boolean}
       */
      isReady() {
        return !this.ws.destroyed && this.ws.status === Status.Ready;
      }
      /**
       * Logs out, terminates the connection to Discord, and destroys the client.
       * @returns {Promise<void>}
       */
      async destroy() {
        super.destroy();
        this.sweepers.destroy();
        await this.ws.destroy();
        this.token = null;
        this.rest.setToken(null);
      }
      /**
       * Options used when fetching an invite from Discord.
       * @typedef {Object} ClientFetchInviteOptions
       * @property {Snowflake} [guildScheduledEventId] The id of the guild scheduled event to include with
       * the invite
       */
      /**
       * Obtains an invite from Discord.
       * @param {InviteResolvable} invite Invite code or URL
       * @param {ClientFetchInviteOptions} [options] Options for fetching the invite
       * @returns {Promise<Invite>}
       * @example
       * client.fetchInvite('https://discord.gg/djs')
       *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))
       *   .catch(console.error);
       */
      async fetchInvite(invite, options) {
        const code = DataResolver.resolveInviteCode(invite);
        const query = makeURLSearchParams({
          with_counts: true,
          with_expiration: true,
          guild_scheduled_event_id: options == null ? void 0 : options.guildScheduledEventId
        });
        const data = await this.rest.get(Routes.invite(code), { query });
        return new Invite(this, data);
      }
      /**
       * Obtains a template from Discord.
       * @param {GuildTemplateResolvable} template Template code or URL
       * @returns {Promise<GuildTemplate>}
       * @example
       * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')
       *   .then(template => console.log(`Obtained template with code: ${template.code}`))
       *   .catch(console.error);
       */
      async fetchGuildTemplate(template) {
        const code = DataResolver.resolveGuildTemplateCode(template);
        const data = await this.rest.get(Routes.template(code));
        return new GuildTemplate(this, data);
      }
      /**
       * Obtains a webhook from Discord.
       * @param {Snowflake} id The webhook's id
       * @param {string} [token] Token for the webhook
       * @returns {Promise<Webhook>}
       * @example
       * client.fetchWebhook('id', 'token')
       *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))
       *   .catch(console.error);
       */
      async fetchWebhook(id, token) {
        const data = await this.rest.get(Routes.webhook(id, token), { auth: token === void 0 });
        return new Webhook(this, { token, ...data });
      }
      /**
       * Obtains the available voice regions from Discord.
       * @returns {Promise<Collection<string, VoiceRegion>>}
       * @example
       * client.fetchVoiceRegions()
       *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))
       *   .catch(console.error);
       */
      async fetchVoiceRegions() {
        const apiRegions = await this.rest.get(Routes.voiceRegions());
        const regions = new Collection();
        for (const region of apiRegions)
          regions.set(region.id, new VoiceRegion(region));
        return regions;
      }
      /**
       * Obtains a sticker from Discord.
       * @param {Snowflake} id The sticker's id
       * @returns {Promise<Sticker>}
       * @example
       * client.fetchSticker('id')
       *   .then(sticker => console.log(`Obtained sticker with name: ${sticker.name}`))
       *   .catch(console.error);
       */
      async fetchSticker(id) {
        const data = await this.rest.get(Routes.sticker(id));
        return new Sticker(this, data);
      }
      /**
       * Obtains the list of available sticker packs.
       * @returns {Promise<Collection<Snowflake, StickerPack>>}
       * @example
       * client.fetchStickerPacks()
       *   .then(packs => console.log(`Available sticker packs are: ${packs.map(pack => pack.name).join(', ')}`))
       *   .catch(console.error);
       */
      async fetchStickerPacks() {
        const data = await this.rest.get(Routes.stickerPacks());
        return new Collection(data.sticker_packs.map((stickerPack) => [stickerPack.id, new StickerPack(this, stickerPack)]));
      }
      /**
       * Obtains the list of available sticker packs.
       * @returns {Promise<Collection<Snowflake, StickerPack>>}
       * @deprecated Use {@link Client#fetchStickerPacks} instead.
       */
      fetchPremiumStickerPacks() {
        if (!deprecationEmittedForPremiumStickerPacks) {
          process.emitWarning(
            "The Client#fetchPremiumStickerPacks() method is deprecated. Use Client#fetchStickerPacks() instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForPremiumStickerPacks = true;
        }
        return this.fetchStickerPacks();
      }
      /**
       * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.
       * @param {GuildResolvable} guild The guild to fetch the preview for
       * @returns {Promise<GuildPreview>}
       */
      async fetchGuildPreview(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
        const data = await this.rest.get(Routes.guildPreview(id));
        return new GuildPreview(this, data);
      }
      /**
       * Obtains the widget data of a guild from Discord, available for guilds with the widget enabled.
       * @param {GuildResolvable} guild The guild to fetch the widget data for
       * @returns {Promise<Widget>}
       */
      async fetchGuildWidget(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
        const data = await this.rest.get(Routes.guildWidgetJSON(id));
        return new Widget(this, data);
      }
      /**
       * Options for {@link Client#generateInvite}.
       * @typedef {Object} InviteGenerationOptions
       * @property {OAuth2Scopes[]} scopes Scopes that should be requested
       * @property {PermissionResolvable} [permissions] Permissions to request
       * @property {GuildResolvable} [guild] Guild to preselect
       * @property {boolean} [disableGuildSelect] Whether to disable the guild selection
       */
      /**
       * Generates a link that can be used to invite the bot to a guild.
       * @param {InviteGenerationOptions} [options={}] Options for the invite
       * @returns {string}
       * @example
       * const link = client.generateInvite({
       *   scopes: [OAuth2Scopes.ApplicationsCommands],
       * });
       * console.log(`Generated application invite link: ${link}`);
       * @example
       * const link = client.generateInvite({
       *   permissions: [
       *     PermissionFlagsBits.SendMessages,
       *     PermissionFlagsBits.ManageGuild,
       *     PermissionFlagsBits.MentionEveryone,
       *   ],
       *   scopes: [OAuth2Scopes.Bot],
       * });
       * console.log(`Generated bot invite link: ${link}`);
       */
      generateInvite(options = {}) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
        if (!this.application)
          throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
        const { scopes } = options;
        if (scopes === void 0) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
        }
        if (!Array.isArray(scopes)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
        }
        if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
        }
        if (!scopes.includes(OAuth2Scopes.Bot) && options.permissions) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidScopesWithPermissions);
        }
        const validScopes = Object.values(OAuth2Scopes);
        const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
        if (invalidScope) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
        }
        const query = makeURLSearchParams({
          client_id: this.application.id,
          scope: scopes.join(" "),
          disable_guild_select: options.disableGuildSelect
        });
        if (options.permissions) {
          const permissions = PermissionsBitField.resolve(options.permissions);
          if (permissions)
            query.set("permissions", permissions.toString());
        }
        if (options.guild) {
          const guildId = this.guilds.resolveId(options.guild);
          if (!guildId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
          query.set("guild_id", guildId);
        }
        return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
      }
      toJSON() {
        return super.toJSON({
          actions: false,
          presence: false
        });
      }
      /**
       * Partially censored client token for debug logging purposes.
       * @type {?string}
       * @readonly
       * @private
       */
      get _censoredToken() {
        if (!this.token)
          return null;
        return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
      }
      /**
       * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script
       * with the client as `this`.
       * @param {string} script Script to eval
       * @returns {*}
       * @private
       */
      _eval(script) {
        return eval(script);
      }
      /**
       * Validates the client options.
       * @param {ClientOptions} [options=this.options] Options to validate
       * @private
       */
      _validateOptions(options = this.options) {
        if (options.intents === void 0) {
          throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
        } else {
          options.intents = new IntentsBitField(options.intents).freeze();
        }
        if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
        }
        if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
        }
        if (options.shards && !options.shards.length)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
        if (typeof options.makeCache !== "function") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
        }
        if (typeof options.sweepers !== "object" || options.sweepers === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
        }
        if (!Array.isArray(options.partials)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
        }
        if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
        }
        if (typeof options.failIfNotExists !== "boolean") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
        }
        if (typeof options.allowedMentions !== "object" && options.allowedMentions !== void 0 || options.allowedMentions === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "allowedMentions", "an object");
        }
        if (typeof options.presence !== "object" || options.presence === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "presence", "an object");
        }
        if (typeof options.ws !== "object" || options.ws === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "ws", "an object");
        }
        if (typeof options.rest !== "object" || options.rest === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "rest", "an object");
        }
        if (typeof options.jsonTransformer !== "function") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "jsonTransformer", "a function");
        }
      }
    };
    module.exports = Client;
  }
});

// browser-external:node:timers/promises
var require_promises3 = __commonJS({
  "browser-external:node:timers/promises"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:timers/promises" has been externalized for browser compatibility. Cannot access "node:timers/promises.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS({
  "node_modules/discord.js/src/util/ShardEvents.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Death: "death",
      Disconnect: "disconnect",
      Error: "error",
      Message: "message",
      Ready: "ready",
      Reconnecting: "reconnecting",
      Resume: "resume",
      Spawn: "spawn"
    };
  }
});

// browser-external:node:child_process
var require_node_child_process = __commonJS({
  "browser-external:node:child_process"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:child_process" has been externalized for browser compatibility. Cannot access "node:child_process.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS({
  "node_modules/discord.js/src/sharding/Shard.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var path = require_node_path();
    var process2 = require_node_process();
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require_node_timers();
    var { setTimeout: sleep } = require_promises3();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var ShardEvents = require_ShardEvents();
    var { makeError, makePlainError } = require_Util();
    var childProcess = null;
    var Worker = null;
    var Shard = class extends EventEmitter {
      constructor(manager, id) {
        super();
        switch (manager.mode) {
          case "process":
            childProcess = require_node_child_process();
            break;
          case "worker":
            Worker = require_node_worker_threads().Worker;
            break;
        }
        this.manager = manager;
        this.id = id;
        this.silent = manager.silent;
        this.args = manager.shardArgs ?? [];
        this.execArgv = manager.execArgv;
        this.env = Object.assign({}, process2.env, {
          SHARDING_MANAGER: true,
          SHARDS: this.id,
          SHARD_COUNT: this.manager.totalShards,
          DISCORD_TOKEN: this.manager.token
        });
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals = /* @__PURE__ */ new Map();
        this._fetches = /* @__PURE__ */ new Map();
        this._exitListener = null;
      }
      /**
       * Forks a child process or creates a worker thread for the shard.
       * <warn>You should not need to call this manually.</warn>
       * @param {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
       * before resolving (`-1` or `Infinity` for no wait)
       * @returns {Promise<ChildProcess>}
       */
      spawn(timeout = 3e4) {
        if (this.process)
          throw new DiscordjsError2(ErrorCodes2.ShardingProcessExists, this.id);
        if (this.worker)
          throw new DiscordjsError2(ErrorCodes2.ShardingWorkerExists, this.id);
        this._exitListener = this._handleExit.bind(this, void 0, timeout);
        switch (this.manager.mode) {
          case "process":
            this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
              env: this.env,
              execArgv: this.execArgv,
              silent: this.silent
            }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
            break;
          case "worker":
            this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
            break;
        }
        this._evals.clear();
        this._fetches.clear();
        const child = this.process ?? this.worker;
        this.emit(ShardEvents.Spawn, child);
        if (timeout === -1 || timeout === Infinity)
          return Promise.resolve(child);
        return new Promise((resolve, reject) => {
          const cleanup = () => {
            clearTimeout2(spawnTimeoutTimer);
            this.off("ready", onReady);
            this.off("disconnect", onDisconnect);
            this.off("death", onDeath);
          };
          const onReady = () => {
            cleanup();
            resolve(child);
          };
          const onDisconnect = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyDisconnected, this.id));
          };
          const onDeath = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyDied, this.id));
          };
          const onTimeout = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyTimeout, this.id));
          };
          const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
          this.once("ready", onReady);
          this.once("disconnect", onDisconnect);
          this.once("death", onDeath);
        });
      }
      /**
       * Immediately kills the shard's process/worker and does not restart it.
       */
      kill() {
        if (this.process) {
          this.process.removeListener("exit", this._exitListener);
          this.process.kill();
        } else {
          this.worker.removeListener("exit", this._exitListener);
          this.worker.terminate();
        }
        this._handleExit(false);
      }
      /**
       * Options used to respawn a shard.
       * @typedef {Object} ShardRespawnOptions
       * @property {number} [delay=500] How long to wait between killing the process/worker and
       * restarting it (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client}
       * has become ready before resolving (`-1` or `Infinity` for no wait)
       */
      /**
       * Kills and restarts the shard's process/worker.
       * @param {ShardRespawnOptions} [options] Options for respawning the shard
       * @returns {Promise<ChildProcess>}
       */
      async respawn({ delay = 500, timeout = 3e4 } = {}) {
        this.kill();
        if (delay > 0)
          await sleep(delay);
        return this.spawn(timeout);
      }
      /**
       * Sends a message to the shard's process/worker.
       * @param {*} message Message to send to the shard
       * @returns {Promise<Shard>}
       */
      send(message) {
        return new Promise((resolve, reject) => {
          if (this.process) {
            this.process.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve(this);
            });
          } else {
            this.worker.postMessage(message);
            resolve(this);
          }
        });
      }
      /**
       * Fetches a client property value of the shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @returns {Promise<*>}
       * @example
       * shard.fetchClientValue('guilds.cache.size')
       *   .then(count => console.log(`${count} guilds in shard ${shard.id}`))
       *   .catch(console.error);
       */
      fetchClientValue(prop) {
        if (!this.process && !this.worker) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoChildExists, this.id));
        }
        if (this._fetches.has(prop))
          return this._fetches.get(prop);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if ((message == null ? void 0 : message._fetchProp) !== prop)
              return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _fetchProp: prop }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            reject(err);
          });
        });
        this._fetches.set(prop, promise);
        return promise;
      }
      /**
       * Evaluates a script or function on the shard, in the context of the {@link Client}.
       * @param {string|Function} script JavaScript to run on the shard
       * @param {*} [context] The context for the eval
       * @returns {Promise<*>} Result of the script execution
       */
      eval(script2, context) {
        const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
        if (!this.process && !this.worker) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoChildExists, this.id));
        }
        if (this._evals.has(_eval))
          return this._evals.get(_eval);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if ((message == null ? void 0 : message._eval) !== _eval)
              return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _eval }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            reject(err);
          });
        });
        this._evals.set(_eval, promise);
        return promise;
      }
      /**
       * Handles a message received from the child process/worker.
       * @param {*} message Message received
       * @private
       */
      _handleMessage(message) {
        if (message) {
          if (message._ready) {
            this.ready = true;
            this.emit(ShardEvents.Ready);
            return;
          }
          if (message._disconnect) {
            this.ready = false;
            this.emit(ShardEvents.Disconnect);
            return;
          }
          if (message._reconnecting) {
            this.ready = false;
            this.emit(ShardEvents.Reconnecting);
            return;
          }
          if (message._resume) {
            this.ready = true;
            this.emit(ShardEvents.Resume);
            return;
          }
          if (message._sFetchProp) {
            const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
            this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: makePlainError(err) })
            );
            return;
          }
          if (message._sEval) {
            const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
            this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: makePlainError(err) })
            );
            return;
          }
          if (message._sRespawnAll) {
            const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
            this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
            });
            return;
          }
        }
        this.emit(ShardEvents.Message, message);
      }
      /**
       * Handles the shard's process/worker exiting.
       * @param {boolean} [respawn=this.manager.respawn] Whether to spawn the shard again
       * @param {number} [timeout] The amount in milliseconds to wait until the {@link Client}
       * has become ready (`-1` or `Infinity` for no wait)
       * @private
       */
      _handleExit(respawn = this.manager.respawn, timeout) {
        this.emit(ShardEvents.Death, this.process ?? this.worker);
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals.clear();
        this._fetches.clear();
        if (respawn)
          this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
      }
      /**
       * Increments max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      /**
       * Decrements max listeners by one for a given emitter, if they are not zero.
       * @param {EventEmitter|process} emitter The emitter that emits the events.
       * @private
       */
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = Shard;
  }
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS({
  "node_modules/discord.js/src/sharding/ShardingManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require_node_events();
    var fs = require_node_fs();
    var path = require_node_path();
    var process2 = require_node_process();
    var { setTimeout: sleep } = require_promises3();
    var { Collection: Collection2 } = require_dist6();
    var Shard = require_Shard();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors();
    var { fetchRecommendedShardCount } = require_Util();
    var ShardingManager = class extends EventEmitter {
      /**
       * The mode to spawn shards with for a {@link ShardingManager}. Can be either one of:
       * * 'process' to use child processes
       * * 'worker' to use [Worker threads](https://nodejs.org/api/worker_threads.html)
       * @typedef {string} ShardingManagerMode
       */
      /**
       * The options to spawn shards with for a {@link ShardingManager}.
       * @typedef {Object} ShardingManagerOptions
       * @property {string|number} [totalShards='auto'] Number of total shards of all shard managers or "auto"
       * @property {string|number[]} [shardList='auto'] List of shards to spawn or "auto"
       * @property {ShardingManagerMode} [mode='process'] Which mode to use for shards
       * @property {boolean} [respawn=true] Whether shards should automatically respawn upon exiting
       * @property {boolean} [silent=false] Whether to pass the silent flag to child process
       * (only available when mode is set to 'process')
       * @property {string[]} [shardArgs=[]] Arguments to pass to the shard script when spawning
       * (only available when mode is set to 'process')
       * @property {string[]} [execArgv=[]] Arguments to pass to the shard script executable when spawning
       * (only available when mode is set to 'process')
       * @property {string} [token] Token to use for automatic shard count and passing to shards
       */
      /**
       * @param {string} file Path to your shard script file
       * @param {ShardingManagerOptions} [options] Options for the sharding manager
       */
      constructor(file, options) {
        var _a;
        super();
        const _options = {
          totalShards: "auto",
          mode: "process",
          respawn: true,
          silent: false,
          shardArgs: [],
          execArgv: [],
          token: process2.env.DISCORD_TOKEN,
          ...options
        };
        this.file = file;
        if (!file)
          throw new DiscordjsError2(ErrorCodes2.ClientInvalidOption, "File", "specified.");
        if (!path.isAbsolute(file))
          this.file = path.resolve(process2.cwd(), file);
        const stats = fs.statSync(this.file);
        if (!stats.isFile())
          throw new DiscordjsError2(ErrorCodes2.ClientInvalidOption, "File", "a file");
        this.shardList = _options.shardList ?? "auto";
        if (this.shardList !== "auto") {
          if (!Array.isArray(this.shardList)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "shardList", "an array.");
          }
          this.shardList = [...new Set(this.shardList)];
          if (this.shardList.length < 1) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "shardList", "at least 1 id.");
          }
          if (this.shardList.some(
            (shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0
          )) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "shardList", "an array of positive integers.");
          }
        }
        this.totalShards = _options.totalShards || "auto";
        if (this.totalShards !== "auto") {
          if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "a number.");
          }
          if (this.totalShards < 1) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "at least 1.");
          }
          if (!Number.isInteger(this.totalShards)) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "an integer.");
          }
        }
        this.mode = _options.mode;
        if (this.mode !== "process" && this.mode !== "worker") {
          throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
        }
        this.respawn = _options.respawn;
        this.silent = _options.silent;
        this.shardArgs = _options.shardArgs;
        this.execArgv = _options.execArgv;
        this.token = ((_a = _options.token) == null ? void 0 : _a.replace(/^Bot\s*/i, "")) ?? null;
        this.shards = new Collection2();
        process2.env.SHARDING_MANAGER = true;
        process2.env.SHARDING_MANAGER_MODE = this.mode;
        process2.env.DISCORD_TOKEN = this.token;
      }
      /**
       * Creates a single shard.
       * <warn>Using this method is usually not necessary if you use the spawn method.</warn>
       * @param {number} [id=this.shards.size] Id of the shard to create
       * <info>This is usually not necessary to manually specify.</info>
       * @returns {Shard} Note that the created shard needs to be explicitly spawned using its spawn method.
       */
      createShard(id = this.shards.size) {
        const shard = new Shard(this, id);
        this.shards.set(id, shard);
        this.emit("shardCreate", shard);
        return shard;
      }
      /**
       * Options used to spawn multiple shards.
       * @typedef {Object} MultipleShardSpawnOptions
       * @property {number|string} [amount=this.totalShards] Number of shards to spawn
       * @property {number} [delay=5500] How long to wait in between spawning each shard (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
       */
      /**
       * Spawns multiple shards.
       * @param {MultipleShardSpawnOptions} [options] Options for spawning shards
       * @returns {Promise<Collection<number, Shard>>}
       */
      async spawn({ amount = this.totalShards, delay = 5500, timeout = 3e4 } = {}) {
        if (amount === "auto") {
          amount = await fetchRecommendedShardCount(this.token);
        } else {
          if (typeof amount !== "number" || isNaN(amount)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "a number.");
          }
          if (amount < 1)
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "at least 1.");
          if (!Number.isInteger(amount)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "an integer.");
          }
        }
        if (this.shards.size >= amount)
          throw new DiscordjsError2(ErrorCodes2.ShardingAlreadySpawned, this.shards.size);
        if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
          this.shardList = [...Array(amount).keys()];
        }
        if (this.totalShards === "auto" || this.totalShards !== amount) {
          this.totalShards = amount;
        }
        if (this.shardList.some((shardId) => shardId >= amount)) {
          throw new DiscordjsRangeError2(
            ErrorCodes2.ClientInvalidOption,
            "Amount of shards",
            "bigger than the highest shardId in the shardList option."
          );
        }
        for (const shardId of this.shardList) {
          const promises = [];
          const shard = this.createShard(shardId);
          promises.push(shard.spawn(timeout));
          if (delay > 0 && this.shards.size !== this.shardList.length)
            promises.push(sleep(delay));
          await Promise.all(promises);
        }
        return this.shards;
      }
      /**
       * Sends a message to all shards.
       * @param {*} message Message to be sent to the shards
       * @returns {Promise<Shard[]>}
       */
      broadcast(message) {
        const promises = [];
        for (const shard of this.shards.values())
          promises.push(shard.send(message));
        return Promise.all(promises);
      }
      /**
       * Options for {@link ShardingManager#broadcastEval} and {@link ShardClientUtil#broadcastEval}.
       * @typedef {Object} BroadcastEvalOptions
       * @property {number} [shard] Shard to run script on, all if undefined
       * @property {*} [context] The JSON-serializable values to call the script with
       */
      /**
       * Evaluates a script on all shards, or a given shard, in the context of the {@link Client}s.
       * @param {Function} script JavaScript to run on each shard
       * @param {BroadcastEvalOptions} [options={}] The options for the broadcast
       * @returns {Promise<*|Array<*>>} Results of the script execution
       */
      broadcastEval(script2, options = {}) {
        if (typeof script2 !== "function") {
          return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.ShardingInvalidEvalBroadcast));
        }
        return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
      }
      /**
       * Fetches a client property value of each shard, or a given shard.
       * @param {string} prop Name of the client property to get, using periods for nesting
       * @param {number} [shard] Shard to fetch property from, all if undefined
       * @returns {Promise<*|Array<*>>}
       * @example
       * manager.fetchClientValues('guilds.cache.size')
       *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
       *   .catch(console.error);
       */
      fetchClientValues(prop, shard) {
        return this._performOnShards("fetchClientValue", [prop], shard);
      }
      /**
       * Runs a method with given arguments on all shards, or a given shard.
       * @param {string} method Method name to run on each shard
       * @param {Array<*>} args Arguments to pass through to the method call
       * @param {number} [shard] Shard to run on, all if undefined
       * @returns {Promise<*|Array<*>>} Results of the method execution
       * @private
       */
      _performOnShards(method, args, shard) {
        if (this.shards.size === 0)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoShards));
        if (typeof shard === "number") {
          if (this.shards.has(shard))
            return this.shards.get(shard)[method](...args);
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingShardNotFound, shard));
        }
        if (this.shards.size !== this.shardList.length) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingInProcess));
        }
        const promises = [];
        for (const sh of this.shards.values())
          promises.push(sh[method](...args));
        return Promise.all(promises);
      }
      /**
       * Options used to respawn all shards.
       * @typedef {Object} MultipleShardRespawnOptions
       * @property {number} [shardDelay=5000] How long to wait between shards (in milliseconds)
       * @property {number} [respawnDelay=500] How long to wait between killing a shard's process and restarting it
       * (in milliseconds)
       * @property {number} [timeout=30000] The amount in milliseconds to wait for a shard to become ready before
       * continuing to another (`-1` or `Infinity` for no wait)
       */
      /**
       * Kills all running shards and respawns them.
       * @param {MultipleShardRespawnOptions} [options] Options for respawning shards
       * @returns {Promise<Collection<number, Shard>>}
       */
      async respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        let s = 0;
        for (const shard of this.shards.values()) {
          const promises = [shard.respawn({ delay: respawnDelay, timeout })];
          if (++s < this.shards.size && shardDelay > 0)
            promises.push(sleep(shardDelay));
          await Promise.all(promises);
        }
        return this.shards;
      }
    };
    module2.exports = ShardingManager;
  }
});

// node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS({
  "node_modules/discord.js/src/util/Formatters.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require_node_util();
    var {
      blockQuote,
      bold,
      channelMention,
      codeBlock,
      formatEmoji,
      hideLinkEmbed,
      hyperlink,
      inlineCode,
      italic,
      quote,
      roleMention,
      spoiler,
      strikethrough,
      time,
      TimestampStyles,
      underscore,
      userMention
    } = require_dist7();
    var Formatters = class extends null {
    };
    /**
     * Formats the content into a block quote.
     * <info>This needs to be at the start of the line for Discord to format it.</info>
     * @method blockQuote
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "blockQuote", deprecate(
      blockQuote,
      "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into bold text.
     * @method bold
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "bold", deprecate(
      bold,
      "Formatters.bold() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a channel id into a channel mention.
     * @method channelMention
     * @memberof Formatters
     * @param {Snowflake} channelId The channel id to format
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "channelMention", deprecate(
      channelMention,
      "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Wraps the content inside a code block with an optional language.
     * @method codeBlock
     * @memberof Formatters
     * @param {string} contentOrLanguage The language to use or content if a second parameter isn't provided
     * @param {string} [content] The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "codeBlock", deprecate(
      codeBlock,
      "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats an emoji id into a fully qualified emoji identifier.
     * @method formatEmoji
     * @memberof Formatters
     * @param {string} emojiId The emoji id to format
     * @param {boolean} [animated=false] Whether the emoji is animated
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "formatEmoji", deprecate(
      formatEmoji,
      "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Wraps the URL into `<>`, which stops it from embedding.
     * @method hideLinkEmbed
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "hideLinkEmbed", deprecate(
      hideLinkEmbed,
      "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content and the URL into a masked URL with an optional title.
     * @method hyperlink
     * @memberof Formatters
     * @param {string} content The content to display
     * @param {string} url The URL the content links to
     * @param {string} [title] The title shown when hovering on the masked link
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "hyperlink", deprecate(
      hyperlink,
      "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Wraps the content inside \`backticks\`, which formats it as inline code.
     * @method inlineCode
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "inlineCode", deprecate(
      inlineCode,
      "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into italic text.
     * @method italic
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "italic", deprecate(
      italic,
      "Formatters.italic() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into a quote. This needs to be at the start of the line for Discord to format it.
     * @method quote
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "quote", deprecate(
      quote,
      "Formatters.quote() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a role id into a role mention.
     * @method roleMention
     * @memberof Formatters
     * @param {Snowflake} roleId The role id to format
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "roleMention", deprecate(
      roleMention,
      "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into spoiler text.
     * @method spoiler
     * @memberof Formatters
     * @param {string} content The content to spoiler
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "spoiler", deprecate(
      spoiler,
      "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats the content into strike-through text.
     * @method strikethrough
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "strikethrough", deprecate(
      strikethrough,
      "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a date into a short date-time string.
     * @method time
     * @memberof Formatters
     * @param {number|Date} [date] The date to format
     * @param {TimestampStylesString} [style] The style to use
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "time", deprecate(
      time,
      "Formatters.time() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * The message formatting timestamp
     * [styles](https://discord.com/developers/docs/reference#message-formatting-timestamp-styles) supported by Discord.
     * @type {Object<string, TimestampStylesString>}
     * @memberof Formatters
     * @deprecated Import this property directly from discord.js instead.
     */
    __publicField(Formatters, "TimestampStyles", TimestampStyles);
    /**
     * Formats the content into underscored text.
     * @method underscore
     * @memberof Formatters
     * @param {string} content The content to wrap
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "underscore", deprecate(
      underscore,
      "Formatters.underscore() is deprecated. Import this method directly from discord.js instead."
    ));
    /**
     * Formats a user id into a user mention.
     * @method userMention
     * @memberof Formatters
     * @param {Snowflake} userId The user id to format
     * @returns {string}
     * @deprecated Import this method directly from discord.js instead.
     */
    __publicField(Formatters, "userMention", deprecate(
      userMention,
      "Formatters.userMention() is deprecated. Import this method directly from discord.js instead."
    ));
    module2.exports = Formatters;
  }
});

// node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS({
  "node_modules/discord.js/src/structures/EmbedBuilder.js"(exports2, module2) {
    "use strict";
    var { EmbedBuilder: BuildersEmbed, embedLength } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var { resolveColor } = require_Util();
    var EmbedBuilder = class extends BuildersEmbed {
      constructor(data) {
        super(toSnakeCase(data));
      }
      /**
       * Sets the color of this embed
       * @param {?ColorResolvable} color The color of the embed
       * @returns {EmbedBuilder}
       */
      setColor(color) {
        return super.setColor(color && resolveColor(color));
      }
      /**
       * Creates a new embed builder from JSON data
       * @param {EmbedBuilder|Embed|APIEmbed} other The other data
       * @returns {EmbedBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
      /**
       * The accumulated length for the embed title, description, fields, footer text, and author name.
       * @type {number}
       * @readonly
       */
      get length() {
        return embedLength(this.data);
      }
    };
    module2.exports = EmbedBuilder;
  }
});

// node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS({
  "node_modules/discord.js/src/structures/AttachmentBuilder.js"(exports2, module2) {
    "use strict";
    var { basename, flatten } = require_Util();
    var AttachmentBuilder = class _AttachmentBuilder {
      /**
       * @param {BufferResolvable|Stream} attachment The file
       * @param {AttachmentData} [data] Extra data
       */
      constructor(attachment, data = {}) {
        this.attachment = attachment;
        this.name = data.name;
        this.description = data.description;
      }
      /**
       * Sets the description of this attachment.
       * @param {string} description The description of the file
       * @returns {AttachmentBuilder} This attachment
       */
      setDescription(description) {
        this.description = description;
        return this;
      }
      /**
       * Sets the file of this attachment.
       * @param {BufferResolvable|Stream} attachment The file
       * @returns {AttachmentBuilder} This attachment
       */
      setFile(attachment) {
        this.attachment = attachment;
        return this;
      }
      /**
       * Sets the name of this attachment.
       * @param {string} name The name of the file
       * @returns {AttachmentBuilder} This attachment
       */
      setName(name) {
        this.name = name;
        return this;
      }
      /**
       * Sets whether this attachment is a spoiler
       * @param {boolean} [spoiler=true] Whether the attachment should be marked as a spoiler
       * @returns {AttachmentBuilder} This attachment
       */
      setSpoiler(spoiler = true) {
        if (spoiler === this.spoiler)
          return this;
        if (!spoiler) {
          while (this.spoiler) {
            this.name = this.name.slice("SPOILER_".length);
          }
          return this;
        }
        this.name = `SPOILER_${this.name}`;
        return this;
      }
      /**
       * Whether or not this attachment has been marked as a spoiler
       * @type {boolean}
       * @readonly
       */
      get spoiler() {
        return basename(this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return flatten(this);
      }
      /**
       * Makes a new builder instance from a preexisting attachment structure.
       * @param {AttachmentBuilder|Attachment|AttachmentPayload} other The builder to construct a new instance from
       * @returns {AttachmentBuilder}
       */
      static from(other) {
        return new _AttachmentBuilder(other.attachment, {
          name: other.name,
          description: other.description
        });
      }
    };
    module2.exports = AttachmentBuilder;
  }
});

// node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS({
  "node_modules/discord.js/src/structures/ModalBuilder.js"(exports2, module2) {
    "use strict";
    var { ModalBuilder: BuildersModal, ComponentBuilder } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var ModalBuilder = class extends BuildersModal {
      constructor({ components, ...data } = {}) {
        super({
          ...toSnakeCase(data),
          components: components == null ? void 0 : components.map(
            (component) => component instanceof ComponentBuilder ? component : toSnakeCase(component)
          )
        });
      }
      /**
       * Creates a new modal builder from JSON data
       * @param {ModalBuilder|APIModalComponent} other The other data
       * @returns {ModalBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = ModalBuilder;
  }
});

// node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
    var deprecationEmitted = false;
    var SelectMenuBuilder2 = class extends StringSelectMenuBuilder {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuBuilder2;
  }
});

// node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var StringSelectMenuComponent = require_StringSelectMenuComponent();
    var deprecationEmitted = false;
    var SelectMenuComponent = class extends StringSelectMenuComponent {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuComponent;
  }
});

// node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
    var deprecationEmitted = false;
    var SelectMenuInteraction = class extends StringSelectMenuInteraction {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuInteraction;
  }
});

// node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS({
  "node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js"(exports2, module2) {
    "use strict";
    var { SelectMenuOptionBuilder: BuildersSelectMenuOption } = require_dist8();
    var { isJSONEncodable } = require_dist();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var StringSelectMenuOptionBuilder = class extends BuildersSelectMenuOption {
      constructor({ emoji, ...data } = {}) {
        super(
          toSnakeCase({
            ...data,
            emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
          })
        );
      }
      /**
       * Sets the emoji to display on this option
       * @param {ComponentEmojiResolvable} emoji The emoji to display on this option
       * @returns {StringSelectMenuOptionBuilder}
       */
      setEmoji(emoji) {
        if (typeof emoji === "string") {
          return super.setEmoji(resolvePartialEmoji(emoji));
        }
        return super.setEmoji(emoji);
      }
      /**
       * Creates a new select menu option builder from JSON data
       * @param {StringSelectMenuOptionBuilder|APISelectMenuOption} other The other data
       * @returns {StringSelectMenuOptionBuilder}
       */
      static from(other) {
        return new this(isJSONEncodable(other) ? other.toJSON() : other);
      }
    };
    module2.exports = StringSelectMenuOptionBuilder;
  }
});

// node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS({
  "node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js"(exports2, module2) {
    "use strict";
    var process2 = require_node_process();
    var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
    var deprecationEmitted = false;
    var SelectMenuOptionBuilder2 = class extends StringSelectMenuOptionBuilder {
      constructor(...params) {
        super(...params);
        if (!deprecationEmitted) {
          process2.emitWarning(
            "The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.",
            "DeprecationWarning"
          );
          deprecationEmitted = true;
        }
      }
    };
    module2.exports = SelectMenuOptionBuilder2;
  }
});

// node_modules/discord.js/src/index.js
var require_src = __commonJS({
  "node_modules/discord.js/src/index.js"(exports2) {
    var { __exportStar: __exportStar2 } = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    exports2.BaseClient = require_BaseClient();
    exports2.Client = require_Client();
    exports2.Shard = require_Shard();
    exports2.ShardClientUtil = require_ShardClientUtil();
    exports2.ShardingManager = require_ShardingManager();
    exports2.WebhookClient = require_WebhookClient();
    exports2.DiscordjsError = require_DJSError().DiscordjsError;
    exports2.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
    exports2.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
    exports2.DiscordjsErrorCodes = require_ErrorCodes();
    exports2.ActivityFlagsBitField = require_ActivityFlagsBitField();
    exports2.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
    exports2.AttachmentFlagsBitField = require_AttachmentFlagsBitField();
    exports2.BaseManager = require_BaseManager();
    exports2.BitField = require_BitField();
    exports2.ChannelFlagsBitField = require_ChannelFlagsBitField();
    exports2.Collection = require_dist6().Collection;
    exports2.Constants = require_Constants();
    exports2.Colors = require_Colors();
    exports2.DataResolver = require_DataResolver();
    exports2.Events = require_Events();
    exports2.Formatters = require_Formatters();
    exports2.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
    exports2.IntentsBitField = require_IntentsBitField();
    exports2.LimitedCollection = require_LimitedCollection();
    exports2.MessageFlagsBitField = require_MessageFlagsBitField();
    exports2.Options = require_Options();
    exports2.Partials = require_Partials();
    exports2.PermissionsBitField = require_PermissionsBitField();
    exports2.RoleFlagsBitField = require_RoleFlagsBitField();
    exports2.ShardEvents = require_ShardEvents();
    exports2.Status = require_Status();
    exports2.SnowflakeUtil = require_dist3().DiscordSnowflake;
    exports2.Sweepers = require_Sweepers();
    exports2.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    exports2.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
    exports2.UserFlagsBitField = require_UserFlagsBitField();
    __exportStar2(require_Util(), exports2);
    exports2.WebSocketShardEvents = require_WebSocketShardEvents();
    exports2.version = require_package().version;
    exports2.ApplicationCommandManager = require_ApplicationCommandManager();
    exports2.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    exports2.AutoModerationRuleManager = require_AutoModerationRuleManager();
    exports2.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    exports2.CachedManager = require_CachedManager();
    exports2.ChannelManager = require_ChannelManager();
    exports2.ClientVoiceManager = require_ClientVoiceManager();
    exports2.DataManager = require_DataManager();
    exports2.DMMessageManager = require_DMMessageManager();
    exports2.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
    exports2.GuildBanManager = require_GuildBanManager();
    exports2.GuildChannelManager = require_GuildChannelManager();
    exports2.GuildEmojiManager = require_GuildEmojiManager();
    exports2.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    exports2.GuildForumThreadManager = require_GuildForumThreadManager();
    exports2.GuildInviteManager = require_GuildInviteManager();
    exports2.GuildManager = require_GuildManager();
    exports2.GuildMemberManager = require_GuildMemberManager();
    exports2.GuildMemberRoleManager = require_GuildMemberRoleManager();
    exports2.GuildMessageManager = require_GuildMessageManager();
    exports2.GuildScheduledEventManager = require_GuildScheduledEventManager();
    exports2.GuildStickerManager = require_GuildStickerManager();
    exports2.GuildTextThreadManager = require_GuildTextThreadManager();
    exports2.MessageManager = require_MessageManager();
    exports2.PermissionOverwriteManager = require_PermissionOverwriteManager();
    exports2.PresenceManager = require_PresenceManager();
    exports2.ReactionManager = require_ReactionManager();
    exports2.ReactionUserManager = require_ReactionUserManager();
    exports2.RoleManager = require_RoleManager();
    exports2.StageInstanceManager = require_StageInstanceManager();
    exports2.ThreadManager = require_ThreadManager();
    exports2.ThreadMemberManager = require_ThreadMemberManager();
    exports2.UserManager = require_UserManager();
    exports2.VoiceStateManager = require_VoiceStateManager();
    exports2.WebSocketManager = require_WebSocketManager();
    exports2.WebSocketShard = require_WebSocketShard();
    exports2.ActionRow = require_ActionRow();
    exports2.ActionRowBuilder = require_ActionRowBuilder();
    exports2.Activity = require_Presence().Activity;
    exports2.AnonymousGuild = require_AnonymousGuild();
    exports2.Application = require_Application();
    exports2.ApplicationCommand = require_ApplicationCommand();
    exports2.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
    exports2.AutocompleteInteraction = require_AutocompleteInteraction();
    exports2.AutoModerationActionExecution = require_AutoModerationActionExecution();
    exports2.AutoModerationRule = require_AutoModerationRule();
    exports2.Base = require_Base();
    exports2.BaseGuild = require_BaseGuild();
    exports2.BaseGuildEmoji = require_BaseGuildEmoji();
    exports2.BaseGuildTextChannel = require_BaseGuildTextChannel();
    exports2.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    exports2.ButtonBuilder = require_ButtonBuilder();
    exports2.ButtonComponent = require_ButtonComponent();
    exports2.ButtonInteraction = require_ButtonInteraction();
    exports2.CategoryChannel = require_CategoryChannel();
    exports2.BaseChannel = require_BaseChannel().BaseChannel;
    exports2.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
    exports2.ClientApplication = require_ClientApplication();
    exports2.ClientPresence = require_ClientPresence();
    exports2.ClientUser = require_ClientUser();
    exports2.CommandInteraction = require_CommandInteraction();
    exports2.Collector = require_Collector();
    exports2.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    exports2.Component = require_Component();
    exports2.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    exports2.DMChannel = require_DMChannel();
    exports2.Embed = require_Embed();
    exports2.EmbedBuilder = require_EmbedBuilder();
    exports2.Emoji = require_Emoji().Emoji;
    exports2.ForumChannel = require_ForumChannel();
    exports2.Guild = require_Guild().Guild;
    exports2.GuildAuditLogs = require_GuildAuditLogs();
    exports2.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    exports2.GuildBan = require_GuildBan();
    exports2.GuildChannel = require_GuildChannel();
    exports2.GuildEmoji = require_GuildEmoji();
    exports2.GuildMember = require_GuildMember().GuildMember;
    exports2.GuildOnboarding = require_GuildOnboarding().GuildOnboarding;
    exports2.GuildOnboardingPrompt = require_GuildOnboardingPrompt().GuildOnboardingPrompt;
    exports2.GuildOnboardingPromptOption = require_GuildOnboardingPromptOption().GuildOnboardingPromptOption;
    exports2.GuildPreview = require_GuildPreview();
    exports2.GuildPreviewEmoji = require_GuildPreviewEmoji();
    exports2.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
    exports2.GuildTemplate = require_GuildTemplate();
    exports2.Integration = require_Integration();
    exports2.IntegrationApplication = require_IntegrationApplication();
    exports2.BaseInteraction = require_BaseInteraction();
    exports2.InteractionCollector = require_InteractionCollector();
    exports2.InteractionResponse = require_InteractionResponse();
    exports2.InteractionWebhook = require_InteractionWebhook();
    exports2.Invite = require_Invite();
    exports2.InviteStageInstance = require_InviteStageInstance();
    exports2.InviteGuild = require_InviteGuild();
    exports2.Message = require_Message().Message;
    exports2.Attachment = require_Attachment();
    exports2.AttachmentBuilder = require_AttachmentBuilder();
    exports2.ModalBuilder = require_ModalBuilder();
    exports2.MediaChannel = require_MediaChannel();
    exports2.MessageCollector = require_MessageCollector();
    exports2.MessageComponentInteraction = require_MessageComponentInteraction();
    exports2.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
    exports2.MessageMentions = require_MessageMentions();
    exports2.MessagePayload = require_MessagePayload();
    exports2.MessageReaction = require_MessageReaction();
    exports2.ModalSubmitInteraction = require_ModalSubmitInteraction();
    exports2.ModalSubmitFields = require_ModalSubmitFields();
    exports2.NewsChannel = require_NewsChannel();
    exports2.OAuth2Guild = require_OAuth2Guild();
    exports2.PartialGroupDMChannel = require_PartialGroupDMChannel();
    exports2.PermissionOverwrites = require_PermissionOverwrites();
    exports2.Presence = require_Presence().Presence;
    exports2.ReactionCollector = require_ReactionCollector();
    exports2.ReactionEmoji = require_ReactionEmoji();
    exports2.RichPresenceAssets = require_Presence().RichPresenceAssets;
    exports2.Role = require_Role().Role;
    exports2.SelectMenuBuilder = require_SelectMenuBuilder();
    exports2.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
    exports2.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
    exports2.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
    exports2.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
    exports2.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
    exports2.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
    exports2.SelectMenuComponent = require_SelectMenuComponent();
    exports2.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
    exports2.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
    exports2.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
    exports2.StringSelectMenuComponent = require_StringSelectMenuComponent();
    exports2.UserSelectMenuComponent = require_UserSelectMenuComponent();
    exports2.SelectMenuInteraction = require_SelectMenuInteraction();
    exports2.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
    exports2.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
    exports2.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
    exports2.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
    exports2.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
    exports2.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
    exports2.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
    exports2.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
    exports2.StageChannel = require_StageChannel();
    exports2.StageInstance = require_StageInstance().StageInstance;
    exports2.Sticker = require_Sticker().Sticker;
    exports2.StickerPack = require_StickerPack();
    exports2.Team = require_Team();
    exports2.TeamMember = require_TeamMember();
    exports2.TextChannel = require_TextChannel();
    exports2.TextInputBuilder = require_TextInputBuilder();
    exports2.TextInputComponent = require_TextInputComponent();
    exports2.ThreadChannel = require_ThreadChannel();
    exports2.ThreadMember = require_ThreadMember();
    exports2.ThreadOnlyChannel = require_ThreadOnlyChannel();
    exports2.Typing = require_Typing();
    exports2.User = require_User();
    exports2.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
    exports2.VoiceChannel = require_VoiceChannel();
    exports2.VoiceRegion = require_VoiceRegion();
    exports2.VoiceState = require_VoiceState();
    exports2.Webhook = require_Webhook();
    exports2.Widget = require_Widget();
    exports2.WidgetMember = require_WidgetMember();
    exports2.WelcomeChannel = require_WelcomeChannel();
    exports2.WelcomeScreen = require_WelcomeScreen();
    __exportStar2(require_v106(), exports2);
    __exportStar2(require_dist8(), exports2);
    __exportStar2(require_dist7(), exports2);
    __exportStar2(require_web(), exports2);
    __exportStar2(require_dist(), exports2);
    __exportStar2(require_dist10(), exports2);
  }
});
export default require_src();
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

@sapphire/shapeshift/dist/cjs/index.cjs:
  (**
   * @license MIT
   * @copyright 2020 Colin McDonnell
   * @see https://github.com/colinhacks/zod/blob/master/LICENSE
   *)
*/
//# sourceMappingURL=discord__js.js.map
